// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package main

import "encoding/json"
import "fmt"
import "reflect"
import "time"

// UnmarshalJSON implements json.Unmarshaler.
func (j *MintBatteryOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["failedReason"]; !ok || v == nil {
		return fmt.Errorf("field failedReason in MintBatteryOutput: required")
	}
	if v, ok := raw["success"]; !ok || v == nil {
		return fmt.Errorf("field success in MintBatteryOutput: required")
	}
	type Plain MintBatteryOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MintBatteryOutput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NFTMetadata) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["attributes"]; !ok || v == nil {
		return fmt.Errorf("field attributes in NFTMetadata: required")
	}
	if v, ok := raw["description"]; !ok || v == nil {
		return fmt.Errorf("field description in NFTMetadata: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in NFTMetadata: required")
	}
	type Plain NFTMetadata
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = NFTMetadata(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AppId) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AppId {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AppId, v)
	}
	*j = AppId(v)
	return nil
}

const AppIdGameServiceMain AppId = "game-service-main"
const AppIdGraphqlService AppId = "graphql-service"
const AppIdPvpService AppId = "pvp-service"
const AppIdSceneDynamicService AppId = "scene-dynamic-service"
const AppIdWeb3Service AppId = "web3-service"

type AuthUserType string

var enumValues_AuthUserType = []interface{}{
	"MANAGER",
	"STUDENT",
	"TEACHER",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AuthUserType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AuthUserType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AuthUserType, v)
	}
	*j = AuthUserType(v)
	return nil
}

type Auth struct {
	// AccessToken corresponds to the JSON schema field "accessToken".
	AccessToken string `json:"accessToken" yaml:"accessToken" mapstructure:"accessToken"`

	// UserType corresponds to the JSON schema field "userType".
	UserType *AuthUserType `json:"userType,omitempty" yaml:"userType,omitempty" mapstructure:"userType,omitempty"`
}

const AuthUserTypeMANAGER AuthUserType = "MANAGER"
const AuthUserTypeSTUDENT AuthUserType = "STUDENT"
const AuthUserTypeTEACHER AuthUserType = "TEACHER"

// UnmarshalJSON implements json.Unmarshaler.
func (j *Auth) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["accessToken"]; !ok || v == nil {
		return fmt.Errorf("field accessToken in Auth: required")
	}
	type Plain Auth
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Auth(plain)
	return nil
}

type BatchBurnNFT struct {
	// index和itemIds一一对应
	// 所有数量
	Amounts []int `json:"amounts" yaml:"amounts" mapstructure:"amounts"`

	// ItemIds corresponds to the JSON schema field "itemIds".
	ItemIds []string `json:"itemIds,omitempty" yaml:"itemIds,omitempty" mapstructure:"itemIds,omitempty"`

	// NftIds corresponds to the JSON schema field "nftIds".
	NftIds []string `json:"nftIds,omitempty" yaml:"nftIds,omitempty" mapstructure:"nftIds,omitempty"`

	// 每个用户的消耗备注
	Remark string `json:"remark" yaml:"remark" mapstructure:"remark"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BatchBurnNFT) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["amounts"]; !ok || v == nil {
		return fmt.Errorf("field amounts in BatchBurnNFT: required")
	}
	if v, ok := raw["remark"]; !ok || v == nil {
		return fmt.Errorf("field remark in BatchBurnNFT: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId in BatchBurnNFT: required")
	}
	type Plain BatchBurnNFT
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BatchBurnNFT(plain)
	return nil
}

type BatchMintNFTQualitysElem string

var enumValues_BatchMintNFTQualitysElem = []interface{}{
	"Advanced",
	"Basic",
	"Enhanced",
	"Super",
	"Ultimate",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BatchMintNFTQualitysElem) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_BatchMintNFTQualitysElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_BatchMintNFTQualitysElem, v)
	}
	*j = BatchMintNFTQualitysElem(v)
	return nil
}

type BatchMintNFT struct {
	// index和itemIds一一对应
	// 所有数量
	Amounts []int `json:"amounts" yaml:"amounts" mapstructure:"amounts"`

	// 需要mint的所有的itemId
	ItemIds []string `json:"itemIds" yaml:"itemIds" mapstructure:"itemIds"`

	// 所有的品质
	// index和itemIds一一对应
	QualityVals []string `json:"qualityVals,omitempty" yaml:"qualityVals,omitempty" mapstructure:"qualityVals,omitempty"`

	// 所有的品质
	// index和itemIds一一对应
	Qualitys []BatchMintNFTQualitysElem `json:"qualitys,omitempty" yaml:"qualitys,omitempty" mapstructure:"qualitys,omitempty"`

	// Remark corresponds to the JSON schema field "remark".
	Remark string `json:"remark" yaml:"remark" mapstructure:"remark"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

const BatchMintNFTQualitysElemAdvanced BatchMintNFTQualitysElem = "Advanced"
const BatchMintNFTQualitysElemBasic BatchMintNFTQualitysElem = "Basic"
const BatchMintNFTQualitysElemEnhanced BatchMintNFTQualitysElem = "Enhanced"
const BatchMintNFTQualitysElemSuper BatchMintNFTQualitysElem = "Super"
const BatchMintNFTQualitysElemUltimate BatchMintNFTQualitysElem = "Ultimate"

// UnmarshalJSON implements json.Unmarshaler.
func (j *BatchMintNFT) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["amounts"]; !ok || v == nil {
		return fmt.Errorf("field amounts in BatchMintNFT: required")
	}
	if v, ok := raw["itemIds"]; !ok || v == nil {
		return fmt.Errorf("field itemIds in BatchMintNFT: required")
	}
	if v, ok := raw["remark"]; !ok || v == nil {
		return fmt.Errorf("field remark in BatchMintNFT: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId in BatchMintNFT: required")
	}
	type Plain BatchMintNFT
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BatchMintNFT(plain)
	return nil
}

// NFTAttribute 为产品定义的每个NFT的属性.
type NFTAttribute struct {
	// DisplayType corresponds to the JSON schema field "display_type".
	DisplayType *string `json:"display_type,omitempty" yaml:"display_type,omitempty" mapstructure:"display_type,omitempty"`

	// TraitType corresponds to the JSON schema field "trait_type".
	TraitType string `json:"trait_type" yaml:"trait_type" mapstructure:"trait_type"`

	// Value corresponds to the JSON schema field "value".
	Value string `json:"value" yaml:"value" mapstructure:"value"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NFTAttribute) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["trait_type"]; !ok || v == nil {
		return fmt.Errorf("field trait_type in NFTAttribute: required")
	}
	if v, ok := raw["value"]; !ok || v == nil {
		return fmt.Errorf("field value in NFTAttribute: required")
	}
	type Plain NFTAttribute
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = NFTAttribute(plain)
	return nil
}

type BatchMintNFTWithAttributes struct {
	// index和itemIds一一对应
	// 所有数量
	Amounts []int `json:"amounts" yaml:"amounts" mapstructure:"amounts"`

	// Attributes corresponds to the JSON schema field "attributes".
	Attributes []NFTAttribute `json:"attributes" yaml:"attributes" mapstructure:"attributes"`

	// 需要mint的所有的itemId
	ItemIds []string `json:"itemIds" yaml:"itemIds" mapstructure:"itemIds"`

	// Remark corresponds to the JSON schema field "remark".
	Remark string `json:"remark" yaml:"remark" mapstructure:"remark"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BatchMintNFTWithAttributes) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["amounts"]; !ok || v == nil {
		return fmt.Errorf("field amounts in BatchMintNFTWithAttributes: required")
	}
	if v, ok := raw["attributes"]; !ok || v == nil {
		return fmt.Errorf("field attributes in BatchMintNFTWithAttributes: required")
	}
	if v, ok := raw["itemIds"]; !ok || v == nil {
		return fmt.Errorf("field itemIds in BatchMintNFTWithAttributes: required")
	}
	if v, ok := raw["remark"]; !ok || v == nil {
		return fmt.Errorf("field remark in BatchMintNFTWithAttributes: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId in BatchMintNFTWithAttributes: required")
	}
	type Plain BatchMintNFTWithAttributes
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BatchMintNFTWithAttributes(plain)
	return nil
}

type BatchTransferNFT struct {
	// index和itemIds一一对应
	// 所有数量
	Amounts []int `json:"amounts" yaml:"amounts" mapstructure:"amounts"`

	// FromUserId corresponds to the JSON schema field "fromUserId".
	FromUserId string `json:"fromUserId" yaml:"fromUserId" mapstructure:"fromUserId"`

	// NftIds corresponds to the JSON schema field "nftIds".
	NftIds []string `json:"nftIds" yaml:"nftIds" mapstructure:"nftIds"`

	// 每个用户的消耗备注
	Remark string `json:"remark" yaml:"remark" mapstructure:"remark"`

	// ToUserId corresponds to the JSON schema field "toUserId".
	ToUserId string `json:"toUserId" yaml:"toUserId" mapstructure:"toUserId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BatchTransferNFT) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["amounts"]; !ok || v == nil {
		return fmt.Errorf("field amounts in BatchTransferNFT: required")
	}
	if v, ok := raw["fromUserId"]; !ok || v == nil {
		return fmt.Errorf("field fromUserId in BatchTransferNFT: required")
	}
	if v, ok := raw["nftIds"]; !ok || v == nil {
		return fmt.Errorf("field nftIds in BatchTransferNFT: required")
	}
	if v, ok := raw["remark"]; !ok || v == nil {
		return fmt.Errorf("field remark in BatchTransferNFT: required")
	}
	if v, ok := raw["toUserId"]; !ok || v == nil {
		return fmt.Errorf("field toUserId in BatchTransferNFT: required")
	}
	type Plain BatchTransferNFT
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BatchTransferNFT(plain)
	return nil
}

type BuildData struct {
	// 建造id
	BuildId int `json:"buildId" yaml:"buildId" mapstructure:"buildId"`

	// 下次可采集(偷取)的时间戳 单位秒
	CollectionAt int `json:"collectionAt" yaml:"collectionAt" mapstructure:"collectionAt"`

	// 可采集(偷取)物品数量统计
	CollectionItemCount int `json:"collectionItemCount" yaml:"collectionItemCount" mapstructure:"collectionItemCount"`

	// 采集开始时间点
	CollectionStartAt int `json:"collectionStartAt" yaml:"collectionStartAt" mapstructure:"collectionStartAt"`

	// 电量过期时间 单位秒
	ElectricEnd int `json:"electricEnd" yaml:"electricEnd" mapstructure:"electricEnd"`

	// 可以收集的时间
	HarvestAt int `json:"harvestAt" yaml:"harvestAt" mapstructure:"harvestAt"`

	// 可收获的物品数量统计(没电时转移到采集) 单位秒
	HarvestItemCount int `json:"harvestItemCount" yaml:"harvestItemCount" mapstructure:"harvestItemCount"`

	// 产出开始时间点.
	HarvestStartAt int `json:"harvestStartAt" yaml:"harvestStartAt" mapstructure:"harvestStartAt"`

	// LandIds corresponds to the JSON schema field "landIds".
	LandIds []int `json:"landIds" yaml:"landIds" mapstructure:"landIds"`

	// LandPlacementPowerZeroCooldownAt corresponds to the JSON schema field
	// "landPlacementPowerZeroCooldownAt".
	LandPlacementPowerZeroCooldownAt int `json:"landPlacementPowerZeroCooldownAt" yaml:"landPlacementPowerZeroCooldownAt" mapstructure:"landPlacementPowerZeroCooldownAt"`

	// LandPlacementPowerZeroCooldownStartAt corresponds to the JSON schema field
	// "landPlacementPowerZeroCooldownStartAt".
	LandPlacementPowerZeroCooldownStartAt int `json:"landPlacementPowerZeroCooldownStartAt" yaml:"landPlacementPowerZeroCooldownStartAt" mapstructure:"landPlacementPowerZeroCooldownStartAt"`

	// 地图id 为多地图准备
	MapId int `json:"mapId" yaml:"mapId" mapstructure:"mapId"`

	// nftId
	NftId string `json:"nftId" yaml:"nftId" mapstructure:"nftId"`

	// 玩家id
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BuildData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["buildId"]; !ok || v == nil {
		return fmt.Errorf("field buildId in BuildData: required")
	}
	if v, ok := raw["collectionAt"]; !ok || v == nil {
		return fmt.Errorf("field collectionAt in BuildData: required")
	}
	if v, ok := raw["collectionItemCount"]; !ok || v == nil {
		return fmt.Errorf("field collectionItemCount in BuildData: required")
	}
	if v, ok := raw["collectionStartAt"]; !ok || v == nil {
		return fmt.Errorf("field collectionStartAt in BuildData: required")
	}
	if v, ok := raw["electricEnd"]; !ok || v == nil {
		return fmt.Errorf("field electricEnd in BuildData: required")
	}
	if v, ok := raw["harvestAt"]; !ok || v == nil {
		return fmt.Errorf("field harvestAt in BuildData: required")
	}
	if v, ok := raw["harvestItemCount"]; !ok || v == nil {
		return fmt.Errorf("field harvestItemCount in BuildData: required")
	}
	if v, ok := raw["harvestStartAt"]; !ok || v == nil {
		return fmt.Errorf("field harvestStartAt in BuildData: required")
	}
	if v, ok := raw["landIds"]; !ok || v == nil {
		return fmt.Errorf("field landIds in BuildData: required")
	}
	if v, ok := raw["landPlacementPowerZeroCooldownAt"]; !ok || v == nil {
		return fmt.Errorf("field landPlacementPowerZeroCooldownAt in BuildData: required")
	}
	if v, ok := raw["landPlacementPowerZeroCooldownStartAt"]; !ok || v == nil {
		return fmt.Errorf("field landPlacementPowerZeroCooldownStartAt in BuildData: required")
	}
	if v, ok := raw["mapId"]; !ok || v == nil {
		return fmt.Errorf("field mapId in BuildData: required")
	}
	if v, ok := raw["nftId"]; !ok || v == nil {
		return fmt.Errorf("field nftId in BuildData: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId in BuildData: required")
	}
	type Plain BuildData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BuildData(plain)
	return nil
}

type BuildInput struct {
	// LandIds corresponds to the JSON schema field "landIds".
	LandIds []int `json:"landIds" yaml:"landIds" mapstructure:"landIds"`

	// 地图id 为多地图准备
	MapId int `json:"mapId" yaml:"mapId" mapstructure:"mapId"`

	// nftId
	NftId string `json:"nftId" yaml:"nftId" mapstructure:"nftId"`

	// 玩家id
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BuildInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["landIds"]; !ok || v == nil {
		return fmt.Errorf("field landIds in BuildInput: required")
	}
	if v, ok := raw["mapId"]; !ok || v == nil {
		return fmt.Errorf("field mapId in BuildInput: required")
	}
	if v, ok := raw["nftId"]; !ok || v == nil {
		return fmt.Errorf("field nftId in BuildInput: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId in BuildInput: required")
	}
	type Plain BuildInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BuildInput(plain)
	return nil
}

type BuildOutput struct {
	// 建造物信息
	BuildData *BuildData `json:"buildData,omitempty" yaml:"buildData,omitempty" mapstructure:"buildData,omitempty"`

	// 失败, 则返回失败原因, 否则返回空字符串
	FailedReason string `json:"failedReason" yaml:"failedReason" mapstructure:"failedReason"`

	// 是否成功
	Success bool `json:"success" yaml:"success" mapstructure:"success"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BuildOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["failedReason"]; !ok || v == nil {
		return fmt.Errorf("field failedReason in BuildOutput: required")
	}
	if v, ok := raw["success"]; !ok || v == nil {
		return fmt.Errorf("field success in BuildOutput: required")
	}
	type Plain BuildOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BuildOutput(plain)
	return nil
}

type DitaminBurnSource string

var enumValues_DitaminBurnSource = []interface{}{
	"build3drNFT",
	"buildNFT",
	"buyEnergy",
	"craft",
	"exchange",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DitaminBurnSource) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_DitaminBurnSource {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_DitaminBurnSource, v)
	}
	*j = DitaminBurnSource(v)
	return nil
}

type BurnDitaminInput struct {
	// 需要燃烧的ditamin数量
	Amount string `json:"amount" yaml:"amount" mapstructure:"amount"`

	// 燃烧的原因
	Source DitaminBurnSource `json:"source" yaml:"source" mapstructure:"source"`

	// 燃烧的hash id
	// 用来防止重复燃烧, 每次燃烧调用方需要生成一个txHash. 如果txHash重复, 则不会重复燃烧
	TxHash string `json:"txHash" yaml:"txHash" mapstructure:"txHash"`

	// 需要燃烧的用户id
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

const DitaminBurnSourceBuild3DrNFT DitaminBurnSource = "build3drNFT"
const DitaminBurnSourceBuildNFT DitaminBurnSource = "buildNFT"
const DitaminBurnSourceBuyEnergy DitaminBurnSource = "buyEnergy"
const DitaminBurnSourceCraft DitaminBurnSource = "craft"
const DitaminBurnSourceExchange DitaminBurnSource = "exchange"

// UnmarshalJSON implements json.Unmarshaler.
func (j *BurnDitaminInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["amount"]; !ok || v == nil {
		return fmt.Errorf("field amount in BurnDitaminInput: required")
	}
	if v, ok := raw["source"]; !ok || v == nil {
		return fmt.Errorf("field source in BurnDitaminInput: required")
	}
	if v, ok := raw["txHash"]; !ok || v == nil {
		return fmt.Errorf("field txHash in BurnDitaminInput: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId in BurnDitaminInput: required")
	}
	type Plain BurnDitaminInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BurnDitaminInput(plain)
	return nil
}

type BurnDitaminOutput struct {
	// 是否燃烧成功
	BurnSuccess bool `json:"burnSuccess" yaml:"burnSuccess" mapstructure:"burnSuccess"`

	// 如果燃烧失败, 则返回失败原因, 否则返回空字符串
	FailedReason string `json:"failedReason" yaml:"failedReason" mapstructure:"failedReason"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BurnDitaminOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["burnSuccess"]; !ok || v == nil {
		return fmt.Errorf("field burnSuccess in BurnDitaminOutput: required")
	}
	if v, ok := raw["failedReason"]; !ok || v == nil {
		return fmt.Errorf("field failedReason in BurnDitaminOutput: required")
	}
	type Plain BurnDitaminOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BurnDitaminOutput(plain)
	return nil
}

type CanBuildNFTInput struct {
	// 实体存活时间，对第三方NFT有效, 单位(秒)
	AliveTimeSec int `json:"aliveTimeSec" yaml:"aliveTimeSec" mapstructure:"aliveTimeSec"`

	// NFT Id
	NftId string `json:"nftId" yaml:"nftId" mapstructure:"nftId"`

	// 归属用户id
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CanBuildNFTInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["aliveTimeSec"]; !ok || v == nil {
		return fmt.Errorf("field aliveTimeSec in CanBuildNFTInput: required")
	}
	if v, ok := raw["nftId"]; !ok || v == nil {
		return fmt.Errorf("field nftId in CanBuildNFTInput: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId in CanBuildNFTInput: required")
	}
	type Plain CanBuildNFTInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CanBuildNFTInput(plain)
	return nil
}

type CanBuildNFTOutput struct {
	// CanBuild corresponds to the JSON schema field "canBuild".
	CanBuild bool `json:"canBuild" yaml:"canBuild" mapstructure:"canBuild"`

	// NFT id
	NftId string `json:"nftId" yaml:"nftId" mapstructure:"nftId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CanBuildNFTOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["canBuild"]; !ok || v == nil {
		return fmt.Errorf("field canBuild in CanBuildNFTOutput: required")
	}
	if v, ok := raw["nftId"]; !ok || v == nil {
		return fmt.Errorf("field nftId in CanBuildNFTOutput: required")
	}
	type Plain CanBuildNFTOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CanBuildNFTOutput(plain)
	return nil
}

type ChargedInput struct {
	// 建造id
	BuildId int `json:"buildId" yaml:"buildId" mapstructure:"buildId"`

	// 地图id 为多地图准备
	MapId int `json:"mapId" yaml:"mapId" mapstructure:"mapId"`

	// 电池数量
	Num int `json:"num" yaml:"num" mapstructure:"num"`

	// 玩家id
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ChargedInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["buildId"]; !ok || v == nil {
		return fmt.Errorf("field buildId in ChargedInput: required")
	}
	if v, ok := raw["mapId"]; !ok || v == nil {
		return fmt.Errorf("field mapId in ChargedInput: required")
	}
	if v, ok := raw["num"]; !ok || v == nil {
		return fmt.Errorf("field num in ChargedInput: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId in ChargedInput: required")
	}
	type Plain ChargedInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ChargedInput(plain)
	return nil
}

type ChargedOutput struct {
	// 失败, 则返回失败原因, 否则返回空字符串
	FailedReason string `json:"failedReason" yaml:"failedReason" mapstructure:"failedReason"`

	// 是否成功
	Success bool `json:"success" yaml:"success" mapstructure:"success"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ChargedOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["failedReason"]; !ok || v == nil {
		return fmt.Errorf("field failedReason in ChargedOutput: required")
	}
	if v, ok := raw["success"]; !ok || v == nil {
		return fmt.Errorf("field success in ChargedOutput: required")
	}
	type Plain ChargedOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ChargedOutput(plain)
	return nil
}

type CheckMultiBatchBurnNFTInput struct {
	// Inputs corresponds to the JSON schema field "inputs".
	Inputs []BatchBurnNFT `json:"inputs" yaml:"inputs" mapstructure:"inputs"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CheckMultiBatchBurnNFTInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["inputs"]; !ok || v == nil {
		return fmt.Errorf("field inputs in CheckMultiBatchBurnNFTInput: required")
	}
	type Plain CheckMultiBatchBurnNFTInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CheckMultiBatchBurnNFTInput(plain)
	return nil
}

type CheckMultiBatchBurnNFTOutput struct {
	// Results corresponds to the JSON schema field "results".
	Results []bool `json:"results" yaml:"results" mapstructure:"results"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CheckMultiBatchBurnNFTOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["results"]; !ok || v == nil {
		return fmt.Errorf("field results in CheckMultiBatchBurnNFTOutput: required")
	}
	type Plain CheckMultiBatchBurnNFTOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CheckMultiBatchBurnNFTOutput(plain)
	return nil
}

type CheckMultiBatchMintNFTWithAttributesInput struct {
	// Inputs corresponds to the JSON schema field "inputs".
	Inputs []BatchMintNFTWithAttributes `json:"inputs" yaml:"inputs" mapstructure:"inputs"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CheckMultiBatchMintNFTWithAttributesInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["inputs"]; !ok || v == nil {
		return fmt.Errorf("field inputs in CheckMultiBatchMintNFTWithAttributesInput: required")
	}
	type Plain CheckMultiBatchMintNFTWithAttributesInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CheckMultiBatchMintNFTWithAttributesInput(plain)
	return nil
}

type CheckMultiBatchMintNFTWithAttributesOutput struct {
	// Results corresponds to the JSON schema field "results".
	Results []bool `json:"results" yaml:"results" mapstructure:"results"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CheckMultiBatchMintNFTWithAttributesOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["results"]; !ok || v == nil {
		return fmt.Errorf("field results in CheckMultiBatchMintNFTWithAttributesOutput: required")
	}
	type Plain CheckMultiBatchMintNFTWithAttributesOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CheckMultiBatchMintNFTWithAttributesOutput(plain)
	return nil
}

type UseLUAUSD struct {
	// 和userId一一对应
	// 所有数量
	Amounts int `json:"amounts" yaml:"amounts" mapstructure:"amounts"`

	// 每个用户的消耗备注
	Remark string `json:"remark" yaml:"remark" mapstructure:"remark"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UseLUAUSD) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["amounts"]; !ok || v == nil {
		return fmt.Errorf("field amounts in UseLUAUSD: required")
	}
	if v, ok := raw["remark"]; !ok || v == nil {
		return fmt.Errorf("field remark in UseLUAUSD: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId in UseLUAUSD: required")
	}
	type Plain UseLUAUSD
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UseLUAUSD(plain)
	return nil
}

type CheckMultiUseLUAUSDInput struct {
	// Inputs corresponds to the JSON schema field "inputs".
	Inputs []UseLUAUSD `json:"inputs" yaml:"inputs" mapstructure:"inputs"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CheckMultiUseLUAUSDInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["inputs"]; !ok || v == nil {
		return fmt.Errorf("field inputs in CheckMultiUseLUAUSDInput: required")
	}
	type Plain CheckMultiUseLUAUSDInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CheckMultiUseLUAUSDInput(plain)
	return nil
}

type CheckMultiUseLUAUSDOutput struct {
	// Results corresponds to the JSON schema field "results".
	Results []bool `json:"results" yaml:"results" mapstructure:"results"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CheckMultiUseLUAUSDOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["results"]; !ok || v == nil {
		return fmt.Errorf("field results in CheckMultiUseLUAUSDOutput: required")
	}
	type Plain CheckMultiUseLUAUSDOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CheckMultiUseLUAUSDOutput(plain)
	return nil
}

type CheckQuestionAnswerInput struct {
	// AnswerJSON corresponds to the JSON schema field "answerJSON".
	AnswerJSON string `json:"answerJSON" yaml:"answerJSON" mapstructure:"answerJSON"`

	// QuestionId corresponds to the JSON schema field "questionId".
	QuestionId string `json:"questionId" yaml:"questionId" mapstructure:"questionId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CheckQuestionAnswerInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["answerJSON"]; !ok || v == nil {
		return fmt.Errorf("field answerJSON in CheckQuestionAnswerInput: required")
	}
	if v, ok := raw["questionId"]; !ok || v == nil {
		return fmt.Errorf("field questionId in CheckQuestionAnswerInput: required")
	}
	type Plain CheckQuestionAnswerInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CheckQuestionAnswerInput(plain)
	return nil
}

type CheckQuestionAnswerOutput struct {
	// IsCorrect corresponds to the JSON schema field "isCorrect".
	IsCorrect bool `json:"isCorrect" yaml:"isCorrect" mapstructure:"isCorrect"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CheckQuestionAnswerOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["isCorrect"]; !ok || v == nil {
		return fmt.Errorf("field isCorrect in CheckQuestionAnswerOutput: required")
	}
	type Plain CheckQuestionAnswerOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CheckQuestionAnswerOutput(plain)
	return nil
}

type CloseServer struct {
	// ServerAppId corresponds to the JSON schema field "serverAppId".
	ServerAppId string `json:"serverAppId" yaml:"serverAppId" mapstructure:"serverAppId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CloseServer) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["serverAppId"]; !ok || v == nil {
		return fmt.Errorf("field serverAppId in CloseServer: required")
	}
	type Plain CloseServer
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CloseServer(plain)
	return nil
}

type CollectionInput struct {
	// 建造Id
	BuildId int `json:"buildId" yaml:"buildId" mapstructure:"buildId"`

	// 地图id 为多地图准备
	MapId int `json:"mapId" yaml:"mapId" mapstructure:"mapId"`

	// 玩家id
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CollectionInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["buildId"]; !ok || v == nil {
		return fmt.Errorf("field buildId in CollectionInput: required")
	}
	if v, ok := raw["mapId"]; !ok || v == nil {
		return fmt.Errorf("field mapId in CollectionInput: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId in CollectionInput: required")
	}
	type Plain CollectionInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CollectionInput(plain)
	return nil
}

type CollectionOutput struct {
	// 失败, 则返回失败原因, 否则返回空字符串
	FailedReason string `json:"failedReason" yaml:"failedReason" mapstructure:"failedReason"`

	// 是否成功
	Success bool `json:"success" yaml:"success" mapstructure:"success"`
}

type AppId string

type CreatePVPRoomInput map[string]interface{}

type CreatePVPRoomOutput struct {
	// RoomId corresponds to the JSON schema field "roomId".
	RoomId string `json:"roomId" yaml:"roomId" mapstructure:"roomId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CreatePVPRoomOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["roomId"]; !ok || v == nil {
		return fmt.Errorf("field roomId in CreatePVPRoomOutput: required")
	}
	type Plain CreatePVPRoomOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CreatePVPRoomOutput(plain)
	return nil
}

type DeductUserExpInput struct {
	// DeductExp corresponds to the JSON schema field "deductExp".
	DeductExp int `json:"deductExp" yaml:"deductExp" mapstructure:"deductExp"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DeductUserExpInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["deductExp"]; !ok || v == nil {
		return fmt.Errorf("field deductExp in DeductUserExpInput: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId in DeductUserExpInput: required")
	}
	type Plain DeductUserExpInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = DeductUserExpInput(plain)
	return nil
}

type DeductUserExpOutput struct {
	// 是否扣除成功
	DeductSuccess bool `json:"deductSuccess" yaml:"deductSuccess" mapstructure:"deductSuccess"`

	// 如果扣除失败, 则返回失败原因, 否则返回空字符串
	FailedReason string `json:"failedReason" yaml:"failedReason" mapstructure:"failedReason"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DeductUserExpOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["deductSuccess"]; !ok || v == nil {
		return fmt.Errorf("field deductSuccess in DeductUserExpOutput: required")
	}
	if v, ok := raw["failedReason"]; !ok || v == nil {
		return fmt.Errorf("field failedReason in DeductUserExpOutput: required")
	}
	type Plain DeductUserExpOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = DeductUserExpOutput(plain)
	return nil
}

type DitaminBurn struct {
	// ditamin数量
	DitaminAmount string `json:"ditaminAmount" yaml:"ditaminAmount" mapstructure:"ditaminAmount"`

	// 消息版本号
	Etag int `json:"etag" yaml:"etag" mapstructure:"etag"`

	// 生产源
	Source DitaminBurnSource `json:"source" yaml:"source" mapstructure:"source"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DitaminBurn) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["ditaminAmount"]; !ok || v == nil {
		return fmt.Errorf("field ditaminAmount in DitaminBurn: required")
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag in DitaminBurn: required")
	}
	if v, ok := raw["source"]; !ok || v == nil {
		return fmt.Errorf("field source in DitaminBurn: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId in DitaminBurn: required")
	}
	type Plain DitaminBurn
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = DitaminBurn(plain)
	return nil
}

type DitaminProduceSource string

var enumValues_DitaminProduceSource = []interface{}{
	"attackFinlish",
	"deposit",
	"harvest",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DitaminProduceSource) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_DitaminProduceSource {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_DitaminProduceSource, v)
	}
	*j = DitaminProduceSource(v)
	return nil
}

type DitaminProduce struct {
	// ditamin数量
	DitaminAmount string `json:"ditaminAmount" yaml:"ditaminAmount" mapstructure:"ditaminAmount"`

	// 消息版本号
	Etag int `json:"etag" yaml:"etag" mapstructure:"etag"`

	// 生产源
	Source DitaminProduceSource `json:"source" yaml:"source" mapstructure:"source"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

const DitaminProduceSourceAttackFinlish DitaminProduceSource = "attackFinlish"
const DitaminProduceSourceDeposit DitaminProduceSource = "deposit"
const DitaminProduceSourceHarvest DitaminProduceSource = "harvest"

// UnmarshalJSON implements json.Unmarshaler.
func (j *DitaminProduce) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["ditaminAmount"]; !ok || v == nil {
		return fmt.Errorf("field ditaminAmount in DitaminProduce: required")
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag in DitaminProduce: required")
	}
	if v, ok := raw["source"]; !ok || v == nil {
		return fmt.Errorf("field source in DitaminProduce: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId in DitaminProduce: required")
	}
	type Plain DitaminProduce
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = DitaminProduce(plain)
	return nil
}

type ExecGameMessageInput struct {
	// Data corresponds to the JSON schema field "data".
	Data string `json:"data" yaml:"data" mapstructure:"data"`

	// EventId corresponds to the JSON schema field "eventId".
	EventId string `json:"eventId" yaml:"eventId" mapstructure:"eventId"`

	// GasFee corresponds to the JSON schema field "gasFee".
	GasFee string `json:"gasFee" yaml:"gasFee" mapstructure:"gasFee"`

	// Remark corresponds to the JSON schema field "remark".
	Remark string `json:"remark" yaml:"remark" mapstructure:"remark"`

	// Target corresponds to the JSON schema field "target".
	Target string `json:"target" yaml:"target" mapstructure:"target"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ExecGameMessageInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in ExecGameMessageInput: required")
	}
	if v, ok := raw["eventId"]; !ok || v == nil {
		return fmt.Errorf("field eventId in ExecGameMessageInput: required")
	}
	if v, ok := raw["gasFee"]; !ok || v == nil {
		return fmt.Errorf("field gasFee in ExecGameMessageInput: required")
	}
	if v, ok := raw["remark"]; !ok || v == nil {
		return fmt.Errorf("field remark in ExecGameMessageInput: required")
	}
	if v, ok := raw["target"]; !ok || v == nil {
		return fmt.Errorf("field target in ExecGameMessageInput: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId in ExecGameMessageInput: required")
	}
	type Plain ExecGameMessageInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ExecGameMessageInput(plain)
	return nil
}

type ExecGameMessageOutput struct {
	// MessageId corresponds to the JSON schema field "messageId".
	MessageId string `json:"messageId" yaml:"messageId" mapstructure:"messageId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ExecGameMessageOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["messageId"]; !ok || v == nil {
		return fmt.Errorf("field messageId in ExecGameMessageOutput: required")
	}
	type Plain ExecGameMessageOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ExecGameMessageOutput(plain)
	return nil
}

type FinishQuestion struct {
	// DiffcultyChange corresponds to the JSON schema field "diffcultyChange".
	DiffcultyChange float64 `json:"diffcultyChange" yaml:"diffcultyChange" mapstructure:"diffcultyChange"`

	// 消息版本号
	Etag int `json:"etag" yaml:"etag" mapstructure:"etag"`

	// Level corresponds to the JSON schema field "level".
	Level string `json:"level" yaml:"level" mapstructure:"level"`

	// QuestionId corresponds to the JSON schema field "questionId".
	QuestionId string `json:"questionId" yaml:"questionId" mapstructure:"questionId"`

	// Result corresponds to the JSON schema field "result".
	Result string `json:"result" yaml:"result" mapstructure:"result"`

	// Type corresponds to the JSON schema field "type".
	Type string `json:"type" yaml:"type" mapstructure:"type"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *FinishQuestion) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["diffcultyChange"]; !ok || v == nil {
		return fmt.Errorf("field diffcultyChange in FinishQuestion: required")
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag in FinishQuestion: required")
	}
	if v, ok := raw["level"]; !ok || v == nil {
		return fmt.Errorf("field level in FinishQuestion: required")
	}
	if v, ok := raw["questionId"]; !ok || v == nil {
		return fmt.Errorf("field questionId in FinishQuestion: required")
	}
	if v, ok := raw["result"]; !ok || v == nil {
		return fmt.Errorf("field result in FinishQuestion: required")
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type in FinishQuestion: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId in FinishQuestion: required")
	}
	type Plain FinishQuestion
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = FinishQuestion(plain)
	return nil
}

type ForgetUserRecipesInput struct {
	// RecipeIds corresponds to the JSON schema field "recipeIds".
	RecipeIds []string `json:"recipeIds" yaml:"recipeIds" mapstructure:"recipeIds"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ForgetUserRecipesInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["recipeIds"]; !ok || v == nil {
		return fmt.Errorf("field recipeIds in ForgetUserRecipesInput: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId in ForgetUserRecipesInput: required")
	}
	type Plain ForgetUserRecipesInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ForgetUserRecipesInput(plain)
	return nil
}

type ForgetUserRecipesOutput map[string]interface{}

type GameDataServiceAction string

var enumValues_GameDataServiceAction = []interface{}{
	"DeductUserExp",
	"GetPlayerItemSlots",
	"GetPlayerUsingNftsByUserId",
	"LandUsingSkill",
	"MultiGetPlayerInfoByUserId",
	"MultiGetPlayerUsingNftsByUserId",
	"UpgradePlayerItemSlots",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GameDataServiceAction) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_GameDataServiceAction {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_GameDataServiceAction, v)
	}
	*j = GameDataServiceAction(v)
	return nil
}

const GameDataServiceActionDeductUserExp GameDataServiceAction = "DeductUserExp"
const GameDataServiceActionGetPlayerItemSlots GameDataServiceAction = "GetPlayerItemSlots"
const GameDataServiceActionGetPlayerUsingNftsByUserId GameDataServiceAction = "GetPlayerUsingNftsByUserId"
const GameDataServiceActionLandUsingSkill GameDataServiceAction = "LandUsingSkill"
const GameDataServiceActionMultiGetPlayerInfoByUserId GameDataServiceAction = "MultiGetPlayerInfoByUserId"
const GameDataServiceActionMultiGetPlayerUsingNftsByUserId GameDataServiceAction = "MultiGetPlayerUsingNftsByUserId"
const GameDataServiceActionUpgradePlayerItemSlots GameDataServiceAction = "UpgradePlayerItemSlots"

type GetAllBuildDataInput struct {
	// 地图id 为多地图准备
	MapId int `json:"mapId" yaml:"mapId" mapstructure:"mapId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetAllBuildDataInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["mapId"]; !ok || v == nil {
		return fmt.Errorf("field mapId in GetAllBuildDataInput: required")
	}
	type Plain GetAllBuildDataInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetAllBuildDataInput(plain)
	return nil
}

type GetAllBuildDataOutput struct {
	// 全量建造物数据
	AllBuild []BuildData `json:"allBuild,omitempty" yaml:"allBuild,omitempty" mapstructure:"allBuild,omitempty"`

	// 失败, 则返回失败原因, 否则返回空字符串
	FailedReason string `json:"failedReason" yaml:"failedReason" mapstructure:"failedReason"`

	// 是否成功
	Success bool `json:"success" yaml:"success" mapstructure:"success"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetAllBuildDataOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["failedReason"]; !ok || v == nil {
		return fmt.Errorf("field failedReason in GetAllBuildDataOutput: required")
	}
	if v, ok := raw["success"]; !ok || v == nil {
		return fmt.Errorf("field success in GetAllBuildDataOutput: required")
	}
	type Plain GetAllBuildDataOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetAllBuildDataOutput(plain)
	return nil
}

type GetAllLandDataInput struct {
	// 地图id 为多地图准备
	MapId int `json:"mapId" yaml:"mapId" mapstructure:"mapId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetAllLandDataInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["mapId"]; !ok || v == nil {
		return fmt.Errorf("field mapId in GetAllLandDataInput: required")
	}
	type Plain GetAllLandDataInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetAllLandDataInput(plain)
	return nil
}

// 地格数据结构
type LandData struct {
	// 地格id地图唯一
	Id int `json:"id" yaml:"id" mapstructure:"id"`

	// 地图id 为多地图准备
	MapId int `json:"mapId" yaml:"mapId" mapstructure:"mapId"`

	// 占领时间 单位秒
	OccupyAt int `json:"occupyAt" yaml:"occupyAt" mapstructure:"occupyAt"`

	// owner userId
	OwnerId string `json:"ownerId" yaml:"ownerId" mapstructure:"ownerId"`

	// 占领过期时间 单位秒
	// 当地块上存在有电量建筑物时，
	// 该时间戳无效 || 在充电时更新该时间戳
	TimeoutAt int `json:"timeoutAt" yaml:"timeoutAt" mapstructure:"timeoutAt"`

	// 地格坐标
	X float64 `json:"x" yaml:"x" mapstructure:"x"`

	// Y corresponds to the JSON schema field "y".
	Y float64 `json:"y" yaml:"y" mapstructure:"y"`

	// Z corresponds to the JSON schema field "z".
	Z float64 `json:"z" yaml:"z" mapstructure:"z"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id in LandData: required")
	}
	if v, ok := raw["mapId"]; !ok || v == nil {
		return fmt.Errorf("field mapId in LandData: required")
	}
	if v, ok := raw["occupyAt"]; !ok || v == nil {
		return fmt.Errorf("field occupyAt in LandData: required")
	}
	if v, ok := raw["ownerId"]; !ok || v == nil {
		return fmt.Errorf("field ownerId in LandData: required")
	}
	if v, ok := raw["timeoutAt"]; !ok || v == nil {
		return fmt.Errorf("field timeoutAt in LandData: required")
	}
	if v, ok := raw["x"]; !ok || v == nil {
		return fmt.Errorf("field x in LandData: required")
	}
	if v, ok := raw["y"]; !ok || v == nil {
		return fmt.Errorf("field y in LandData: required")
	}
	if v, ok := raw["z"]; !ok || v == nil {
		return fmt.Errorf("field z in LandData: required")
	}
	type Plain LandData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = LandData(plain)
	return nil
}

type GetAllLandDataOutput struct {
	// 全量地格数据
	AllLandData []LandData `json:"allLandData,omitempty" yaml:"allLandData,omitempty" mapstructure:"allLandData,omitempty"`

	// 失败, 则返回失败原因, 否则返回空字符串
	FailedReason string `json:"failedReason" yaml:"failedReason" mapstructure:"failedReason"`

	// 是否成功
	Success bool `json:"success" yaml:"success" mapstructure:"success"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetAllLandDataOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["failedReason"]; !ok || v == nil {
		return fmt.Errorf("field failedReason in GetAllLandDataOutput: required")
	}
	if v, ok := raw["success"]; !ok || v == nil {
		return fmt.Errorf("field success in GetAllLandDataOutput: required")
	}
	type Plain GetAllLandDataOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetAllLandDataOutput(plain)
	return nil
}

type PVPUserType string

var enumValues_PVPUserType = []interface{}{
	"guest",
	"user",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PVPUserType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PVPUserType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PVPUserType, v)
	}
	*j = PVPUserType(v)
	return nil
}

type PVPPlayer struct {
	// Id corresponds to the JSON schema field "id".
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// Type corresponds to the JSON schema field "type".
	Type PVPUserType `json:"type" yaml:"type" mapstructure:"type"`
}

const PVPUserTypeGuest PVPUserType = "guest"
const PVPUserTypeUser PVPUserType = "user"

// UnmarshalJSON implements json.Unmarshaler.
func (j *PVPPlayer) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id in PVPPlayer: required")
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type in PVPPlayer: required")
	}
	type Plain PVPPlayer
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PVPPlayer(plain)
	return nil
}

type GetCurrentPkSessionIdInput struct {
	// Player corresponds to the JSON schema field "player".
	Player PVPPlayer `json:"player" yaml:"player" mapstructure:"player"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetCurrentPkSessionIdInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["player"]; !ok || v == nil {
		return fmt.Errorf("field player in GetCurrentPkSessionIdInput: required")
	}
	type Plain GetCurrentPkSessionIdInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetCurrentPkSessionIdInput(plain)
	return nil
}

type GetCurrentPkSessionIdOutput struct {
	// PkSessionId corresponds to the JSON schema field "pkSessionId".
	PkSessionId string `json:"pkSessionId" yaml:"pkSessionId" mapstructure:"pkSessionId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetCurrentPkSessionIdOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["pkSessionId"]; !ok || v == nil {
		return fmt.Errorf("field pkSessionId in GetCurrentPkSessionIdOutput: required")
	}
	type Plain GetCurrentPkSessionIdOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetCurrentPkSessionIdOutput(plain)
	return nil
}

type GetGameMessageStatusByIdInput struct {
	// MessageId corresponds to the JSON schema field "messageId".
	MessageId string `json:"messageId" yaml:"messageId" mapstructure:"messageId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetGameMessageStatusByIdInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["messageId"]; !ok || v == nil {
		return fmt.Errorf("field messageId in GetGameMessageStatusByIdInput: required")
	}
	type Plain GetGameMessageStatusByIdInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetGameMessageStatusByIdInput(plain)
	return nil
}

type GetGameMessageStatusByIdOutput struct {
	// Executed corresponds to the JSON schema field "executed".
	Executed bool `json:"executed" yaml:"executed" mapstructure:"executed"`

	// Reason corresponds to the JSON schema field "reason".
	Reason string `json:"reason" yaml:"reason" mapstructure:"reason"`

	// Success corresponds to the JSON schema field "success".
	Success bool `json:"success" yaml:"success" mapstructure:"success"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetGameMessageStatusByIdOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["executed"]; !ok || v == nil {
		return fmt.Errorf("field executed in GetGameMessageStatusByIdOutput: required")
	}
	if v, ok := raw["reason"]; !ok || v == nil {
		return fmt.Errorf("field reason in GetGameMessageStatusByIdOutput: required")
	}
	if v, ok := raw["success"]; !ok || v == nil {
		return fmt.Errorf("field success in GetGameMessageStatusByIdOutput: required")
	}
	type Plain GetGameMessageStatusByIdOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetGameMessageStatusByIdOutput(plain)
	return nil
}

type GetPlayerItemSlotsInput struct {
	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetPlayerItemSlotsInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId in GetPlayerItemSlotsInput: required")
	}
	type Plain GetPlayerItemSlotsInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetPlayerItemSlotsInput(plain)
	return nil
}

type PlayerItemSlot struct {
	// Level corresponds to the JSON schema field "level".
	Level int `json:"level" yaml:"level" mapstructure:"level"`

	// Position corresponds to the JSON schema field "position".
	Position int `json:"position" yaml:"position" mapstructure:"position"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PlayerItemSlot) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["level"]; !ok || v == nil {
		return fmt.Errorf("field level in PlayerItemSlot: required")
	}
	if v, ok := raw["position"]; !ok || v == nil {
		return fmt.Errorf("field position in PlayerItemSlot: required")
	}
	type Plain PlayerItemSlot
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PlayerItemSlot(plain)
	return nil
}

type GetPlayerItemSlotsOutput struct {
	// ItemSlots corresponds to the JSON schema field "itemSlots".
	ItemSlots []PlayerItemSlot `json:"itemSlots" yaml:"itemSlots" mapstructure:"itemSlots"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetPlayerItemSlotsOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["itemSlots"]; !ok || v == nil {
		return fmt.Errorf("field itemSlots in GetPlayerItemSlotsOutput: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId in GetPlayerItemSlotsOutput: required")
	}
	type Plain GetPlayerItemSlotsOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetPlayerItemSlotsOutput(plain)
	return nil
}

type GetPlayerPvpProfileInput struct {
	// PlayerId corresponds to the JSON schema field "playerId".
	PlayerId string `json:"playerId" yaml:"playerId" mapstructure:"playerId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetPlayerPvpProfileInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["playerId"]; !ok || v == nil {
		return fmt.Errorf("field playerId in GetPlayerPvpProfileInput: required")
	}
	type Plain GetPlayerPvpProfileInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetPlayerPvpProfileInput(plain)
	return nil
}

type PlayerAvatar struct {
	// Cid corresponds to the JSON schema field "cid".
	Cid int `json:"cid" yaml:"cid" mapstructure:"cid"`

	// NftId corresponds to the JSON schema field "nftId".
	NftId string `json:"nftId" yaml:"nftId" mapstructure:"nftId"`

	// NftJson corresponds to the JSON schema field "nftJson".
	NftJson string `json:"nftJson" yaml:"nftJson" mapstructure:"nftJson"`

	// Pos corresponds to the JSON schema field "pos".
	Pos int `json:"pos" yaml:"pos" mapstructure:"pos"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PlayerAvatar) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["cid"]; !ok || v == nil {
		return fmt.Errorf("field cid in PlayerAvatar: required")
	}
	if v, ok := raw["nftId"]; !ok || v == nil {
		return fmt.Errorf("field nftId in PlayerAvatar: required")
	}
	if v, ok := raw["nftJson"]; !ok || v == nil {
		return fmt.Errorf("field nftJson in PlayerAvatar: required")
	}
	if v, ok := raw["pos"]; !ok || v == nil {
		return fmt.Errorf("field pos in PlayerAvatar: required")
	}
	type Plain PlayerAvatar
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PlayerAvatar(plain)
	return nil
}

type PlayerInfo struct {
	// Icon corresponds to the JSON schema field "icon".
	Icon string `json:"icon" yaml:"icon" mapstructure:"icon"`

	// InviteCode corresponds to the JSON schema field "inviteCode".
	InviteCode string `json:"inviteCode" yaml:"inviteCode" mapstructure:"inviteCode"`

	// Level corresponds to the JSON schema field "level".
	Level int `json:"level" yaml:"level" mapstructure:"level"`

	// PlayerName corresponds to the JSON schema field "playerName".
	PlayerName string `json:"playerName" yaml:"playerName" mapstructure:"playerName"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PlayerInfo) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["icon"]; !ok || v == nil {
		return fmt.Errorf("field icon in PlayerInfo: required")
	}
	if v, ok := raw["inviteCode"]; !ok || v == nil {
		return fmt.Errorf("field inviteCode in PlayerInfo: required")
	}
	if v, ok := raw["level"]; !ok || v == nil {
		return fmt.Errorf("field level in PlayerInfo: required")
	}
	if v, ok := raw["playerName"]; !ok || v == nil {
		return fmt.Errorf("field playerName in PlayerInfo: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId in PlayerInfo: required")
	}
	type Plain PlayerInfo
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PlayerInfo(plain)
	return nil
}

type PvpPlayerProfile struct {
	// Avatars corresponds to the JSON schema field "avatars".
	Avatars []PlayerAvatar `json:"avatars" yaml:"avatars" mapstructure:"avatars"`

	// BaseInfo corresponds to the JSON schema field "baseInfo".
	BaseInfo PlayerInfo `json:"baseInfo" yaml:"baseInfo" mapstructure:"baseInfo"`

	// ItemSlots corresponds to the JSON schema field "itemSlots".
	ItemSlots []PlayerItemSlot `json:"itemSlots" yaml:"itemSlots" mapstructure:"itemSlots"`

	// PlayerId corresponds to the JSON schema field "playerId".
	PlayerId string `json:"playerId" yaml:"playerId" mapstructure:"playerId"`

	// Score corresponds to the JSON schema field "score".
	Score int `json:"score" yaml:"score" mapstructure:"score"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PvpPlayerProfile) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["avatars"]; !ok || v == nil {
		return fmt.Errorf("field avatars in PvpPlayerProfile: required")
	}
	if v, ok := raw["baseInfo"]; !ok || v == nil {
		return fmt.Errorf("field baseInfo in PvpPlayerProfile: required")
	}
	if v, ok := raw["itemSlots"]; !ok || v == nil {
		return fmt.Errorf("field itemSlots in PvpPlayerProfile: required")
	}
	if v, ok := raw["playerId"]; !ok || v == nil {
		return fmt.Errorf("field playerId in PvpPlayerProfile: required")
	}
	if v, ok := raw["score"]; !ok || v == nil {
		return fmt.Errorf("field score in PvpPlayerProfile: required")
	}
	type Plain PvpPlayerProfile
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PvpPlayerProfile(plain)
	return nil
}

type GetPlayerPvpProfileOutput struct {
	// Profile corresponds to the JSON schema field "profile".
	Profile PvpPlayerProfile `json:"profile" yaml:"profile" mapstructure:"profile"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetPlayerPvpProfileOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["profile"]; !ok || v == nil {
		return fmt.Errorf("field profile in GetPlayerPvpProfileOutput: required")
	}
	type Plain GetPlayerPvpProfileOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetPlayerPvpProfileOutput(plain)
	return nil
}

type GetPlayerPvpRankInput struct {
	// PlayerId corresponds to the JSON schema field "playerId".
	PlayerId string `json:"playerId" yaml:"playerId" mapstructure:"playerId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetPlayerPvpRankInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["playerId"]; !ok || v == nil {
		return fmt.Errorf("field playerId in GetPlayerPvpRankInput: required")
	}
	type Plain GetPlayerPvpRankInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetPlayerPvpRankInput(plain)
	return nil
}

type PvpPlayerRank struct {
	// Avatars corresponds to the JSON schema field "avatars".
	Avatars []PlayerAvatar `json:"avatars" yaml:"avatars" mapstructure:"avatars"`

	// BaseInfo corresponds to the JSON schema field "baseInfo".
	BaseInfo PlayerInfo `json:"baseInfo" yaml:"baseInfo" mapstructure:"baseInfo"`

	// PlayerId corresponds to the JSON schema field "playerId".
	PlayerId string `json:"playerId" yaml:"playerId" mapstructure:"playerId"`

	// Rank corresponds to the JSON schema field "rank".
	Rank int `json:"rank" yaml:"rank" mapstructure:"rank"`

	// Score corresponds to the JSON schema field "score".
	Score int `json:"score" yaml:"score" mapstructure:"score"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PvpPlayerRank) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["avatars"]; !ok || v == nil {
		return fmt.Errorf("field avatars in PvpPlayerRank: required")
	}
	if v, ok := raw["baseInfo"]; !ok || v == nil {
		return fmt.Errorf("field baseInfo in PvpPlayerRank: required")
	}
	if v, ok := raw["playerId"]; !ok || v == nil {
		return fmt.Errorf("field playerId in PvpPlayerRank: required")
	}
	if v, ok := raw["rank"]; !ok || v == nil {
		return fmt.Errorf("field rank in PvpPlayerRank: required")
	}
	if v, ok := raw["score"]; !ok || v == nil {
		return fmt.Errorf("field score in PvpPlayerRank: required")
	}
	type Plain PvpPlayerRank
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PvpPlayerRank(plain)
	return nil
}

type GetPlayerPvpRankOutput struct {
	// RankList corresponds to the JSON schema field "rankList".
	RankList []PvpPlayerRank `json:"rankList" yaml:"rankList" mapstructure:"rankList"`

	// SelfRank corresponds to the JSON schema field "selfRank".
	SelfRank PvpPlayerRank `json:"selfRank" yaml:"selfRank" mapstructure:"selfRank"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetPlayerPvpRankOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["rankList"]; !ok || v == nil {
		return fmt.Errorf("field rankList in GetPlayerPvpRankOutput: required")
	}
	if v, ok := raw["selfRank"]; !ok || v == nil {
		return fmt.Errorf("field selfRank in GetPlayerPvpRankOutput: required")
	}
	type Plain GetPlayerPvpRankOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetPlayerPvpRankOutput(plain)
	return nil
}

type GetPlayerUsingNftsByUserIdInput struct {
	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetPlayerUsingNftsByUserIdInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId in GetPlayerUsingNftsByUserIdInput: required")
	}
	type Plain GetPlayerUsingNftsByUserIdInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetPlayerUsingNftsByUserIdInput(plain)
	return nil
}

type UsingNFT struct {
	// 装备位置 对时装和装备有效
	AvatarPos int `json:"avatarPos" yaml:"avatarPos" mapstructure:"avatarPos"`

	// Cid corresponds to the JSON schema field "cid".
	Cid int `json:"cid" yaml:"cid" mapstructure:"cid"`

	// NftId corresponds to the JSON schema field "nftId".
	NftId string `json:"nftId" yaml:"nftId" mapstructure:"nftId"`

	// 游戏角色id
	PlayerId string `json:"playerId" yaml:"playerId" mapstructure:"playerId"`

	// 用户id
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UsingNFT) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["avatarPos"]; !ok || v == nil {
		return fmt.Errorf("field avatarPos in UsingNFT: required")
	}
	if v, ok := raw["cid"]; !ok || v == nil {
		return fmt.Errorf("field cid in UsingNFT: required")
	}
	if v, ok := raw["nftId"]; !ok || v == nil {
		return fmt.Errorf("field nftId in UsingNFT: required")
	}
	if v, ok := raw["playerId"]; !ok || v == nil {
		return fmt.Errorf("field playerId in UsingNFT: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId in UsingNFT: required")
	}
	type Plain UsingNFT
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UsingNFT(plain)
	return nil
}

type GetPlayerUsingNftsByUserIdOutput struct {
	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`

	// UsingNfts corresponds to the JSON schema field "usingNfts".
	UsingNfts []UsingNFT `json:"usingNfts" yaml:"usingNfts" mapstructure:"usingNfts"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetPlayerUsingNftsByUserIdOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId in GetPlayerUsingNftsByUserIdOutput: required")
	}
	if v, ok := raw["usingNfts"]; !ok || v == nil {
		return fmt.Errorf("field usingNfts in GetPlayerUsingNftsByUserIdOutput: required")
	}
	type Plain GetPlayerUsingNftsByUserIdOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetPlayerUsingNftsByUserIdOutput(plain)
	return nil
}

type GetPvpHistoryInput struct {
	// PlayerId corresponds to the JSON schema field "playerId".
	PlayerId string `json:"playerId" yaml:"playerId" mapstructure:"playerId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetPvpHistoryInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["playerId"]; !ok || v == nil {
		return fmt.Errorf("field playerId in GetPvpHistoryInput: required")
	}
	type Plain GetPvpHistoryInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetPvpHistoryInput(plain)
	return nil
}

type PvpHistory struct {
	// EndType corresponds to the JSON schema field "endType".
	EndType string `json:"endType" yaml:"endType" mapstructure:"endType"`

	// Loser corresponds to the JSON schema field "loser".
	Loser string `json:"loser" yaml:"loser" mapstructure:"loser"`

	// LoserName corresponds to the JSON schema field "loserName".
	LoserName string `json:"loserName" yaml:"loserName" mapstructure:"loserName"`

	// LoserScore corresponds to the JSON schema field "loserScore".
	LoserScore int `json:"loserScore" yaml:"loserScore" mapstructure:"loserScore"`

	// PvpType corresponds to the JSON schema field "pvpType".
	PvpType string `json:"pvpType" yaml:"pvpType" mapstructure:"pvpType"`

	// ScoreOffset corresponds to the JSON schema field "scoreOffset".
	ScoreOffset int `json:"scoreOffset" yaml:"scoreOffset" mapstructure:"scoreOffset"`

	// TimeSec corresponds to the JSON schema field "timeSec".
	TimeSec int `json:"timeSec" yaml:"timeSec" mapstructure:"timeSec"`

	// Winner corresponds to the JSON schema field "winner".
	Winner string `json:"winner" yaml:"winner" mapstructure:"winner"`

	// WinnerName corresponds to the JSON schema field "winnerName".
	WinnerName string `json:"winnerName" yaml:"winnerName" mapstructure:"winnerName"`

	// WinnerScore corresponds to the JSON schema field "winnerScore".
	WinnerScore int `json:"winnerScore" yaml:"winnerScore" mapstructure:"winnerScore"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PvpHistory) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["endType"]; !ok || v == nil {
		return fmt.Errorf("field endType in PvpHistory: required")
	}
	if v, ok := raw["loser"]; !ok || v == nil {
		return fmt.Errorf("field loser in PvpHistory: required")
	}
	if v, ok := raw["loserName"]; !ok || v == nil {
		return fmt.Errorf("field loserName in PvpHistory: required")
	}
	if v, ok := raw["loserScore"]; !ok || v == nil {
		return fmt.Errorf("field loserScore in PvpHistory: required")
	}
	if v, ok := raw["pvpType"]; !ok || v == nil {
		return fmt.Errorf("field pvpType in PvpHistory: required")
	}
	if v, ok := raw["scoreOffset"]; !ok || v == nil {
		return fmt.Errorf("field scoreOffset in PvpHistory: required")
	}
	if v, ok := raw["timeSec"]; !ok || v == nil {
		return fmt.Errorf("field timeSec in PvpHistory: required")
	}
	if v, ok := raw["winner"]; !ok || v == nil {
		return fmt.Errorf("field winner in PvpHistory: required")
	}
	if v, ok := raw["winnerName"]; !ok || v == nil {
		return fmt.Errorf("field winnerName in PvpHistory: required")
	}
	if v, ok := raw["winnerScore"]; !ok || v == nil {
		return fmt.Errorf("field winnerScore in PvpHistory: required")
	}
	type Plain PvpHistory
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PvpHistory(plain)
	return nil
}

type GetPvpHistoryOutput struct {
	// HistoryList corresponds to the JSON schema field "historyList".
	HistoryList []PvpHistory `json:"historyList" yaml:"historyList" mapstructure:"historyList"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetPvpHistoryOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["historyList"]; !ok || v == nil {
		return fmt.Errorf("field historyList in GetPvpHistoryOutput: required")
	}
	type Plain GetPvpHistoryOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetPvpHistoryOutput(plain)
	return nil
}

type GetQuestionResourcesByTypesInput struct {
	// Types corresponds to the JSON schema field "types".
	Types []string `json:"types" yaml:"types" mapstructure:"types"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetQuestionResourcesByTypesInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["types"]; !ok || v == nil {
		return fmt.Errorf("field types in GetQuestionResourcesByTypesInput: required")
	}
	type Plain GetQuestionResourcesByTypesInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetQuestionResourcesByTypesInput(plain)
	return nil
}

type QuestionType string

var enumValues_QuestionType = []interface{}{
	"AdjustClock",
	"BlockCompute",
	"CageShuffle",
	"CardMemory",
	"CuttingArt",
	"HitBrick",
	"MatchingMouse",
	"QuickFlashMemory",
	"ReverseMemory",
	"RotatingSilhouette",
	"SequenceBalloon",
	"SingleChoice",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *QuestionType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_QuestionType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_QuestionType, v)
	}
	*j = QuestionType(v)
	return nil
}

const QuestionTypeAdjustClock QuestionType = "AdjustClock"
const QuestionTypeBlockCompute QuestionType = "BlockCompute"
const QuestionTypeCageShuffle QuestionType = "CageShuffle"
const QuestionTypeCardMemory QuestionType = "CardMemory"
const QuestionTypeCuttingArt QuestionType = "CuttingArt"
const QuestionTypeHitBrick QuestionType = "HitBrick"
const QuestionTypeMatchingMouse QuestionType = "MatchingMouse"
const QuestionTypeQuickFlashMemory QuestionType = "QuickFlashMemory"
const QuestionTypeReverseMemory QuestionType = "ReverseMemory"
const QuestionTypeRotatingSilhouette QuestionType = "RotatingSilhouette"
const QuestionTypeSequenceBalloon QuestionType = "SequenceBalloon"
const QuestionTypeSingleChoice QuestionType = "SingleChoice"

type Prefetch struct {
	// QuestionId corresponds to the JSON schema field "questionId".
	QuestionId string `json:"questionId" yaml:"questionId" mapstructure:"questionId"`

	// QuestionType corresponds to the JSON schema field "questionType".
	QuestionType QuestionType `json:"questionType" yaml:"questionType" mapstructure:"questionType"`

	// Resources corresponds to the JSON schema field "resources".
	Resources []string `json:"resources" yaml:"resources" mapstructure:"resources"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Prefetch) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["questionId"]; !ok || v == nil {
		return fmt.Errorf("field questionId in Prefetch: required")
	}
	if v, ok := raw["questionType"]; !ok || v == nil {
		return fmt.Errorf("field questionType in Prefetch: required")
	}
	if v, ok := raw["resources"]; !ok || v == nil {
		return fmt.Errorf("field resources in Prefetch: required")
	}
	type Plain Prefetch
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Prefetch(plain)
	return nil
}

type GetQuestionResourcesByTypesOutput struct {
	// Prefetchs corresponds to the JSON schema field "prefetchs".
	Prefetchs []Prefetch `json:"prefetchs" yaml:"prefetchs" mapstructure:"prefetchs"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetQuestionResourcesByTypesOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["prefetchs"]; !ok || v == nil {
		return fmt.Errorf("field prefetchs in GetQuestionResourcesByTypesOutput: required")
	}
	type Plain GetQuestionResourcesByTypesOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetQuestionResourcesByTypesOutput(plain)
	return nil
}

type GetQuestionsByTypesRandomInput struct {
	// Limit corresponds to the JSON schema field "limit".
	Limit int `json:"limit" yaml:"limit" mapstructure:"limit"`

	// Types corresponds to the JSON schema field "types".
	Types []string `json:"types" yaml:"types" mapstructure:"types"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetQuestionsByTypesRandomInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["limit"]; !ok || v == nil {
		return fmt.Errorf("field limit in GetQuestionsByTypesRandomInput: required")
	}
	if v, ok := raw["types"]; !ok || v == nil {
		return fmt.Errorf("field types in GetQuestionsByTypesRandomInput: required")
	}
	type Plain GetQuestionsByTypesRandomInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetQuestionsByTypesRandomInput(plain)
	return nil
}

type Question struct {
	// Id corresponds to the JSON schema field "id".
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// StructJSON corresponds to the JSON schema field "structJSON".
	StructJSON string `json:"structJSON" yaml:"structJSON" mapstructure:"structJSON"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Question) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id in Question: required")
	}
	if v, ok := raw["structJSON"]; !ok || v == nil {
		return fmt.Errorf("field structJSON in Question: required")
	}
	type Plain Question
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Question(plain)
	return nil
}

type GetQuestionsByTypesRandomOutput struct {
	// Questions corresponds to the JSON schema field "questions".
	Questions []Question `json:"questions" yaml:"questions" mapstructure:"questions"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetQuestionsByTypesRandomOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["questions"]; !ok || v == nil {
		return fmt.Errorf("field questions in GetQuestionsByTypesRandomOutput: required")
	}
	type Plain GetQuestionsByTypesRandomOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetQuestionsByTypesRandomOutput(plain)
	return nil
}

type GetUserIdByAddressInput struct {
	// BlockchainAddress corresponds to the JSON schema field "blockchainAddress".
	BlockchainAddress string `json:"blockchainAddress" yaml:"blockchainAddress" mapstructure:"blockchainAddress"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserIdByAddressInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["blockchainAddress"]; !ok || v == nil {
		return fmt.Errorf("field blockchainAddress in GetUserIdByAddressInput: required")
	}
	type Plain GetUserIdByAddressInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserIdByAddressInput(plain)
	return nil
}

type GetUserIdByAddressOutput struct {
	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserIdByAddressOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId in GetUserIdByAddressOutput: required")
	}
	type Plain GetUserIdByAddressOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserIdByAddressOutput(plain)
	return nil
}

type GetUserNFTsByUserIdAndAddressInput struct {
	// 用户钱包地址
	BlockchainAddress string `json:"blockchainAddress" yaml:"blockchainAddress" mapstructure:"blockchainAddress"`

	// 用户id
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserNFTsByUserIdAndAddressInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["blockchainAddress"]; !ok || v == nil {
		return fmt.Errorf("field blockchainAddress in GetUserNFTsByUserIdAndAddressInput: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId in GetUserNFTsByUserIdAndAddressInput: required")
	}
	type Plain GetUserNFTsByUserIdAndAddressInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserNFTsByUserIdAndAddressInput(plain)
	return nil
}

// 有一些配置表格的数据不希望显示在opensea中, 但是为了方便统一解析。
// 生成到这个表格中.
type LumiAttribute struct {
	// TraitType corresponds to the JSON schema field "trait_type".
	TraitType string `json:"trait_type" yaml:"trait_type" mapstructure:"trait_type"`

	// Value corresponds to the JSON schema field "value".
	Value string `json:"value" yaml:"value" mapstructure:"value"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LumiAttribute) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["trait_type"]; !ok || v == nil {
		return fmt.Errorf("field trait_type in LumiAttribute: required")
	}
	if v, ok := raw["value"]; !ok || v == nil {
		return fmt.Errorf("field value in LumiAttribute: required")
	}
	type Plain LumiAttribute
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = LumiAttribute(plain)
	return nil
}

// NFT metadata源信息
// https://docs.opensea.io/docs/metadata-standards
type NFTMetadata struct {
	// NFT gif animation url
	AnimationUrl *string `json:"animation_url,omitempty" yaml:"animation_url,omitempty" mapstructure:"animation_url,omitempty"`

	// NFT的额外属性.
	Attributes []NFTAttribute `json:"attributes" yaml:"attributes" mapstructure:"attributes"`

	// BackgroundColor corresponds to the JSON schema field "background_color".
	BackgroundColor *string `json:"background_color,omitempty" yaml:"background_color,omitempty" mapstructure:"background_color,omitempty"`

	// NFT description
	Description string `json:"description" yaml:"description" mapstructure:"description"`

	// NFT 扩展url
	// 有扩展URL的NFT社区会实现规范用户点击进行跳转。
	ExternalUrl *string `json:"external_url,omitempty" yaml:"external_url,omitempty" mapstructure:"external_url,omitempty"`

	// NFT image data.
	Image *string `json:"image,omitempty" yaml:"image,omitempty" mapstructure:"image,omitempty"`

	// ImageData corresponds to the JSON schema field "image_data".
	ImageData *string `json:"image_data,omitempty" yaml:"image_data,omitempty" mapstructure:"image_data,omitempty"`

	// ImageUrl corresponds to the JSON schema field "image_url".
	ImageUrl *string `json:"image_url,omitempty" yaml:"image_url,omitempty" mapstructure:"image_url,omitempty"`

	// NFT的原始数据. 只有Lumiterra的NFT才会携带
	// 基于策划的表格配置生成.
	LumiAttributes []LumiAttribute `json:"lumiAttributes,omitempty" yaml:"lumiAttributes,omitempty" mapstructure:"lumiAttributes,omitempty"`

	// NFT name
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Youtube video url
	YoutubeUrl *string `json:"youtube_url,omitempty" yaml:"youtube_url,omitempty" mapstructure:"youtube_url,omitempty"`
}

type MultiBuildUpdateEvent struct {
	// 建造物信息
	BuildDatas []BuildData `json:"buildDatas" yaml:"buildDatas" mapstructure:"buildDatas"`

	// 消息版本号
	Etag int `json:"etag" yaml:"etag" mapstructure:"etag"`
}

type NFT struct {
	// NFT address
	Address string `json:"address" yaml:"address" mapstructure:"address"`

	// NFT amount
	Amount int `json:"amount" yaml:"amount" mapstructure:"amount"`

	// NFT 变化量
	// 默认值为0, 当某一个事件发出时, 若为n<0则表示此次事件导致的nft数量减少n, n>0则表示此次事件导致的nft数量增加n
	AmountOfChange int `json:"amountOfChange" yaml:"amountOfChange" mapstructure:"amountOfChange"`

	// CreatedAt corresponds to the JSON schema field "createdAt".
	CreatedAt int `json:"createdAt" yaml:"createdAt" mapstructure:"createdAt"`

	// NFT id
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// IsGame corresponds to the JSON schema field "isGame".
	IsGame bool `json:"isGame" yaml:"isGame" mapstructure:"isGame"`

	// 只有当isGame为true时, 才存在, 否则为空字符串
	ItemId string `json:"itemId" yaml:"itemId" mapstructure:"itemId"`

	// NFT metadata info
	// 如果非第三方则必须有metadata
	// 目前的实现是, 如果是第三方NFT, 则metadata为空, 直接将tokenURL返回给前端解析即可.
	// example: https://nftmetadata-service-release.lumiterra.net/placeable/80000031/1
	Metadata *NFTMetadata `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`

	// 描述当前nft存储于那条链上
	Network string `json:"network" yaml:"network" mapstructure:"network"`

	// product Id
	ProductId string `json:"productId" yaml:"productId" mapstructure:"productId"`

	// NFT token id
	TokenId string `json:"tokenId" yaml:"tokenId" mapstructure:"tokenId"`

	// NFT metadata url
	// https://nftmetadata-service-release.lumiterra.net/placeable/80000031/1
	TokenURL string `json:"tokenURL" yaml:"tokenURL" mapstructure:"tokenURL"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NFT) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["address"]; !ok || v == nil {
		return fmt.Errorf("field address in NFT: required")
	}
	if v, ok := raw["amount"]; !ok || v == nil {
		return fmt.Errorf("field amount in NFT: required")
	}
	if v, ok := raw["amountOfChange"]; !ok || v == nil {
		return fmt.Errorf("field amountOfChange in NFT: required")
	}
	if v, ok := raw["createdAt"]; !ok || v == nil {
		return fmt.Errorf("field createdAt in NFT: required")
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id in NFT: required")
	}
	if v, ok := raw["isGame"]; !ok || v == nil {
		return fmt.Errorf("field isGame in NFT: required")
	}
	if v, ok := raw["itemId"]; !ok || v == nil {
		return fmt.Errorf("field itemId in NFT: required")
	}
	if v, ok := raw["network"]; !ok || v == nil {
		return fmt.Errorf("field network in NFT: required")
	}
	if v, ok := raw["productId"]; !ok || v == nil {
		return fmt.Errorf("field productId in NFT: required")
	}
	if v, ok := raw["tokenId"]; !ok || v == nil {
		return fmt.Errorf("field tokenId in NFT: required")
	}
	if v, ok := raw["tokenURL"]; !ok || v == nil {
		return fmt.Errorf("field tokenURL in NFT: required")
	}
	type Plain NFT
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = NFT(plain)
	return nil
}

type GetUserNFTsByUserIdAndAddressOutput struct {
	// Nfts corresponds to the JSON schema field "nfts".
	Nfts []NFT `json:"nfts" yaml:"nfts" mapstructure:"nfts"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserNFTsByUserIdAndAddressOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["nfts"]; !ok || v == nil {
		return fmt.Errorf("field nfts in GetUserNFTsByUserIdAndAddressOutput: required")
	}
	type Plain GetUserNFTsByUserIdAndAddressOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserNFTsByUserIdAndAddressOutput(plain)
	return nil
}

type GetUserNFTsInput struct {
	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserNFTsInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId in GetUserNFTsInput: required")
	}
	type Plain GetUserNFTsInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserNFTsInput(plain)
	return nil
}

// NFT放置过期时间结构体
type NFTPlaceableTimeout struct {
	// NFT Id
	NftId string `json:"nftId" yaml:"nftId" mapstructure:"nftId"`

	// 名字（是否唯一）
	TimeoutSec int `json:"timeoutSec" yaml:"timeoutSec" mapstructure:"timeoutSec"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NFTPlaceableTimeout) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["nftId"]; !ok || v == nil {
		return fmt.Errorf("field nftId in NFTPlaceableTimeout: required")
	}
	if v, ok := raw["timeoutSec"]; !ok || v == nil {
		return fmt.Errorf("field timeoutSec in NFTPlaceableTimeout: required")
	}
	type Plain NFTPlaceableTimeout
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = NFTPlaceableTimeout(plain)
	return nil
}

type GetUserNFTsOutput struct {
	// 消息版本号
	Etag int `json:"etag" yaml:"etag" mapstructure:"etag"`

	// user all nfts
	Nfts []NFT `json:"nfts" yaml:"nfts" mapstructure:"nfts"`

	// NFT放置过期时间表
	PlaceableTimeouts []NFTPlaceableTimeout `json:"placeableTimeouts" yaml:"placeableTimeouts" mapstructure:"placeableTimeouts"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserNFTsOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag in GetUserNFTsOutput: required")
	}
	if v, ok := raw["nfts"]; !ok || v == nil {
		return fmt.Errorf("field nfts in GetUserNFTsOutput: required")
	}
	if v, ok := raw["placeableTimeouts"]; !ok || v == nil {
		return fmt.Errorf("field placeableTimeouts in GetUserNFTsOutput: required")
	}
	type Plain GetUserNFTsOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserNFTsOutput(plain)
	return nil
}

type GetUserRecipesInput struct {
	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserRecipesInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId in GetUserRecipesInput: required")
	}
	type Plain GetUserRecipesInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserRecipesInput(plain)
	return nil
}

type GetUserRecipesOutput struct {
	// RecipeIds corresponds to the JSON schema field "recipeIds".
	RecipeIds []string `json:"recipeIds" yaml:"recipeIds" mapstructure:"recipeIds"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserRecipesOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["recipeIds"]; !ok || v == nil {
		return fmt.Errorf("field recipeIds in GetUserRecipesOutput: required")
	}
	type Plain GetUserRecipesOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserRecipesOutput(plain)
	return nil
}

type GetUserTrackInput struct {
	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserTrackInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId in GetUserTrackInput: required")
	}
	type Plain GetUserTrackInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserTrackInput(plain)
	return nil
}

type GetUserTrackOutput struct {
	// DitaminAmount corresponds to the JSON schema field "ditamin_amount".
	DitaminAmount int `json:"ditamin_amount" yaml:"ditamin_amount" mapstructure:"ditamin_amount"`

	// OccupiedLandNum corresponds to the JSON schema field "occupied_land_num".
	OccupiedLandNum int `json:"occupied_land_num" yaml:"occupied_land_num" mapstructure:"occupied_land_num"`

	// StakeVipname corresponds to the JSON schema field "stake_vipname".
	StakeVipname string `json:"stake_vipname" yaml:"stake_vipname" mapstructure:"stake_vipname"`

	// TicketLandNum corresponds to the JSON schema field "ticket_land_num".
	TicketLandNum int `json:"ticket_land_num" yaml:"ticket_land_num" mapstructure:"ticket_land_num"`

	// VipLandNum corresponds to the JSON schema field "vip_land_num".
	VipLandNum int `json:"vip_land_num" yaml:"vip_land_num" mapstructure:"vip_land_num"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserTrackOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["ditamin_amount"]; !ok || v == nil {
		return fmt.Errorf("field ditamin_amount in GetUserTrackOutput: required")
	}
	if v, ok := raw["occupied_land_num"]; !ok || v == nil {
		return fmt.Errorf("field occupied_land_num in GetUserTrackOutput: required")
	}
	if v, ok := raw["stake_vipname"]; !ok || v == nil {
		return fmt.Errorf("field stake_vipname in GetUserTrackOutput: required")
	}
	if v, ok := raw["ticket_land_num"]; !ok || v == nil {
		return fmt.Errorf("field ticket_land_num in GetUserTrackOutput: required")
	}
	if v, ok := raw["vip_land_num"]; !ok || v == nil {
		return fmt.Errorf("field vip_land_num in GetUserTrackOutput: required")
	}
	type Plain GetUserTrackOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserTrackOutput(plain)
	return nil
}

type GetUserWeb3ProfileInput struct {
	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserWeb3ProfileInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId in GetUserWeb3ProfileInput: required")
	}
	type Plain GetUserWeb3ProfileInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserWeb3ProfileInput(plain)
	return nil
}

type GetUserWeb3ProfileOutput struct {
	// BlockchainAddress corresponds to the JSON schema field "blockchainAddress".
	BlockchainAddress string `json:"blockchainAddress" yaml:"blockchainAddress" mapstructure:"blockchainAddress"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserWeb3ProfileOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["blockchainAddress"]; !ok || v == nil {
		return fmt.Errorf("field blockchainAddress in GetUserWeb3ProfileOutput: required")
	}
	type Plain GetUserWeb3ProfileOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserWeb3ProfileOutput(plain)
	return nil
}

type GraphqlServiceAction string

var enumValues_GraphqlServiceAction = []interface{}{
	"CanBuildNFT",
	"CheckQuestionAnswer",
	"GetQuestionResourcesByTypes",
	"GetQuestionsByTypesRandom",
	"GetUserIdByAddress",
	"GetUserNFTs",
	"GetUserTrack",
	"GetUserWeb3Profile",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GraphqlServiceAction) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_GraphqlServiceAction {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_GraphqlServiceAction, v)
	}
	*j = GraphqlServiceAction(v)
	return nil
}

const GraphqlServiceActionCanBuildNFT GraphqlServiceAction = "CanBuildNFT"
const GraphqlServiceActionCheckQuestionAnswer GraphqlServiceAction = "CheckQuestionAnswer"
const GraphqlServiceActionGetQuestionResourcesByTypes GraphqlServiceAction = "GetQuestionResourcesByTypes"
const GraphqlServiceActionGetQuestionsByTypesRandom GraphqlServiceAction = "GetQuestionsByTypesRandom"
const GraphqlServiceActionGetUserIdByAddress GraphqlServiceAction = "GetUserIdByAddress"
const GraphqlServiceActionGetUserNFTs GraphqlServiceAction = "GetUserNFTs"
const GraphqlServiceActionGetUserTrack GraphqlServiceAction = "GetUserTrack"
const GraphqlServiceActionGetUserWeb3Profile GraphqlServiceAction = "GetUserWeb3Profile"

type HarvestInput struct {
	// 建造id
	BuildId int `json:"buildId" yaml:"buildId" mapstructure:"buildId"`

	// 地图id 为多地图准备
	MapId int `json:"mapId" yaml:"mapId" mapstructure:"mapId"`

	// 玩家id
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *HarvestInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["buildId"]; !ok || v == nil {
		return fmt.Errorf("field buildId in HarvestInput: required")
	}
	if v, ok := raw["mapId"]; !ok || v == nil {
		return fmt.Errorf("field mapId in HarvestInput: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId in HarvestInput: required")
	}
	type Plain HarvestInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = HarvestInput(plain)
	return nil
}

type HarvestOutput struct {
	// 失败, 则返回失败原因, 否则返回空字符串
	FailedReason string `json:"failedReason" yaml:"failedReason" mapstructure:"failedReason"`

	// 是否成功
	Success bool `json:"success" yaml:"success" mapstructure:"success"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *HarvestOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["failedReason"]; !ok || v == nil {
		return fmt.Errorf("field failedReason in HarvestOutput: required")
	}
	if v, ok := raw["success"]; !ok || v == nil {
		return fmt.Errorf("field success in HarvestOutput: required")
	}
	type Plain HarvestOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = HarvestOutput(plain)
	return nil
}

type Int32 int

type LandServiceAction string

var enumValues_LandServiceAction = []interface{}{
	"Build",
	"Charged",
	"Collection",
	"GetAllBuildData",
	"GetAllLandData",
	"Harvest",
	"MintBattery",
	"Recycling",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandServiceAction) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LandServiceAction {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LandServiceAction, v)
	}
	*j = LandServiceAction(v)
	return nil
}

const LandServiceActionBuild LandServiceAction = "Build"
const LandServiceActionCharged LandServiceAction = "Charged"
const LandServiceActionCollection LandServiceAction = "Collection"
const LandServiceActionGetAllBuildData LandServiceAction = "GetAllBuildData"
const LandServiceActionGetAllLandData LandServiceAction = "GetAllLandData"
const LandServiceActionHarvest LandServiceAction = "Harvest"
const LandServiceActionMintBattery LandServiceAction = "MintBattery"
const LandServiceActionRecycling LandServiceAction = "Recycling"

// 攻占地格 请求地格中产生效果的skill
type LandUsingSkillInput struct {
	// 消息版本号
	Etag int `json:"etag" yaml:"etag" mapstructure:"etag"`

	// 地格ID
	TileId int `json:"tileId" yaml:"tileId" mapstructure:"tileId"`

	// 攻占者ID
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandUsingSkillInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag in LandUsingSkillInput: required")
	}
	if v, ok := raw["tileId"]; !ok || v == nil {
		return fmt.Errorf("field tileId in LandUsingSkillInput: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId in LandUsingSkillInput: required")
	}
	type Plain LandUsingSkillInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = LandUsingSkillInput(plain)
	return nil
}

type Skill struct {
	// skill level
	Level int `json:"level" yaml:"level" mapstructure:"level"`

	// skill Id,  only key
	SkillId int `json:"skillId" yaml:"skillId" mapstructure:"skillId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Skill) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["level"]; !ok || v == nil {
		return fmt.Errorf("field level in Skill: required")
	}
	if v, ok := raw["skillId"]; !ok || v == nil {
		return fmt.Errorf("field skillId in Skill: required")
	}
	type Plain Skill
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Skill(plain)
	return nil
}

// 攻占地格 请求地格skill返回
type LandUsingSkillOutput struct {
	// 消息版本号
	Etag int `json:"etag" yaml:"etag" mapstructure:"etag"`

	// Skill List
	SkillList []Skill `json:"skillList" yaml:"skillList" mapstructure:"skillList"`

	// 地格ID
	TileId int `json:"tileId" yaml:"tileId" mapstructure:"tileId"`

	// 攻占者ID
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandUsingSkillOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag in LandUsingSkillOutput: required")
	}
	if v, ok := raw["skillList"]; !ok || v == nil {
		return fmt.Errorf("field skillList in LandUsingSkillOutput: required")
	}
	if v, ok := raw["tileId"]; !ok || v == nil {
		return fmt.Errorf("field tileId in LandUsingSkillOutput: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId in LandUsingSkillOutput: required")
	}
	type Plain LandUsingSkillOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = LandUsingSkillOutput(plain)
	return nil
}

type LearnUserRecipesInput struct {
	// RecipeIds corresponds to the JSON schema field "recipeIds".
	RecipeIds []string `json:"recipeIds" yaml:"recipeIds" mapstructure:"recipeIds"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LearnUserRecipesInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["recipeIds"]; !ok || v == nil {
		return fmt.Errorf("field recipeIds in LearnUserRecipesInput: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId in LearnUserRecipesInput: required")
	}
	type Plain LearnUserRecipesInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = LearnUserRecipesInput(plain)
	return nil
}

type LearnUserRecipesOutput map[string]interface{}

type MergeByRecipeInput struct {
	// 合成数量
	Amount int `json:"amount" yaml:"amount" mapstructure:"amount"`

	// 图鉴id
	RecipeId string `json:"recipeId" yaml:"recipeId" mapstructure:"recipeId"`

	// 合成的用户
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MergeByRecipeInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["amount"]; !ok || v == nil {
		return fmt.Errorf("field amount in MergeByRecipeInput: required")
	}
	if v, ok := raw["recipeId"]; !ok || v == nil {
		return fmt.Errorf("field recipeId in MergeByRecipeInput: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId in MergeByRecipeInput: required")
	}
	type Plain MergeByRecipeInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MergeByRecipeInput(plain)
	return nil
}

type MergeByRecipeOutput map[string]interface{}

type MintBatteryInput struct {
	// 赠送数量, 由前端传过来, 防止后端配表跟前端不一致时, 出现问题
	GiftNum int `json:"giftNum" yaml:"giftNum" mapstructure:"giftNum"`

	// mint 数量
	Num int `json:"num" yaml:"num" mapstructure:"num"`

	// 用户数量
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MintBatteryInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["giftNum"]; !ok || v == nil {
		return fmt.Errorf("field giftNum in MintBatteryInput: required")
	}
	if v, ok := raw["num"]; !ok || v == nil {
		return fmt.Errorf("field num in MintBatteryInput: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId in MintBatteryInput: required")
	}
	type Plain MintBatteryInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MintBatteryInput(plain)
	return nil
}

type MintBatteryOutput struct {
	// 失败, 则返回失败原因, 否则返回空字符串
	FailedReason string `json:"failedReason" yaml:"failedReason" mapstructure:"failedReason"`

	// 是否成功
	Success bool `json:"success" yaml:"success" mapstructure:"success"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CollectionOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["failedReason"]; !ok || v == nil {
		return fmt.Errorf("field failedReason in CollectionOutput: required")
	}
	if v, ok := raw["success"]; !ok || v == nil {
		return fmt.Errorf("field success in CollectionOutput: required")
	}
	type Plain CollectionOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CollectionOutput(plain)
	return nil
}

var enumValues_AppId = []interface{}{
	"game-service-main",
	"graphql-service",
	"pvp-service",
	"scene-dynamic-service",
	"web3-service",
}

const PVPTypePvpTypeMatch PVPType = "pvpTypeMatch"

type MultiGetPlayerInfoByUserIdInput struct {
	// UserIds corresponds to the JSON schema field "userIds".
	UserIds []string `json:"userIds" yaml:"userIds" mapstructure:"userIds"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MultiGetPlayerInfoByUserIdInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["userIds"]; !ok || v == nil {
		return fmt.Errorf("field userIds in MultiGetPlayerInfoByUserIdInput: required")
	}
	type Plain MultiGetPlayerInfoByUserIdInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MultiGetPlayerInfoByUserIdInput(plain)
	return nil
}

type MultiGetPlayerInfoByUserIdOutput struct {
	// PlayerInfos corresponds to the JSON schema field "playerInfos".
	PlayerInfos []PlayerInfo `json:"playerInfos" yaml:"playerInfos" mapstructure:"playerInfos"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MultiGetPlayerInfoByUserIdOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["playerInfos"]; !ok || v == nil {
		return fmt.Errorf("field playerInfos in MultiGetPlayerInfoByUserIdOutput: required")
	}
	type Plain MultiGetPlayerInfoByUserIdOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MultiGetPlayerInfoByUserIdOutput(plain)
	return nil
}

type MultiGetPlayerUsingNftsByUserIdInput struct {
	// UserIds corresponds to the JSON schema field "userIds".
	UserIds []string `json:"userIds" yaml:"userIds" mapstructure:"userIds"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MultiGetPlayerUsingNftsByUserIdInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["userIds"]; !ok || v == nil {
		return fmt.Errorf("field userIds in MultiGetPlayerUsingNftsByUserIdInput: required")
	}
	type Plain MultiGetPlayerUsingNftsByUserIdInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MultiGetPlayerUsingNftsByUserIdInput(plain)
	return nil
}

type UserUsingNft struct {
	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`

	// UsingNfts corresponds to the JSON schema field "usingNfts".
	UsingNfts []UsingNFT `json:"usingNfts" yaml:"usingNfts" mapstructure:"usingNfts"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UserUsingNft) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId in UserUsingNft: required")
	}
	if v, ok := raw["usingNfts"]; !ok || v == nil {
		return fmt.Errorf("field usingNfts in UserUsingNft: required")
	}
	type Plain UserUsingNft
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UserUsingNft(plain)
	return nil
}

type MultiGetPlayerUsingNftsByUserIdOutput struct {
	// UserUsingNfts corresponds to the JSON schema field "UserUsingNfts".
	UserUsingNfts []UserUsingNft `json:"UserUsingNfts" yaml:"UserUsingNfts" mapstructure:"UserUsingNfts"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MultiGetPlayerUsingNftsByUserIdOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["UserUsingNfts"]; !ok || v == nil {
		return fmt.Errorf("field UserUsingNfts in MultiGetPlayerUsingNftsByUserIdOutput: required")
	}
	type Plain MultiGetPlayerUsingNftsByUserIdOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MultiGetPlayerUsingNftsByUserIdOutput(plain)
	return nil
}

type MultiLandDataUpdateEvent struct {
	// 消息版本号
	Etag int `json:"etag" yaml:"etag" mapstructure:"etag"`

	// Lands corresponds to the JSON schema field "lands".
	Lands []LandData `json:"lands" yaml:"lands" mapstructure:"lands"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MultiLandDataUpdateEvent) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag in MultiLandDataUpdateEvent: required")
	}
	if v, ok := raw["lands"]; !ok || v == nil {
		return fmt.Errorf("field lands in MultiLandDataUpdateEvent: required")
	}
	type Plain MultiLandDataUpdateEvent
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MultiLandDataUpdateEvent(plain)
	return nil
}

type RecyclingInfo struct {
	// BuildId corresponds to the JSON schema field "buildId".
	BuildId int `json:"buildId" yaml:"buildId" mapstructure:"buildId"`

	// MapId corresponds to the JSON schema field "mapId".
	MapId int `json:"mapId" yaml:"mapId" mapstructure:"mapId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RecyclingInfo) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["buildId"]; !ok || v == nil {
		return fmt.Errorf("field buildId in RecyclingInfo: required")
	}
	if v, ok := raw["mapId"]; !ok || v == nil {
		return fmt.Errorf("field mapId in RecyclingInfo: required")
	}
	type Plain RecyclingInfo
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = RecyclingInfo(plain)
	return nil
}

type MultiRecyclingEvent struct {
	// 消息版本号
	Etag int `json:"etag" yaml:"etag" mapstructure:"etag"`

	// RecyclingInfos corresponds to the JSON schema field "recyclingInfos".
	RecyclingInfos []RecyclingInfo `json:"recyclingInfos" yaml:"recyclingInfos" mapstructure:"recyclingInfos"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MultiRecyclingEvent) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag in MultiRecyclingEvent: required")
	}
	if v, ok := raw["recyclingInfos"]; !ok || v == nil {
		return fmt.Errorf("field recyclingInfos in MultiRecyclingEvent: required")
	}
	type Plain MultiRecyclingEvent
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MultiRecyclingEvent(plain)
	return nil
}

type RecipeInfo struct {
	// 图鉴id
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// 图鉴名称
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RecipeInfo) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id in RecipeInfo: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in RecipeInfo: required")
	}
	type Plain RecipeInfo
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = RecipeInfo(plain)
	return nil
}

type MultiUpdateUserNFT struct {
	// 消息版本号
	Etag int `json:"etag" yaml:"etag" mapstructure:"etag"`

	// 来源坐标
	// 当捡取时携带且不为0
	FromLandId int `json:"fromLandId" yaml:"fromLandId" mapstructure:"fromLandId"`

	// 来源合成图鉴
	FromRecipeInfo *RecipeInfo `json:"fromRecipeInfo,omitempty" yaml:"fromRecipeInfo,omitempty" mapstructure:"fromRecipeInfo,omitempty"`

	// NFT信息
	Nfts []NFT `json:"nfts" yaml:"nfts" mapstructure:"nfts"`

	// 接收NFT的用户钱包地址
	RecipientBlockchainAddress *string `json:"recipientBlockchainAddress,omitempty" yaml:"recipientBlockchainAddress,omitempty" mapstructure:"recipientBlockchainAddress,omitempty"`

	// 发送NFT的用户钱包地址
	SenderBlockchainAddress *string `json:"senderBlockchainAddress,omitempty" yaml:"senderBlockchainAddress,omitempty" mapstructure:"senderBlockchainAddress,omitempty"`

	// 区块链交易hash
	Txn *string `json:"txn,omitempty" yaml:"txn,omitempty" mapstructure:"txn,omitempty"`

	// 归属用户id
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MultiUpdateUserNFT) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag in MultiUpdateUserNFT: required")
	}
	if v, ok := raw["fromLandId"]; !ok || v == nil {
		return fmt.Errorf("field fromLandId in MultiUpdateUserNFT: required")
	}
	if v, ok := raw["nfts"]; !ok || v == nil {
		return fmt.Errorf("field nfts in MultiUpdateUserNFT: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId in MultiUpdateUserNFT: required")
	}
	type Plain MultiUpdateUserNFT
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MultiUpdateUserNFT(plain)
	return nil
}

type NFTTraitTypes string

var enumValues_NFTTraitTypes = []interface{}{
	"Abilities",
	"Attack",
	"Attack Speed",
	"Battle Exp",
	"Battle Level",
	"Battle Potentiality",
	"CoreSkillId",
	"Creator",
	"Crit Damage",
	"Crit Points",
	"Defence",
	"Dodge Points",
	"Farm Exp",
	"Farm Level",
	"Farm Potentiality",
	"Fertilize",
	"Gather Exp",
	"Gather Level",
	"Gather Potentiality",
	"Gender",
	"Get Buff",
	"HP Recovery",
	"Hit Points",
	"Learn Recipe",
	"MaxHP",
	"Move Speed",
	"Occupy Land",
	"Pet Name",
	"Placeable Lands",
	"Quality",
	"Rarity",
	"Requires level",
	"Restore HP",
	"Series",
	"SkillLevel",
	"Sow Seeds",
	"Type",
	"Wearing Position",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NFTTraitTypes) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NFTTraitTypes {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NFTTraitTypes, v)
	}
	*j = NFTTraitTypes(v)
	return nil
}

const NFTTraitTypesAbilities NFTTraitTypes = "Abilities"
const NFTTraitTypesAttack NFTTraitTypes = "Attack"
const NFTTraitTypesAttackSpeed NFTTraitTypes = "Attack Speed"
const NFTTraitTypesBattleExp NFTTraitTypes = "Battle Exp"
const NFTTraitTypesBattleLevel NFTTraitTypes = "Battle Level"
const NFTTraitTypesBattlePotentiality NFTTraitTypes = "Battle Potentiality"
const NFTTraitTypesCoreSkillId NFTTraitTypes = "CoreSkillId"
const NFTTraitTypesCreator NFTTraitTypes = "Creator"
const NFTTraitTypesCritDamage NFTTraitTypes = "Crit Damage"
const NFTTraitTypesCritPoints NFTTraitTypes = "Crit Points"
const NFTTraitTypesDefence NFTTraitTypes = "Defence"
const NFTTraitTypesDodgePoints NFTTraitTypes = "Dodge Points"
const NFTTraitTypesFarmExp NFTTraitTypes = "Farm Exp"
const NFTTraitTypesFarmLevel NFTTraitTypes = "Farm Level"
const NFTTraitTypesFarmPotentiality NFTTraitTypes = "Farm Potentiality"
const NFTTraitTypesFertilize NFTTraitTypes = "Fertilize"
const NFTTraitTypesGatherExp NFTTraitTypes = "Gather Exp"
const NFTTraitTypesGatherLevel NFTTraitTypes = "Gather Level"
const NFTTraitTypesGatherPotentiality NFTTraitTypes = "Gather Potentiality"
const NFTTraitTypesGender NFTTraitTypes = "Gender"
const NFTTraitTypesGetBuff NFTTraitTypes = "Get Buff"
const NFTTraitTypesHPRecovery NFTTraitTypes = "HP Recovery"
const NFTTraitTypesHitPoints NFTTraitTypes = "Hit Points"
const NFTTraitTypesLearnRecipe NFTTraitTypes = "Learn Recipe"
const NFTTraitTypesMaxHP NFTTraitTypes = "MaxHP"
const NFTTraitTypesMoveSpeed NFTTraitTypes = "Move Speed"
const NFTTraitTypesOccupyLand NFTTraitTypes = "Occupy Land"
const NFTTraitTypesPetName NFTTraitTypes = "Pet Name"
const NFTTraitTypesPlaceableLands NFTTraitTypes = "Placeable Lands"
const NFTTraitTypesQuality NFTTraitTypes = "Quality"
const NFTTraitTypesRarity NFTTraitTypes = "Rarity"
const NFTTraitTypesRequiresLevel NFTTraitTypes = "Requires level"
const NFTTraitTypesRestoreHP NFTTraitTypes = "Restore HP"
const NFTTraitTypesSeries NFTTraitTypes = "Series"
const NFTTraitTypesSkillLevel NFTTraitTypes = "SkillLevel"
const NFTTraitTypesSowSeeds NFTTraitTypes = "Sow Seeds"
const NFTTraitTypesType NFTTraitTypes = "Type"
const NFTTraitTypesWearingPosition NFTTraitTypes = "Wearing Position"

// 核心技能id
type NFTTraitCoreSkillId interface{}

type NFTTraitPlaceableLands string

var enumValues_NFTTraitPlaceableLands = []interface{}{
	"Occupied",
	"Ticket",
	"VIP",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NFTTraitPlaceableLands) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NFTTraitPlaceableLands {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NFTTraitPlaceableLands, v)
	}
	*j = NFTTraitPlaceableLands(v)
	return nil
}

const NFTTraitPlaceableLandsOccupied NFTTraitPlaceableLands = "Occupied"
const NFTTraitPlaceableLandsTicket NFTTraitPlaceableLands = "Ticket"
const NFTTraitPlaceableLandsVIP NFTTraitPlaceableLands = "VIP"

type NFTTraitQuality string

var enumValues_NFTTraitQuality = []interface{}{
	"Advanced",
	"Basic",
	"Enhanced",
	"Super",
	"Ultimate",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NFTTraitQuality) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NFTTraitQuality {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NFTTraitQuality, v)
	}
	*j = NFTTraitQuality(v)
	return nil
}

const NFTTraitQualityAdvanced NFTTraitQuality = "Advanced"
const NFTTraitQualityBasic NFTTraitQuality = "Basic"
const NFTTraitQualityEnhanced NFTTraitQuality = "Enhanced"
const NFTTraitQualitySuper NFTTraitQuality = "Super"
const NFTTraitQualityUltimate NFTTraitQuality = "Ultimate"

type NFTTraitRarity string

var enumValues_NFTTraitRarity = []interface{}{
	"common",
	"epic",
	"mythic",
	"rare",
	"unique",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NFTTraitRarity) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NFTTraitRarity {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NFTTraitRarity, v)
	}
	*j = NFTTraitRarity(v)
	return nil
}

const NFTTraitRarityCommon NFTTraitRarity = "common"
const NFTTraitRarityEpic NFTTraitRarity = "epic"
const NFTTraitRarityMythic NFTTraitRarity = "mythic"
const NFTTraitRarityRare NFTTraitRarity = "rare"
const NFTTraitRarityUnique NFTTraitRarity = "unique"

type NFTTraitSkillLevel interface{}

type NFTTraitType string

var enumValues_NFTTraitType = []interface{}{
	"Bow",
	"Chest Armor",
	"Consumable",
	"Dagger",
	"Feet Armor",
	"Hands Armor",
	"Head Armor",
	"Legs Armor",
	"Material",
	"MysteryBox",
	"PetEgg",
	"Placeable",
	"Spear",
	"Sword",
	"Wearable",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NFTTraitType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NFTTraitType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NFTTraitType, v)
	}
	*j = NFTTraitType(v)
	return nil
}

const NFTTraitTypeBow NFTTraitType = "Bow"
const NFTTraitTypeChestArmor NFTTraitType = "Chest Armor"
const NFTTraitTypeConsumable NFTTraitType = "Consumable"
const NFTTraitTypeDagger NFTTraitType = "Dagger"
const NFTTraitTypeFeetArmor NFTTraitType = "Feet Armor"
const NFTTraitTypeHandsArmor NFTTraitType = "Hands Armor"
const NFTTraitTypeHeadArmor NFTTraitType = "Head Armor"
const NFTTraitTypeLegsArmor NFTTraitType = "Legs Armor"
const NFTTraitTypeMaterial NFTTraitType = "Material"
const NFTTraitTypeMysteryBox NFTTraitType = "MysteryBox"
const NFTTraitTypePetEgg NFTTraitType = "PetEgg"
const NFTTraitTypePlaceable NFTTraitType = "Placeable"
const NFTTraitTypeSpear NFTTraitType = "Spear"
const NFTTraitTypeSword NFTTraitType = "Sword"
const NFTTraitTypeWearable NFTTraitType = "Wearable"

type NFTTraitWearingPosition string

var enumValues_NFTTraitWearingPosition = []interface{}{
	"Gloves",
	"Head",
	"Lower Body",
	"Shoes",
	"Upper Body",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NFTTraitWearingPosition) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NFTTraitWearingPosition {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NFTTraitWearingPosition, v)
	}
	*j = NFTTraitWearingPosition(v)
	return nil
}

const NFTTraitWearingPositionGloves NFTTraitWearingPosition = "Gloves"
const NFTTraitWearingPositionHead NFTTraitWearingPosition = "Head"
const NFTTraitWearingPositionLowerBody NFTTraitWearingPosition = "Lower Body"
const NFTTraitWearingPositionShoes NFTTraitWearingPosition = "Shoes"
const NFTTraitWearingPositionUpperBody NFTTraitWearingPosition = "Upper Body"

type PVPEndType string

var enumValues_PVPEndType = []interface{}{
	"endTypeTie",
	"endTypeWin",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PVPEndType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PVPEndType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PVPEndType, v)
	}
	*j = PVPEndType(v)
	return nil
}

const PVPEndTypeEndTypeTie PVPEndType = "endTypeTie"
const PVPEndTypeEndTypeWin PVPEndType = "endTypeWin"

type PVPMatchEnterInput struct {
	// Player corresponds to the JSON schema field "player".
	Player PVPPlayer `json:"player" yaml:"player" mapstructure:"player"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PVPMatchEnterInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["player"]; !ok || v == nil {
		return fmt.Errorf("field player in PVPMatchEnterInput: required")
	}
	type Plain PVPMatchEnterInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PVPMatchEnterInput(plain)
	return nil
}

type PVPMatchEnterOutput struct {
	// Succese corresponds to the JSON schema field "succese".
	Succese bool `json:"succese" yaml:"succese" mapstructure:"succese"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PVPMatchEnterOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["succese"]; !ok || v == nil {
		return fmt.Errorf("field succese in PVPMatchEnterOutput: required")
	}
	type Plain PVPMatchEnterOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PVPMatchEnterOutput(plain)
	return nil
}

type PVPMatchLeaveInput struct {
	// Player corresponds to the JSON schema field "player".
	Player PVPPlayer `json:"player" yaml:"player" mapstructure:"player"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PVPMatchLeaveInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["player"]; !ok || v == nil {
		return fmt.Errorf("field player in PVPMatchLeaveInput: required")
	}
	type Plain PVPMatchLeaveInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PVPMatchLeaveInput(plain)
	return nil
}

type PVPMatchLeaveOutput struct {
	// Succese corresponds to the JSON schema field "succese".
	Succese bool `json:"succese" yaml:"succese" mapstructure:"succese"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PVPMatchLeaveOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["succese"]; !ok || v == nil {
		return fmt.Errorf("field succese in PVPMatchLeaveOutput: required")
	}
	type Plain PVPMatchLeaveOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PVPMatchLeaveOutput(plain)
	return nil
}

type PVPPKSessionStatus string

var enumValues_PVPPKSessionStatus = []interface{}{
	"ended",
	"preloading",
	"started",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PVPPKSessionStatus) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PVPPKSessionStatus {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PVPPKSessionStatus, v)
	}
	*j = PVPPKSessionStatus(v)
	return nil
}

const PVPPKSessionStatusEnded PVPPKSessionStatus = "ended"
const PVPPKSessionStatusPreloading PVPPKSessionStatus = "preloading"
const PVPPKSessionStatusStarted PVPPKSessionStatus = "started"

type PVPRoomPreLeaveInput struct {
	// Player corresponds to the JSON schema field "player".
	Player PVPPlayer `json:"player" yaml:"player" mapstructure:"player"`

	// RoomId corresponds to the JSON schema field "roomId".
	RoomId string `json:"roomId" yaml:"roomId" mapstructure:"roomId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PVPRoomPreLeaveInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["player"]; !ok || v == nil {
		return fmt.Errorf("field player in PVPRoomPreLeaveInput: required")
	}
	if v, ok := raw["roomId"]; !ok || v == nil {
		return fmt.Errorf("field roomId in PVPRoomPreLeaveInput: required")
	}
	type Plain PVPRoomPreLeaveInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PVPRoomPreLeaveInput(plain)
	return nil
}

type PVPRoomPreLeaveOutput struct {
	// CanLeave corresponds to the JSON schema field "canLeave".
	CanLeave bool `json:"canLeave" yaml:"canLeave" mapstructure:"canLeave"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PVPRoomPreLeaveOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["canLeave"]; !ok || v == nil {
		return fmt.Errorf("field canLeave in PVPRoomPreLeaveOutput: required")
	}
	type Plain PVPRoomPreLeaveOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PVPRoomPreLeaveOutput(plain)
	return nil
}

type PVPRoomReadyInput struct {
	// Player corresponds to the JSON schema field "player".
	Player PVPPlayer `json:"player" yaml:"player" mapstructure:"player"`

	// PvpRoomId corresponds to the JSON schema field "pvpRoomId".
	PvpRoomId string `json:"pvpRoomId" yaml:"pvpRoomId" mapstructure:"pvpRoomId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PVPRoomReadyInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["player"]; !ok || v == nil {
		return fmt.Errorf("field player in PVPRoomReadyInput: required")
	}
	if v, ok := raw["pvpRoomId"]; !ok || v == nil {
		return fmt.Errorf("field pvpRoomId in PVPRoomReadyInput: required")
	}
	type Plain PVPRoomReadyInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PVPRoomReadyInput(plain)
	return nil
}

type PVPRoomReadyOutput map[string]interface{}

type PVPServiceAction string

var enumValues_PVPServiceAction = []interface{}{
	"CreatePVPRoom",
	"GetCurrentPkSessionId",
	"GetPlayerPvpProfile",
	"GetPlayerPvpRank",
	"GetPvpHistory",
	"PVPMatchEnter",
	"PVPMatchLeave",
	"PVPRoomPreLeave",
	"PVPRoomReady",
	"PkSessionAgain",
	"PkSessionDoQuestion",
	"PkSessionLoadSuccess",
	"PkSessionUITick",
	"PvpSurrender",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PVPServiceAction) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PVPServiceAction {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PVPServiceAction, v)
	}
	*j = PVPServiceAction(v)
	return nil
}

const PVPServiceActionCreatePVPRoom PVPServiceAction = "CreatePVPRoom"
const PVPServiceActionGetCurrentPkSessionId PVPServiceAction = "GetCurrentPkSessionId"
const PVPServiceActionGetPlayerPvpProfile PVPServiceAction = "GetPlayerPvpProfile"
const PVPServiceActionGetPlayerPvpRank PVPServiceAction = "GetPlayerPvpRank"
const PVPServiceActionGetPvpHistory PVPServiceAction = "GetPvpHistory"
const PVPServiceActionPVPMatchEnter PVPServiceAction = "PVPMatchEnter"
const PVPServiceActionPVPMatchLeave PVPServiceAction = "PVPMatchLeave"
const PVPServiceActionPVPRoomPreLeave PVPServiceAction = "PVPRoomPreLeave"
const PVPServiceActionPVPRoomReady PVPServiceAction = "PVPRoomReady"
const PVPServiceActionPkSessionAgain PVPServiceAction = "PkSessionAgain"
const PVPServiceActionPkSessionDoQuestion PVPServiceAction = "PkSessionDoQuestion"
const PVPServiceActionPkSessionLoadSuccess PVPServiceAction = "PkSessionLoadSuccess"
const PVPServiceActionPkSessionUITick PVPServiceAction = "PkSessionUITick"
const PVPServiceActionPvpSurrender PVPServiceAction = "PvpSurrender"

type PVPSubscriptionEvent string

var enumValues_PVPSubscriptionEvent = []interface{}{
	"PVPMatchBegin",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PVPSubscriptionEvent) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PVPSubscriptionEvent {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PVPSubscriptionEvent, v)
	}
	*j = PVPSubscriptionEvent(v)
	return nil
}

const PVPSubscriptionEventPVPMatchBegin PVPSubscriptionEvent = "PVPMatchBegin"

type PVPType string

var enumValues_PVPType = []interface{}{
	"pvpTypeMatch",
	"pvpTypePk",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PVPType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PVPType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PVPType, v)
	}
	*j = PVPType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MultiBuildUpdateEvent) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["buildDatas"]; !ok || v == nil {
		return fmt.Errorf("field buildDatas in MultiBuildUpdateEvent: required")
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag in MultiBuildUpdateEvent: required")
	}
	type Plain MultiBuildUpdateEvent
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MultiBuildUpdateEvent(plain)
	return nil
}

const PVPTypePvpTypePk PVPType = "pvpTypePk"

type PageMeta struct {
	// Count corresponds to the JSON schema field "count".
	Count int `json:"count" yaml:"count" mapstructure:"count"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PageMeta) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["count"]; !ok || v == nil {
		return fmt.Errorf("field count in PageMeta: required")
	}
	type Plain PageMeta
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PageMeta(plain)
	return nil
}

type PkSessionAgainInput struct {
	// PkSessionId corresponds to the JSON schema field "pkSessionId".
	PkSessionId string `json:"pkSessionId" yaml:"pkSessionId" mapstructure:"pkSessionId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PkSessionAgainInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["pkSessionId"]; !ok || v == nil {
		return fmt.Errorf("field pkSessionId in PkSessionAgainInput: required")
	}
	type Plain PkSessionAgainInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PkSessionAgainInput(plain)
	return nil
}

type PkSessionAgainOutput struct {
	// PkRoomId corresponds to the JSON schema field "pkRoomId".
	PkRoomId string `json:"pkRoomId" yaml:"pkRoomId" mapstructure:"pkRoomId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PkSessionAgainOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["pkRoomId"]; !ok || v == nil {
		return fmt.Errorf("field pkRoomId in PkSessionAgainOutput: required")
	}
	type Plain PkSessionAgainOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PkSessionAgainOutput(plain)
	return nil
}

type PkSessionDoQuestionInput struct {
	// AnswerSequentialMatch corresponds to the JSON schema field
	// "answerSequentialMatch".
	AnswerSequentialMatch []string `json:"answerSequentialMatch,omitempty" yaml:"answerSequentialMatch,omitempty" mapstructure:"answerSequentialMatch,omitempty"`

	// PkSessionId corresponds to the JSON schema field "pkSessionId".
	PkSessionId string `json:"pkSessionId" yaml:"pkSessionId" mapstructure:"pkSessionId"`

	// Player corresponds to the JSON schema field "player".
	Player PVPPlayer `json:"player" yaml:"player" mapstructure:"player"`

	// QuestionId corresponds to the JSON schema field "questionId".
	QuestionId string `json:"questionId" yaml:"questionId" mapstructure:"questionId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PkSessionDoQuestionInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["pkSessionId"]; !ok || v == nil {
		return fmt.Errorf("field pkSessionId in PkSessionDoQuestionInput: required")
	}
	if v, ok := raw["player"]; !ok || v == nil {
		return fmt.Errorf("field player in PkSessionDoQuestionInput: required")
	}
	if v, ok := raw["questionId"]; !ok || v == nil {
		return fmt.Errorf("field questionId in PkSessionDoQuestionInput: required")
	}
	type Plain PkSessionDoQuestionInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PkSessionDoQuestionInput(plain)
	return nil
}

type PkSessionDoQuestionOutput struct {
	// IsCorrect corresponds to the JSON schema field "isCorrect".
	IsCorrect bool `json:"isCorrect" yaml:"isCorrect" mapstructure:"isCorrect"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PkSessionDoQuestionOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["isCorrect"]; !ok || v == nil {
		return fmt.Errorf("field isCorrect in PkSessionDoQuestionOutput: required")
	}
	type Plain PkSessionDoQuestionOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PkSessionDoQuestionOutput(plain)
	return nil
}

type PkSessionLoadSuccessInput struct {
	// PkSessionId corresponds to the JSON schema field "pkSessionId".
	PkSessionId string `json:"pkSessionId" yaml:"pkSessionId" mapstructure:"pkSessionId"`

	// Player corresponds to the JSON schema field "player".
	Player PVPPlayer `json:"player" yaml:"player" mapstructure:"player"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PkSessionLoadSuccessInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["pkSessionId"]; !ok || v == nil {
		return fmt.Errorf("field pkSessionId in PkSessionLoadSuccessInput: required")
	}
	if v, ok := raw["player"]; !ok || v == nil {
		return fmt.Errorf("field player in PkSessionLoadSuccessInput: required")
	}
	type Plain PkSessionLoadSuccessInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PkSessionLoadSuccessInput(plain)
	return nil
}

type PkSessionLoadSuccessOutput map[string]interface{}

type PkSessionUITickInput struct {
	// Data corresponds to the JSON schema field "data".
	Data string `json:"data" yaml:"data" mapstructure:"data"`

	// PkSessionId corresponds to the JSON schema field "pkSessionId".
	PkSessionId string `json:"pkSessionId" yaml:"pkSessionId" mapstructure:"pkSessionId"`

	// Player corresponds to the JSON schema field "player".
	Player PVPPlayer `json:"player" yaml:"player" mapstructure:"player"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PkSessionUITickInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in PkSessionUITickInput: required")
	}
	if v, ok := raw["pkSessionId"]; !ok || v == nil {
		return fmt.Errorf("field pkSessionId in PkSessionUITickInput: required")
	}
	if v, ok := raw["player"]; !ok || v == nil {
		return fmt.Errorf("field player in PkSessionUITickInput: required")
	}
	type Plain PkSessionUITickInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PkSessionUITickInput(plain)
	return nil
}

type PkSessionUITickOutput map[string]interface{}

// 玩家死亡事件, 当玩家死亡时触发
type PlayerDeath struct {
	// 玩家死亡的附近landId
	DeathLandId int `json:"deathLandId" yaml:"deathLandId" mapstructure:"deathLandId"`

	// 造成玩家死亡的生物或用户id
	KillerId string `json:"killerId" yaml:"killerId" mapstructure:"killerId"`

	// 造成玩家死亡的生物或用户名称
	KillerName string `json:"killerName" yaml:"killerName" mapstructure:"killerName"`

	// 最后造成死亡的数值
	LastDamage float64 `json:"lastDamage" yaml:"lastDamage" mapstructure:"lastDamage"`

	// 死亡的用户id
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PlayerDeath) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["deathLandId"]; !ok || v == nil {
		return fmt.Errorf("field deathLandId in PlayerDeath: required")
	}
	if v, ok := raw["killerId"]; !ok || v == nil {
		return fmt.Errorf("field killerId in PlayerDeath: required")
	}
	if v, ok := raw["killerName"]; !ok || v == nil {
		return fmt.Errorf("field killerName in PlayerDeath: required")
	}
	if v, ok := raw["lastDamage"]; !ok || v == nil {
		return fmt.Errorf("field lastDamage in PlayerDeath: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId in PlayerDeath: required")
	}
	type Plain PlayerDeath
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PlayerDeath(plain)
	return nil
}

// 玩家击杀怪物
type PlayerKilled struct {
	// 怪物被击杀的坐标
	KilledLandId int `json:"killedLandId" yaml:"killedLandId" mapstructure:"killedLandId"`

	// 最后一击的伤害
	LastDamage float64 `json:"lastDamage" yaml:"lastDamage" mapstructure:"lastDamage"`

	// 击杀的目标id
	TargetId string `json:"targetId" yaml:"targetId" mapstructure:"targetId"`

	// 击杀的目标名称
	TargetName string `json:"targetName" yaml:"targetName" mapstructure:"targetName"`

	// 用户id
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PlayerKilled) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["killedLandId"]; !ok || v == nil {
		return fmt.Errorf("field killedLandId in PlayerKilled: required")
	}
	if v, ok := raw["lastDamage"]; !ok || v == nil {
		return fmt.Errorf("field lastDamage in PlayerKilled: required")
	}
	if v, ok := raw["targetId"]; !ok || v == nil {
		return fmt.Errorf("field targetId in PlayerKilled: required")
	}
	if v, ok := raw["targetName"]; !ok || v == nil {
		return fmt.Errorf("field targetName in PlayerKilled: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId in PlayerKilled: required")
	}
	type Plain PlayerKilled
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PlayerKilled(plain)
	return nil
}

type PlayerRebornType string

var enumValues_PlayerRebornType = []interface{}{
	"in_place",
	"main_city",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PlayerRebornType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PlayerRebornType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PlayerRebornType, v)
	}
	*j = PlayerRebornType(v)
	return nil
}

const PlayerRebornTypeInPlace PlayerRebornType = "in_place"
const PlayerRebornTypeMainCity PlayerRebornType = "main_city"

// 玩家重生事件, 当玩家重生时, 会触发此事件
type PlayerReborn struct {
	// 重生的地格id
	RebornLandId int `json:"rebornLandId" yaml:"rebornLandId" mapstructure:"rebornLandId"`

	// 玩家重生类型
	Type PlayerRebornType `json:"type" yaml:"type" mapstructure:"type"`

	// 重生的玩家id
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PlayerReborn) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["rebornLandId"]; !ok || v == nil {
		return fmt.Errorf("field rebornLandId in PlayerReborn: required")
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type in PlayerReborn: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId in PlayerReborn: required")
	}
	type Plain PlayerReborn
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PlayerReborn(plain)
	return nil
}

type PvpSurrenderInput struct {
	// PkSessionId corresponds to the JSON schema field "pkSessionId".
	PkSessionId string `json:"pkSessionId" yaml:"pkSessionId" mapstructure:"pkSessionId"`

	// PlayerId corresponds to the JSON schema field "playerId".
	PlayerId string `json:"playerId" yaml:"playerId" mapstructure:"playerId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PvpSurrenderInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["pkSessionId"]; !ok || v == nil {
		return fmt.Errorf("field pkSessionId in PvpSurrenderInput: required")
	}
	if v, ok := raw["playerId"]; !ok || v == nil {
		return fmt.Errorf("field playerId in PvpSurrenderInput: required")
	}
	type Plain PvpSurrenderInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PvpSurrenderInput(plain)
	return nil
}

type PvpSurrenderOutput struct {
	// Success corresponds to the JSON schema field "success".
	Success bool `json:"success" yaml:"success" mapstructure:"success"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PvpSurrenderOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["success"]; !ok || v == nil {
		return fmt.Errorf("field success in PvpSurrenderOutput: required")
	}
	type Plain PvpSurrenderOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PvpSurrenderOutput(plain)
	return nil
}

type RecyclingInput struct {
	// 建造Id
	BuildId int `json:"buildId" yaml:"buildId" mapstructure:"buildId"`

	// 地图id 为多地图准备
	MapId int `json:"mapId" yaml:"mapId" mapstructure:"mapId"`

	// 玩家id
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RecyclingInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["buildId"]; !ok || v == nil {
		return fmt.Errorf("field buildId in RecyclingInput: required")
	}
	if v, ok := raw["mapId"]; !ok || v == nil {
		return fmt.Errorf("field mapId in RecyclingInput: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId in RecyclingInput: required")
	}
	type Plain RecyclingInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = RecyclingInput(plain)
	return nil
}

type RecyclingOutput struct {
	// 失败, 则返回失败原因, 否则返回空字符串
	FailedReason string `json:"failedReason" yaml:"failedReason" mapstructure:"failedReason"`

	// 是否成功
	Success bool `json:"success" yaml:"success" mapstructure:"success"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RecyclingOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["failedReason"]; !ok || v == nil {
		return fmt.Errorf("field failedReason in RecyclingOutput: required")
	}
	if v, ok := raw["success"]; !ok || v == nil {
		return fmt.Errorf("field success in RecyclingOutput: required")
	}
	type Plain RecyclingOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = RecyclingOutput(plain)
	return nil
}

type SceneDynamicServiceAction string

var enumValues_SceneDynamicServiceAction = []interface{}{
	"StartServer",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SceneDynamicServiceAction) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SceneDynamicServiceAction {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SceneDynamicServiceAction, v)
	}
	*j = SceneDynamicServiceAction(v)
	return nil
}

const SceneDynamicServiceActionStartServer SceneDynamicServiceAction = "StartServer"

type SendMetaTxInput struct {
	// Data corresponds to the JSON schema field "data".
	Data string `json:"data" yaml:"data" mapstructure:"data"`

	// From corresponds to the JSON schema field "from".
	From string `json:"from" yaml:"from" mapstructure:"from"`

	// Gas corresponds to the JSON schema field "gas".
	Gas float64 `json:"gas" yaml:"gas" mapstructure:"gas"`

	// Nonce corresponds to the JSON schema field "nonce".
	Nonce string `json:"nonce" yaml:"nonce" mapstructure:"nonce"`

	// Signature corresponds to the JSON schema field "signature".
	Signature string `json:"signature" yaml:"signature" mapstructure:"signature"`

	// To corresponds to the JSON schema field "to".
	To string `json:"to" yaml:"to" mapstructure:"to"`

	// Value corresponds to the JSON schema field "value".
	Value string `json:"value" yaml:"value" mapstructure:"value"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SendMetaTxInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in SendMetaTxInput: required")
	}
	if v, ok := raw["from"]; !ok || v == nil {
		return fmt.Errorf("field from in SendMetaTxInput: required")
	}
	if v, ok := raw["gas"]; !ok || v == nil {
		return fmt.Errorf("field gas in SendMetaTxInput: required")
	}
	if v, ok := raw["nonce"]; !ok || v == nil {
		return fmt.Errorf("field nonce in SendMetaTxInput: required")
	}
	if v, ok := raw["signature"]; !ok || v == nil {
		return fmt.Errorf("field signature in SendMetaTxInput: required")
	}
	if v, ok := raw["to"]; !ok || v == nil {
		return fmt.Errorf("field to in SendMetaTxInput: required")
	}
	if v, ok := raw["value"]; !ok || v == nil {
		return fmt.Errorf("field value in SendMetaTxInput: required")
	}
	type Plain SendMetaTxInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SendMetaTxInput(plain)
	return nil
}

type SendMetaTxOutput struct {
	// TxId corresponds to the JSON schema field "txId".
	TxId string `json:"txId" yaml:"txId" mapstructure:"txId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SendMetaTxOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["txId"]; !ok || v == nil {
		return fmt.Errorf("field txId in SendMetaTxOutput: required")
	}
	type Plain SendMetaTxOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SendMetaTxOutput(plain)
	return nil
}

type SendTxInput struct {
	// Data corresponds to the JSON schema field "data".
	Data string `json:"data" yaml:"data" mapstructure:"data"`

	// Gas corresponds to the JSON schema field "gas".
	Gas float64 `json:"gas" yaml:"gas" mapstructure:"gas"`

	// To corresponds to the JSON schema field "to".
	To string `json:"to" yaml:"to" mapstructure:"to"`

	// Value corresponds to the JSON schema field "value".
	Value string `json:"value" yaml:"value" mapstructure:"value"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SendTxInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in SendTxInput: required")
	}
	if v, ok := raw["gas"]; !ok || v == nil {
		return fmt.Errorf("field gas in SendTxInput: required")
	}
	if v, ok := raw["to"]; !ok || v == nil {
		return fmt.Errorf("field to in SendTxInput: required")
	}
	if v, ok := raw["value"]; !ok || v == nil {
		return fmt.Errorf("field value in SendTxInput: required")
	}
	type Plain SendTxInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SendTxInput(plain)
	return nil
}

type SendTxOutput struct {
	// TxId corresponds to the JSON schema field "txId".
	TxId string `json:"txId" yaml:"txId" mapstructure:"txId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SendTxOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["txId"]; !ok || v == nil {
		return fmt.Errorf("field txId in SendTxOutput: required")
	}
	type Plain SendTxOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SendTxOutput(plain)
	return nil
}

type Sex string

var enumValues_Sex = []interface{}{
	"FEMALE",
	"MALE",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Sex) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Sex {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Sex, v)
	}
	*j = Sex(v)
	return nil
}

const SexFEMALE Sex = "FEMALE"
const SexMALE Sex = "MALE"

type SmapleNFT struct {
	// Amount corresponds to the JSON schema field "amount".
	Amount int `json:"amount" yaml:"amount" mapstructure:"amount"`

	// ItemId corresponds to the JSON schema field "itemId".
	ItemId string `json:"itemId" yaml:"itemId" mapstructure:"itemId"`

	// Metadata corresponds to the JSON schema field "metadata".
	Metadata NFTMetadata `json:"metadata" yaml:"metadata" mapstructure:"metadata"`

	// TokenId corresponds to the JSON schema field "tokenId".
	TokenId string `json:"tokenId" yaml:"tokenId" mapstructure:"tokenId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SmapleNFT) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["amount"]; !ok || v == nil {
		return fmt.Errorf("field amount in SmapleNFT: required")
	}
	if v, ok := raw["itemId"]; !ok || v == nil {
		return fmt.Errorf("field itemId in SmapleNFT: required")
	}
	if v, ok := raw["metadata"]; !ok || v == nil {
		return fmt.Errorf("field metadata in SmapleNFT: required")
	}
	if v, ok := raw["tokenId"]; !ok || v == nil {
		return fmt.Errorf("field tokenId in SmapleNFT: required")
	}
	type Plain SmapleNFT
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SmapleNFT(plain)
	return nil
}

type StartServerInput struct {
	// Args corresponds to the JSON schema field "args".
	Args string `json:"args" yaml:"args" mapstructure:"args"`

	// Envs corresponds to the JSON schema field "envs".
	Envs string `json:"envs" yaml:"envs" mapstructure:"envs"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StartServerInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["args"]; !ok || v == nil {
		return fmt.Errorf("field args in StartServerInput: required")
	}
	if v, ok := raw["envs"]; !ok || v == nil {
		return fmt.Errorf("field envs in StartServerInput: required")
	}
	type Plain StartServerInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = StartServerInput(plain)
	return nil
}

type StartServerOutput struct {
	// ServerAppId corresponds to the JSON schema field "serverAppId".
	ServerAppId string `json:"serverAppId" yaml:"serverAppId" mapstructure:"serverAppId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StartServerOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["serverAppId"]; !ok || v == nil {
		return fmt.Errorf("field serverAppId in StartServerOutput: required")
	}
	type Plain StartServerOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = StartServerOutput(plain)
	return nil
}

type SubscriptionEvent string

var enumValues_SubscriptionEvent = []interface{}{
	"BatchBurnNFT",
	"BatchMintNFT",
	"BatchMintNFTWithAttributes",
	"BatchTransferNFT",
	"CloseServer",
	"MultiBuildUpdateEvent",
	"MultiLandDataUpdateEvent",
	"MultiRecyclingEvent",
	"MultiUpdateUserNFT",
	"PlayerDeath",
	"PlayerKilled",
	"PlayerReborn",
	"UnloadEquipment",
	"UpdateUpcomingUses",
	"UpdateUserNFT",
	"UseEquipment",
	"UseLUAUSD",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubscriptionEvent) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SubscriptionEvent {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SubscriptionEvent, v)
	}
	*j = SubscriptionEvent(v)
	return nil
}

const SubscriptionEventBatchBurnNFT SubscriptionEvent = "BatchBurnNFT"
const SubscriptionEventBatchMintNFT SubscriptionEvent = "BatchMintNFT"
const SubscriptionEventBatchMintNFTWithAttributes SubscriptionEvent = "BatchMintNFTWithAttributes"
const SubscriptionEventBatchTransferNFT SubscriptionEvent = "BatchTransferNFT"
const SubscriptionEventCloseServer SubscriptionEvent = "CloseServer"
const SubscriptionEventMultiBuildUpdateEvent SubscriptionEvent = "MultiBuildUpdateEvent"
const SubscriptionEventMultiLandDataUpdateEvent SubscriptionEvent = "MultiLandDataUpdateEvent"
const SubscriptionEventMultiRecyclingEvent SubscriptionEvent = "MultiRecyclingEvent"
const SubscriptionEventMultiUpdateUserNFT SubscriptionEvent = "MultiUpdateUserNFT"
const SubscriptionEventPlayerDeath SubscriptionEvent = "PlayerDeath"
const SubscriptionEventPlayerKilled SubscriptionEvent = "PlayerKilled"
const SubscriptionEventPlayerReborn SubscriptionEvent = "PlayerReborn"
const SubscriptionEventUnloadEquipment SubscriptionEvent = "UnloadEquipment"
const SubscriptionEventUpdateUpcomingUses SubscriptionEvent = "UpdateUpcomingUses"
const SubscriptionEventUpdateUserNFT SubscriptionEvent = "UpdateUserNFT"
const SubscriptionEventUseEquipment SubscriptionEvent = "UseEquipment"
const SubscriptionEventUseLUAUSD SubscriptionEvent = "UseLUAUSD"

type TemporaryTokenExtraInfo struct {
	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TemporaryTokenExtraInfo) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId in TemporaryTokenExtraInfo: required")
	}
	type Plain TemporaryTokenExtraInfo
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TemporaryTokenExtraInfo(plain)
	return nil
}

type TemporaryToken struct {
	// CreatedAt corresponds to the JSON schema field "createdAt".
	CreatedAt time.Time `json:"createdAt" yaml:"createdAt" mapstructure:"createdAt"`

	// ExpiredAt corresponds to the JSON schema field "expiredAt".
	ExpiredAt time.Time `json:"expiredAt" yaml:"expiredAt" mapstructure:"expiredAt"`

	// Id corresponds to the JSON schema field "id".
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// TemporaryTokenExtraInfo corresponds to the JSON schema field
	// "temporaryTokenExtraInfo".
	TemporaryTokenExtraInfo *TemporaryTokenExtraInfo `json:"temporaryTokenExtraInfo,omitempty" yaml:"temporaryTokenExtraInfo,omitempty" mapstructure:"temporaryTokenExtraInfo,omitempty"`

	// Token corresponds to the JSON schema field "token".
	Token string `json:"token" yaml:"token" mapstructure:"token"`

	// UpdatedAt corresponds to the JSON schema field "updatedAt".
	UpdatedAt time.Time `json:"updatedAt" yaml:"updatedAt" mapstructure:"updatedAt"`

	// UsedAt corresponds to the JSON schema field "usedAt".
	UsedAt *time.Time `json:"usedAt,omitempty" yaml:"usedAt,omitempty" mapstructure:"usedAt,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TemporaryToken) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["createdAt"]; !ok || v == nil {
		return fmt.Errorf("field createdAt in TemporaryToken: required")
	}
	if v, ok := raw["expiredAt"]; !ok || v == nil {
		return fmt.Errorf("field expiredAt in TemporaryToken: required")
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id in TemporaryToken: required")
	}
	if v, ok := raw["token"]; !ok || v == nil {
		return fmt.Errorf("field token in TemporaryToken: required")
	}
	if v, ok := raw["updatedAt"]; !ok || v == nil {
		return fmt.Errorf("field updatedAt in TemporaryToken: required")
	}
	type Plain TemporaryToken
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TemporaryToken(plain)
	return nil
}

type UnloadEquipment struct {
	// NftId corresponds to the JSON schema field "nftId".
	NftId string `json:"nftId" yaml:"nftId" mapstructure:"nftId"`

	// 游戏角色id
	PlayerId string `json:"playerId" yaml:"playerId" mapstructure:"playerId"`

	// 用户id
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UnloadEquipment) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["nftId"]; !ok || v == nil {
		return fmt.Errorf("field nftId in UnloadEquipment: required")
	}
	if v, ok := raw["playerId"]; !ok || v == nil {
		return fmt.Errorf("field playerId in UnloadEquipment: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId in UnloadEquipment: required")
	}
	type Plain UnloadEquipment
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UnloadEquipment(plain)
	return nil
}

type UpdateUpcomingUses struct {
	// Number corresponds to the JSON schema field "number".
	Number int `json:"number" yaml:"number" mapstructure:"number"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UpdateUpcomingUses) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["number"]; !ok || v == nil {
		return fmt.Errorf("field number in UpdateUpcomingUses: required")
	}
	type Plain UpdateUpcomingUses
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UpdateUpcomingUses(plain)
	return nil
}

// 更新用户的NFT
// 可能是添加或者数量变更.
type UpdateUserNFT struct {
	// 消息版本号
	Etag int `json:"etag" yaml:"etag" mapstructure:"etag"`

	// 来源坐标
	// 当捡取时携带且不为0
	FromLandId int `json:"fromLandId" yaml:"fromLandId" mapstructure:"fromLandId"`

	// NFT信息
	Nft NFT `json:"nft" yaml:"nft" mapstructure:"nft"`

	// 接收NFT的用户钱包地址
	RecipientBlockchainAddress *string `json:"recipientBlockchainAddress,omitempty" yaml:"recipientBlockchainAddress,omitempty" mapstructure:"recipientBlockchainAddress,omitempty"`

	// 发送NFT的用户钱包地址
	SenderBlockchainAddress *string `json:"senderBlockchainAddress,omitempty" yaml:"senderBlockchainAddress,omitempty" mapstructure:"senderBlockchainAddress,omitempty"`

	// 区块链交易hash
	Txn *string `json:"txn,omitempty" yaml:"txn,omitempty" mapstructure:"txn,omitempty"`

	// 归属用户id
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UpdateUserNFT) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["etag"]; !ok || v == nil {
		return fmt.Errorf("field etag in UpdateUserNFT: required")
	}
	if v, ok := raw["fromLandId"]; !ok || v == nil {
		return fmt.Errorf("field fromLandId in UpdateUserNFT: required")
	}
	if v, ok := raw["nft"]; !ok || v == nil {
		return fmt.Errorf("field nft in UpdateUserNFT: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId in UpdateUserNFT: required")
	}
	type Plain UpdateUserNFT
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UpdateUserNFT(plain)
	return nil
}

type UpgradePlayerItemSlotsInput struct {
	// ItemSlots corresponds to the JSON schema field "itemSlots".
	ItemSlots []PlayerItemSlot `json:"itemSlots" yaml:"itemSlots" mapstructure:"itemSlots"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UpgradePlayerItemSlotsInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["itemSlots"]; !ok || v == nil {
		return fmt.Errorf("field itemSlots in UpgradePlayerItemSlotsInput: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId in UpgradePlayerItemSlotsInput: required")
	}
	type Plain UpgradePlayerItemSlotsInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UpgradePlayerItemSlotsInput(plain)
	return nil
}

type UpgradePlayerItemSlotsOutput struct {
	// 是否成功
	Success bool `json:"success" yaml:"success" mapstructure:"success"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UpgradePlayerItemSlotsOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["success"]; !ok || v == nil {
		return fmt.Errorf("field success in UpgradePlayerItemSlotsOutput: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId in UpgradePlayerItemSlotsOutput: required")
	}
	type Plain UpgradePlayerItemSlotsOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UpgradePlayerItemSlotsOutput(plain)
	return nil
}

type UseEquipment struct {
	// 装备位置 对时装和装备有效
	AvatarPos int `json:"avatarPos" yaml:"avatarPos" mapstructure:"avatarPos"`

	// Cid corresponds to the JSON schema field "cid".
	Cid int `json:"cid" yaml:"cid" mapstructure:"cid"`

	// NftId corresponds to the JSON schema field "nftId".
	NftId string `json:"nftId" yaml:"nftId" mapstructure:"nftId"`

	// 游戏角色id
	PlayerId string `json:"playerId" yaml:"playerId" mapstructure:"playerId"`

	// 用户id
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UseEquipment) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["avatarPos"]; !ok || v == nil {
		return fmt.Errorf("field avatarPos in UseEquipment: required")
	}
	if v, ok := raw["cid"]; !ok || v == nil {
		return fmt.Errorf("field cid in UseEquipment: required")
	}
	if v, ok := raw["nftId"]; !ok || v == nil {
		return fmt.Errorf("field nftId in UseEquipment: required")
	}
	if v, ok := raw["playerId"]; !ok || v == nil {
		return fmt.Errorf("field playerId in UseEquipment: required")
	}
	if v, ok := raw["userId"]; !ok || v == nil {
		return fmt.Errorf("field userId in UseEquipment: required")
	}
	type Plain UseEquipment
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UseEquipment(plain)
	return nil
}

type UserType string

var enumValues_UserType = []interface{}{
	"MANAGER",
	"STUDENT",
	"TEACHER",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UserType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_UserType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_UserType, v)
	}
	*j = UserType(v)
	return nil
}

const UserTypeMANAGER UserType = "MANAGER"
const UserTypeSTUDENT UserType = "STUDENT"
const UserTypeTEACHER UserType = "TEACHER"

type User struct {
	// Avatar corresponds to the JSON schema field "avatar".
	Avatar string `json:"avatar" yaml:"avatar" mapstructure:"avatar"`

	// Email corresponds to the JSON schema field "email".
	Email string `json:"email" yaml:"email" mapstructure:"email"`

	// Id corresponds to the JSON schema field "id".
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// Mobile corresponds to the JSON schema field "mobile".
	Mobile string `json:"mobile" yaml:"mobile" mapstructure:"mobile"`

	// Nickname corresponds to the JSON schema field "nickname".
	Nickname string `json:"nickname" yaml:"nickname" mapstructure:"nickname"`

	// Realname corresponds to the JSON schema field "realname".
	Realname string `json:"realname" yaml:"realname" mapstructure:"realname"`

	// SchoolId corresponds to the JSON schema field "schoolId".
	SchoolId string `json:"schoolId" yaml:"schoolId" mapstructure:"schoolId"`

	// Sex corresponds to the JSON schema field "sex".
	Sex Sex `json:"sex" yaml:"sex" mapstructure:"sex"`

	// Username corresponds to the JSON schema field "username".
	Username string `json:"username" yaml:"username" mapstructure:"username"`

	// Usertype corresponds to the JSON schema field "usertype".
	Usertype UserType `json:"usertype" yaml:"usertype" mapstructure:"usertype"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *User) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["avatar"]; !ok || v == nil {
		return fmt.Errorf("field avatar in User: required")
	}
	if v, ok := raw["email"]; !ok || v == nil {
		return fmt.Errorf("field email in User: required")
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id in User: required")
	}
	if v, ok := raw["mobile"]; !ok || v == nil {
		return fmt.Errorf("field mobile in User: required")
	}
	if v, ok := raw["nickname"]; !ok || v == nil {
		return fmt.Errorf("field nickname in User: required")
	}
	if v, ok := raw["realname"]; !ok || v == nil {
		return fmt.Errorf("field realname in User: required")
	}
	if v, ok := raw["schoolId"]; !ok || v == nil {
		return fmt.Errorf("field schoolId in User: required")
	}
	if v, ok := raw["sex"]; !ok || v == nil {
		return fmt.Errorf("field sex in User: required")
	}
	if v, ok := raw["username"]; !ok || v == nil {
		return fmt.Errorf("field username in User: required")
	}
	if v, ok := raw["usertype"]; !ok || v == nil {
		return fmt.Errorf("field usertype in User: required")
	}
	type Plain User
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = User(plain)
	return nil
}

type Web3ServiceAction string

var enumValues_Web3ServiceAction = []interface{}{
	"CheckMultiBatchBurnNFT",
	"CheckMultiBatchMintNFTWithAttributes",
	"CheckMultiUseLUAUSD",
	"ExecGameMessage",
	"ForgetUserRecipes",
	"GetGameMessageStatusById",
	"GetUserNFTsByUserIdAndAddress",
	"GetUserRecipes",
	"LearnUserRecipes",
	"MergeByRecipe",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Web3ServiceAction) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Web3ServiceAction {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Web3ServiceAction, v)
	}
	*j = Web3ServiceAction(v)
	return nil
}

const Web3ServiceActionCheckMultiBatchBurnNFT Web3ServiceAction = "CheckMultiBatchBurnNFT"
const Web3ServiceActionCheckMultiBatchMintNFTWithAttributes Web3ServiceAction = "CheckMultiBatchMintNFTWithAttributes"
const Web3ServiceActionCheckMultiUseLUAUSD Web3ServiceAction = "CheckMultiUseLUAUSD"
const Web3ServiceActionExecGameMessage Web3ServiceAction = "ExecGameMessage"
const Web3ServiceActionForgetUserRecipes Web3ServiceAction = "ForgetUserRecipes"
const Web3ServiceActionGetGameMessageStatusById Web3ServiceAction = "GetGameMessageStatusById"
const Web3ServiceActionGetUserNFTsByUserIdAndAddress Web3ServiceAction = "GetUserNFTsByUserIdAndAddress"
const Web3ServiceActionGetUserRecipes Web3ServiceAction = "GetUserRecipes"
const Web3ServiceActionLearnUserRecipes Web3ServiceAction = "LearnUserRecipes"
const Web3ServiceActionMergeByRecipe Web3ServiceAction = "MergeByRecipe"

type Integer float64
