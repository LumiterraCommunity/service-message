// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package main

import "encoding/json"
import "fmt"
import "reflect"
import "time"

type AccountMigrate struct {
	// FromAddress corresponds to the JSON schema field "fromAddress".
	FromAddress string `json:"fromAddress" yaml:"fromAddress" mapstructure:"fromAddress"`

	// ToAddress corresponds to the JSON schema field "toAddress".
	ToAddress string `json:"toAddress" yaml:"toAddress" mapstructure:"toAddress"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AccountMigrate) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["fromAddress"]; raw != nil && !ok {
		return fmt.Errorf("field fromAddress in AccountMigrate: required")
	}
	if _, ok := raw["toAddress"]; raw != nil && !ok {
		return fmt.Errorf("field toAddress in AccountMigrate: required")
	}
	type Plain AccountMigrate
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = AccountMigrate(plain)
	return nil
}

type AppId string

const AppIdGameServiceMain AppId = "game-service-main"
const AppIdGameServiceRank AppId = "game-service-rank"
const AppIdGraphqlService AppId = "graphql-service"
const AppIdPvpService AppId = "pvp-service"
const AppIdSceneDynamicService AppId = "scene-dynamic-service"
const AppIdWeb3Service AppId = "web3-service"

var enumValues_AppId = []interface{}{
	"game-service-main",
	"game-service-rank",
	"graphql-service",
	"pvp-service",
	"scene-dynamic-service",
	"web3-service",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AppId) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AppId {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AppId, v)
	}
	*j = AppId(v)
	return nil
}

type AttributeChangeData struct {
	// After corresponds to the JSON schema field "after".
	After int `json:"after" yaml:"after" mapstructure:"after"`

	// Before corresponds to the JSON schema field "before".
	Before int `json:"before" yaml:"before" mapstructure:"before"`

	// Type corresponds to the JSON schema field "type".
	Type string `json:"type" yaml:"type" mapstructure:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AttributeChangeData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["after"]; raw != nil && !ok {
		return fmt.Errorf("field after in AttributeChangeData: required")
	}
	if _, ok := raw["before"]; raw != nil && !ok {
		return fmt.Errorf("field before in AttributeChangeData: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in AttributeChangeData: required")
	}
	type Plain AttributeChangeData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = AttributeChangeData(plain)
	return nil
}

type Auth struct {
	// AccessToken corresponds to the JSON schema field "accessToken".
	AccessToken string `json:"accessToken" yaml:"accessToken" mapstructure:"accessToken"`

	// UserType corresponds to the JSON schema field "userType".
	UserType *AuthUserType `json:"userType,omitempty" yaml:"userType,omitempty" mapstructure:"userType,omitempty"`
}

type AuthUserType string

const AuthUserTypeMANAGER AuthUserType = "MANAGER"
const AuthUserTypeSTUDENT AuthUserType = "STUDENT"
const AuthUserTypeTEACHER AuthUserType = "TEACHER"

var enumValues_AuthUserType = []interface{}{
	"MANAGER",
	"STUDENT",
	"TEACHER",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AuthUserType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AuthUserType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AuthUserType, v)
	}
	*j = AuthUserType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Auth) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["accessToken"]; raw != nil && !ok {
		return fmt.Errorf("field accessToken in Auth: required")
	}
	type Plain Auth
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Auth(plain)
	return nil
}

type BatchBurnNFT struct {
	// index和itemIds一一对应
	// 所有数量
	Amounts []int `json:"amounts" yaml:"amounts" mapstructure:"amounts"`

	// ItemIds corresponds to the JSON schema field "itemIds".
	ItemIds []string `json:"itemIds,omitempty" yaml:"itemIds,omitempty" mapstructure:"itemIds,omitempty"`

	// NftIds corresponds to the JSON schema field "nftIds".
	NftIds []string `json:"nftIds,omitempty" yaml:"nftIds,omitempty" mapstructure:"nftIds,omitempty"`

	// NftTrackingMessage corresponds to the JSON schema field "nftTrackingMessage".
	NftTrackingMessage NFTTracking `json:"nftTrackingMessage" yaml:"nftTrackingMessage" mapstructure:"nftTrackingMessage"`

	// 每个用户的消耗备注
	Remark string `json:"remark" yaml:"remark" mapstructure:"remark"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

type BatchBurnNFTInput struct {
	// index和itemIds一一对应
	// 所有数量
	Amounts []int `json:"amounts" yaml:"amounts" mapstructure:"amounts"`

	// ItemIds corresponds to the JSON schema field "itemIds".
	ItemIds []string `json:"itemIds,omitempty" yaml:"itemIds,omitempty" mapstructure:"itemIds,omitempty"`

	// NftIds corresponds to the JSON schema field "nftIds".
	NftIds []string `json:"nftIds,omitempty" yaml:"nftIds,omitempty" mapstructure:"nftIds,omitempty"`

	// 每个用户的消耗备注
	Remark string `json:"remark" yaml:"remark" mapstructure:"remark"`

	// UniqueId corresponds to the JSON schema field "uniqueId".
	UniqueId string `json:"uniqueId" yaml:"uniqueId" mapstructure:"uniqueId"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BatchBurnNFTInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["amounts"]; raw != nil && !ok {
		return fmt.Errorf("field amounts in BatchBurnNFTInput: required")
	}
	if _, ok := raw["remark"]; raw != nil && !ok {
		return fmt.Errorf("field remark in BatchBurnNFTInput: required")
	}
	if _, ok := raw["uniqueId"]; raw != nil && !ok {
		return fmt.Errorf("field uniqueId in BatchBurnNFTInput: required")
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in BatchBurnNFTInput: required")
	}
	type Plain BatchBurnNFTInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BatchBurnNFTInput(plain)
	return nil
}

type BatchBurnNFTOutput struct {
	// GameMessageId corresponds to the JSON schema field "gameMessageId".
	GameMessageId string `json:"gameMessageId" yaml:"gameMessageId" mapstructure:"gameMessageId"`

	// Reason corresponds to the JSON schema field "reason".
	Reason string `json:"reason" yaml:"reason" mapstructure:"reason"`

	// Success corresponds to the JSON schema field "success".
	Success bool `json:"success" yaml:"success" mapstructure:"success"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BatchBurnNFTOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["gameMessageId"]; raw != nil && !ok {
		return fmt.Errorf("field gameMessageId in BatchBurnNFTOutput: required")
	}
	if _, ok := raw["reason"]; raw != nil && !ok {
		return fmt.Errorf("field reason in BatchBurnNFTOutput: required")
	}
	if _, ok := raw["success"]; raw != nil && !ok {
		return fmt.Errorf("field success in BatchBurnNFTOutput: required")
	}
	type Plain BatchBurnNFTOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BatchBurnNFTOutput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BatchBurnNFT) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["amounts"]; raw != nil && !ok {
		return fmt.Errorf("field amounts in BatchBurnNFT: required")
	}
	if _, ok := raw["nftTrackingMessage"]; raw != nil && !ok {
		return fmt.Errorf("field nftTrackingMessage in BatchBurnNFT: required")
	}
	if _, ok := raw["remark"]; raw != nil && !ok {
		return fmt.Errorf("field remark in BatchBurnNFT: required")
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in BatchBurnNFT: required")
	}
	type Plain BatchBurnNFT
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BatchBurnNFT(plain)
	return nil
}

type BatchGetGameMessageStatusInput struct {
	// MessageIds corresponds to the JSON schema field "messageIds".
	MessageIds []string `json:"messageIds" yaml:"messageIds" mapstructure:"messageIds"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BatchGetGameMessageStatusInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["messageIds"]; raw != nil && !ok {
		return fmt.Errorf("field messageIds in BatchGetGameMessageStatusInput: required")
	}
	type Plain BatchGetGameMessageStatusInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BatchGetGameMessageStatusInput(plain)
	return nil
}

type BatchGetGameMessageStatusOutput struct {
	// Results corresponds to the JSON schema field "results".
	Results []GameMessageResult `json:"results" yaml:"results" mapstructure:"results"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BatchGetGameMessageStatusOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["results"]; raw != nil && !ok {
		return fmt.Errorf("field results in BatchGetGameMessageStatusOutput: required")
	}
	type Plain BatchGetGameMessageStatusOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BatchGetGameMessageStatusOutput(plain)
	return nil
}

type BatchMintNFT struct {
	// index和itemIds一一对应
	// 所有数量
	Amounts []int `json:"amounts" yaml:"amounts" mapstructure:"amounts"`

	// 需要mint的所有的itemId
	ItemIds []string `json:"itemIds" yaml:"itemIds" mapstructure:"itemIds"`

	// NftTrackingMessage corresponds to the JSON schema field "nftTrackingMessage".
	NftTrackingMessage NFTTracking `json:"nftTrackingMessage" yaml:"nftTrackingMessage" mapstructure:"nftTrackingMessage"`

	// 所有的品质
	// index和itemIds一一对应
	QualityVals []string `json:"qualityVals,omitempty" yaml:"qualityVals,omitempty" mapstructure:"qualityVals,omitempty"`

	// 所有的品质
	// index和itemIds一一对应
	Qualitys []BatchMintNFTQualitysElem `json:"qualitys,omitempty" yaml:"qualitys,omitempty" mapstructure:"qualitys,omitempty"`

	// Remark corresponds to the JSON schema field "remark".
	Remark string `json:"remark" yaml:"remark" mapstructure:"remark"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

type BatchMintNFTByAddress struct {
	// index和itemIds一一对应
	// 所有数量
	Amounts []int `json:"amounts" yaml:"amounts" mapstructure:"amounts"`

	// 需要mint的所有的itemId
	ItemIds []string `json:"itemIds" yaml:"itemIds" mapstructure:"itemIds"`

	// 所有的品质
	// index和itemIds一一对应
	QualityVals []string `json:"qualityVals,omitempty" yaml:"qualityVals,omitempty" mapstructure:"qualityVals,omitempty"`

	// 所有的品质
	// index和itemIds一一对应
	Qualitys []BatchMintNFTByAddressQualitysElem `json:"qualitys,omitempty" yaml:"qualitys,omitempty" mapstructure:"qualitys,omitempty"`

	// Remark corresponds to the JSON schema field "remark".
	Remark string `json:"remark" yaml:"remark" mapstructure:"remark"`

	// UserAddress corresponds to the JSON schema field "userAddress".
	UserAddress string `json:"userAddress" yaml:"userAddress" mapstructure:"userAddress"`
}

type BatchMintNFTByAddressQualitysElem string

const BatchMintNFTByAddressQualitysElemAdvanced BatchMintNFTByAddressQualitysElem = "Advanced"
const BatchMintNFTByAddressQualitysElemBasic BatchMintNFTByAddressQualitysElem = "Basic"
const BatchMintNFTByAddressQualitysElemEnhanced BatchMintNFTByAddressQualitysElem = "Enhanced"
const BatchMintNFTByAddressQualitysElemSuper BatchMintNFTByAddressQualitysElem = "Super"
const BatchMintNFTByAddressQualitysElemUltimate BatchMintNFTByAddressQualitysElem = "Ultimate"

var enumValues_BatchMintNFTByAddressQualitysElem = []interface{}{
	"Advanced",
	"Basic",
	"Enhanced",
	"Super",
	"Ultimate",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BatchMintNFTByAddressQualitysElem) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_BatchMintNFTByAddressQualitysElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_BatchMintNFTByAddressQualitysElem, v)
	}
	*j = BatchMintNFTByAddressQualitysElem(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BatchMintNFTByAddress) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["amounts"]; raw != nil && !ok {
		return fmt.Errorf("field amounts in BatchMintNFTByAddress: required")
	}
	if _, ok := raw["itemIds"]; raw != nil && !ok {
		return fmt.Errorf("field itemIds in BatchMintNFTByAddress: required")
	}
	if _, ok := raw["remark"]; raw != nil && !ok {
		return fmt.Errorf("field remark in BatchMintNFTByAddress: required")
	}
	if _, ok := raw["userAddress"]; raw != nil && !ok {
		return fmt.Errorf("field userAddress in BatchMintNFTByAddress: required")
	}
	type Plain BatchMintNFTByAddress
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BatchMintNFTByAddress(plain)
	return nil
}

type BatchMintNFTQualitysElem string

const BatchMintNFTQualitysElemAdvanced BatchMintNFTQualitysElem = "Advanced"
const BatchMintNFTQualitysElemBasic BatchMintNFTQualitysElem = "Basic"
const BatchMintNFTQualitysElemEnhanced BatchMintNFTQualitysElem = "Enhanced"
const BatchMintNFTQualitysElemSuper BatchMintNFTQualitysElem = "Super"
const BatchMintNFTQualitysElemUltimate BatchMintNFTQualitysElem = "Ultimate"

var enumValues_BatchMintNFTQualitysElem = []interface{}{
	"Advanced",
	"Basic",
	"Enhanced",
	"Super",
	"Ultimate",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BatchMintNFTQualitysElem) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_BatchMintNFTQualitysElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_BatchMintNFTQualitysElem, v)
	}
	*j = BatchMintNFTQualitysElem(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BatchMintNFT) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["amounts"]; raw != nil && !ok {
		return fmt.Errorf("field amounts in BatchMintNFT: required")
	}
	if _, ok := raw["itemIds"]; raw != nil && !ok {
		return fmt.Errorf("field itemIds in BatchMintNFT: required")
	}
	if _, ok := raw["nftTrackingMessage"]; raw != nil && !ok {
		return fmt.Errorf("field nftTrackingMessage in BatchMintNFT: required")
	}
	if _, ok := raw["remark"]; raw != nil && !ok {
		return fmt.Errorf("field remark in BatchMintNFT: required")
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in BatchMintNFT: required")
	}
	type Plain BatchMintNFT
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BatchMintNFT(plain)
	return nil
}

type BatchTransferNFT struct {
	// index和itemIds一一对应
	// 所有数量
	Amounts []int `json:"amounts" yaml:"amounts" mapstructure:"amounts"`

	// FromUserId corresponds to the JSON schema field "fromUserId".
	FromUserId string `json:"fromUserId" yaml:"fromUserId" mapstructure:"fromUserId"`

	// NftIds corresponds to the JSON schema field "nftIds".
	NftIds []string `json:"nftIds" yaml:"nftIds" mapstructure:"nftIds"`

	// 每个用户的消耗备注
	Remark string `json:"remark" yaml:"remark" mapstructure:"remark"`

	// ToUserId corresponds to the JSON schema field "toUserId".
	ToUserId string `json:"toUserId" yaml:"toUserId" mapstructure:"toUserId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BatchTransferNFT) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["amounts"]; raw != nil && !ok {
		return fmt.Errorf("field amounts in BatchTransferNFT: required")
	}
	if _, ok := raw["fromUserId"]; raw != nil && !ok {
		return fmt.Errorf("field fromUserId in BatchTransferNFT: required")
	}
	if _, ok := raw["nftIds"]; raw != nil && !ok {
		return fmt.Errorf("field nftIds in BatchTransferNFT: required")
	}
	if _, ok := raw["remark"]; raw != nil && !ok {
		return fmt.Errorf("field remark in BatchTransferNFT: required")
	}
	if _, ok := raw["toUserId"]; raw != nil && !ok {
		return fmt.Errorf("field toUserId in BatchTransferNFT: required")
	}
	type Plain BatchTransferNFT
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BatchTransferNFT(plain)
	return nil
}

type BuildData struct {
	// 建造id
	BuildId int `json:"buildId" yaml:"buildId" mapstructure:"buildId"`

	// 下次可采集(偷取)的时间戳 单位秒
	CollectionAt int `json:"collectionAt" yaml:"collectionAt" mapstructure:"collectionAt"`

	// 可采集(偷取)物品数量统计
	CollectionItemCount int `json:"collectionItemCount" yaml:"collectionItemCount" mapstructure:"collectionItemCount"`

	// 采集开始时间点
	CollectionStartAt int `json:"collectionStartAt" yaml:"collectionStartAt" mapstructure:"collectionStartAt"`

	// 电量过期时间 单位秒
	ElectricEnd int `json:"electricEnd" yaml:"electricEnd" mapstructure:"electricEnd"`

	// 可以收集的时间
	HarvestAt int `json:"harvestAt" yaml:"harvestAt" mapstructure:"harvestAt"`

	// 可收获的物品数量统计(没电时转移到采集) 单位秒
	HarvestItemCount int `json:"harvestItemCount" yaml:"harvestItemCount" mapstructure:"harvestItemCount"`

	// 产出开始时间点.
	HarvestStartAt int `json:"harvestStartAt" yaml:"harvestStartAt" mapstructure:"harvestStartAt"`

	// LandIds corresponds to the JSON schema field "landIds".
	LandIds []int `json:"landIds" yaml:"landIds" mapstructure:"landIds"`

	// LandPlacementPowerZeroCooldownAt corresponds to the JSON schema field
	// "landPlacementPowerZeroCooldownAt".
	LandPlacementPowerZeroCooldownAt int `json:"landPlacementPowerZeroCooldownAt" yaml:"landPlacementPowerZeroCooldownAt" mapstructure:"landPlacementPowerZeroCooldownAt"`

	// LandPlacementPowerZeroCooldownStartAt corresponds to the JSON schema field
	// "landPlacementPowerZeroCooldownStartAt".
	LandPlacementPowerZeroCooldownStartAt int `json:"landPlacementPowerZeroCooldownStartAt" yaml:"landPlacementPowerZeroCooldownStartAt" mapstructure:"landPlacementPowerZeroCooldownStartAt"`

	// 地图id 为多地图准备
	MapId int `json:"mapId" yaml:"mapId" mapstructure:"mapId"`

	// nftId
	NftId string `json:"nftId" yaml:"nftId" mapstructure:"nftId"`

	// 玩家id
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BuildData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["buildId"]; raw != nil && !ok {
		return fmt.Errorf("field buildId in BuildData: required")
	}
	if _, ok := raw["collectionAt"]; raw != nil && !ok {
		return fmt.Errorf("field collectionAt in BuildData: required")
	}
	if _, ok := raw["collectionItemCount"]; raw != nil && !ok {
		return fmt.Errorf("field collectionItemCount in BuildData: required")
	}
	if _, ok := raw["collectionStartAt"]; raw != nil && !ok {
		return fmt.Errorf("field collectionStartAt in BuildData: required")
	}
	if _, ok := raw["electricEnd"]; raw != nil && !ok {
		return fmt.Errorf("field electricEnd in BuildData: required")
	}
	if _, ok := raw["harvestAt"]; raw != nil && !ok {
		return fmt.Errorf("field harvestAt in BuildData: required")
	}
	if _, ok := raw["harvestItemCount"]; raw != nil && !ok {
		return fmt.Errorf("field harvestItemCount in BuildData: required")
	}
	if _, ok := raw["harvestStartAt"]; raw != nil && !ok {
		return fmt.Errorf("field harvestStartAt in BuildData: required")
	}
	if _, ok := raw["landIds"]; raw != nil && !ok {
		return fmt.Errorf("field landIds in BuildData: required")
	}
	if _, ok := raw["landPlacementPowerZeroCooldownAt"]; raw != nil && !ok {
		return fmt.Errorf("field landPlacementPowerZeroCooldownAt in BuildData: required")
	}
	if _, ok := raw["landPlacementPowerZeroCooldownStartAt"]; raw != nil && !ok {
		return fmt.Errorf("field landPlacementPowerZeroCooldownStartAt in BuildData: required")
	}
	if _, ok := raw["mapId"]; raw != nil && !ok {
		return fmt.Errorf("field mapId in BuildData: required")
	}
	if _, ok := raw["nftId"]; raw != nil && !ok {
		return fmt.Errorf("field nftId in BuildData: required")
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in BuildData: required")
	}
	type Plain BuildData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BuildData(plain)
	return nil
}

type BuildInput struct {
	// LandIds corresponds to the JSON schema field "landIds".
	LandIds []int `json:"landIds" yaml:"landIds" mapstructure:"landIds"`

	// 地图id 为多地图准备
	MapId int `json:"mapId" yaml:"mapId" mapstructure:"mapId"`

	// nftId
	NftId string `json:"nftId" yaml:"nftId" mapstructure:"nftId"`

	// 玩家id
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BuildInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["landIds"]; raw != nil && !ok {
		return fmt.Errorf("field landIds in BuildInput: required")
	}
	if _, ok := raw["mapId"]; raw != nil && !ok {
		return fmt.Errorf("field mapId in BuildInput: required")
	}
	if _, ok := raw["nftId"]; raw != nil && !ok {
		return fmt.Errorf("field nftId in BuildInput: required")
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in BuildInput: required")
	}
	type Plain BuildInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BuildInput(plain)
	return nil
}

type BuildOutput struct {
	// 建造物信息
	BuildData *BuildData `json:"buildData,omitempty" yaml:"buildData,omitempty" mapstructure:"buildData,omitempty"`

	// 失败, 则返回失败原因, 否则返回空字符串
	FailedReason string `json:"failedReason" yaml:"failedReason" mapstructure:"failedReason"`

	// 是否成功
	Success bool `json:"success" yaml:"success" mapstructure:"success"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BuildOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["failedReason"]; raw != nil && !ok {
		return fmt.Errorf("field failedReason in BuildOutput: required")
	}
	if _, ok := raw["success"]; raw != nil && !ok {
		return fmt.Errorf("field success in BuildOutput: required")
	}
	type Plain BuildOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BuildOutput(plain)
	return nil
}

type CanBuildNFTInput struct {
	// 实体存活时间，对第三方NFT有效, 单位(秒)
	AliveTimeSec int `json:"aliveTimeSec" yaml:"aliveTimeSec" mapstructure:"aliveTimeSec"`

	// NFT Id
	NftId string `json:"nftId" yaml:"nftId" mapstructure:"nftId"`

	// 归属用户id
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CanBuildNFTInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["aliveTimeSec"]; raw != nil && !ok {
		return fmt.Errorf("field aliveTimeSec in CanBuildNFTInput: required")
	}
	if _, ok := raw["nftId"]; raw != nil && !ok {
		return fmt.Errorf("field nftId in CanBuildNFTInput: required")
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in CanBuildNFTInput: required")
	}
	type Plain CanBuildNFTInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CanBuildNFTInput(plain)
	return nil
}

type CanBuildNFTOutput struct {
	// CanBuild corresponds to the JSON schema field "canBuild".
	CanBuild bool `json:"canBuild" yaml:"canBuild" mapstructure:"canBuild"`

	// NFT id
	NftId string `json:"nftId" yaml:"nftId" mapstructure:"nftId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CanBuildNFTOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["canBuild"]; raw != nil && !ok {
		return fmt.Errorf("field canBuild in CanBuildNFTOutput: required")
	}
	if _, ok := raw["nftId"]; raw != nil && !ok {
		return fmt.Errorf("field nftId in CanBuildNFTOutput: required")
	}
	type Plain CanBuildNFTOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CanBuildNFTOutput(plain)
	return nil
}

type ChargedInput struct {
	// 建造id
	BuildId int `json:"buildId" yaml:"buildId" mapstructure:"buildId"`

	// 地图id 为多地图准备
	MapId int `json:"mapId" yaml:"mapId" mapstructure:"mapId"`

	// 电池数量
	Num int `json:"num" yaml:"num" mapstructure:"num"`

	// 玩家id
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ChargedInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["buildId"]; raw != nil && !ok {
		return fmt.Errorf("field buildId in ChargedInput: required")
	}
	if _, ok := raw["mapId"]; raw != nil && !ok {
		return fmt.Errorf("field mapId in ChargedInput: required")
	}
	if _, ok := raw["num"]; raw != nil && !ok {
		return fmt.Errorf("field num in ChargedInput: required")
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in ChargedInput: required")
	}
	type Plain ChargedInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ChargedInput(plain)
	return nil
}

type ChargedOutput struct {
	// 失败, 则返回失败原因, 否则返回空字符串
	FailedReason string `json:"failedReason" yaml:"failedReason" mapstructure:"failedReason"`

	// 是否成功
	Success bool `json:"success" yaml:"success" mapstructure:"success"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ChargedOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["failedReason"]; raw != nil && !ok {
		return fmt.Errorf("field failedReason in ChargedOutput: required")
	}
	if _, ok := raw["success"]; raw != nil && !ok {
		return fmt.Errorf("field success in ChargedOutput: required")
	}
	type Plain ChargedOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ChargedOutput(plain)
	return nil
}

type CheckMintNFTWithAttributesInput struct {
	// Input corresponds to the JSON schema field "input".
	Input MintNFTWithAttributes `json:"input" yaml:"input" mapstructure:"input"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CheckMintNFTWithAttributesInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["input"]; raw != nil && !ok {
		return fmt.Errorf("field input in CheckMintNFTWithAttributesInput: required")
	}
	type Plain CheckMintNFTWithAttributesInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CheckMintNFTWithAttributesInput(plain)
	return nil
}

type CheckMintNFTWithAttributesOutput struct {
	// Resaon corresponds to the JSON schema field "resaon".
	Resaon string `json:"resaon" yaml:"resaon" mapstructure:"resaon"`

	// Result corresponds to the JSON schema field "result".
	Result bool `json:"result" yaml:"result" mapstructure:"result"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CheckMintNFTWithAttributesOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["resaon"]; raw != nil && !ok {
		return fmt.Errorf("field resaon in CheckMintNFTWithAttributesOutput: required")
	}
	if _, ok := raw["result"]; raw != nil && !ok {
		return fmt.Errorf("field result in CheckMintNFTWithAttributesOutput: required")
	}
	type Plain CheckMintNFTWithAttributesOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CheckMintNFTWithAttributesOutput(plain)
	return nil
}

type CheckMultiBatchBurnNFTInput struct {
	// Inputs corresponds to the JSON schema field "inputs".
	Inputs []BatchBurnNFT `json:"inputs" yaml:"inputs" mapstructure:"inputs"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CheckMultiBatchBurnNFTInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["inputs"]; raw != nil && !ok {
		return fmt.Errorf("field inputs in CheckMultiBatchBurnNFTInput: required")
	}
	type Plain CheckMultiBatchBurnNFTInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CheckMultiBatchBurnNFTInput(plain)
	return nil
}

type CheckMultiBatchBurnNFTOutput struct {
	// Results corresponds to the JSON schema field "results".
	Results []bool `json:"results" yaml:"results" mapstructure:"results"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CheckMultiBatchBurnNFTOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["results"]; raw != nil && !ok {
		return fmt.Errorf("field results in CheckMultiBatchBurnNFTOutput: required")
	}
	type Plain CheckMultiBatchBurnNFTOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CheckMultiBatchBurnNFTOutput(plain)
	return nil
}

type CheckMultiUseLUAUSDInput struct {
	// Inputs corresponds to the JSON schema field "inputs".
	Inputs []UseLUAUSD `json:"inputs" yaml:"inputs" mapstructure:"inputs"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CheckMultiUseLUAUSDInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["inputs"]; raw != nil && !ok {
		return fmt.Errorf("field inputs in CheckMultiUseLUAUSDInput: required")
	}
	type Plain CheckMultiUseLUAUSDInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CheckMultiUseLUAUSDInput(plain)
	return nil
}

type CheckMultiUseLUAUSDOutput struct {
	// Results corresponds to the JSON schema field "results".
	Results []bool `json:"results" yaml:"results" mapstructure:"results"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CheckMultiUseLUAUSDOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["results"]; raw != nil && !ok {
		return fmt.Errorf("field results in CheckMultiUseLUAUSDOutput: required")
	}
	type Plain CheckMultiUseLUAUSDOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CheckMultiUseLUAUSDOutput(plain)
	return nil
}

type CheckQuestionAnswerInput struct {
	// AnswerJSON corresponds to the JSON schema field "answerJSON".
	AnswerJSON string `json:"answerJSON" yaml:"answerJSON" mapstructure:"answerJSON"`

	// QuestionId corresponds to the JSON schema field "questionId".
	QuestionId string `json:"questionId" yaml:"questionId" mapstructure:"questionId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CheckQuestionAnswerInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["answerJSON"]; raw != nil && !ok {
		return fmt.Errorf("field answerJSON in CheckQuestionAnswerInput: required")
	}
	if _, ok := raw["questionId"]; raw != nil && !ok {
		return fmt.Errorf("field questionId in CheckQuestionAnswerInput: required")
	}
	type Plain CheckQuestionAnswerInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CheckQuestionAnswerInput(plain)
	return nil
}

type CheckQuestionAnswerOutput struct {
	// IsCorrect corresponds to the JSON schema field "isCorrect".
	IsCorrect bool `json:"isCorrect" yaml:"isCorrect" mapstructure:"isCorrect"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CheckQuestionAnswerOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["isCorrect"]; raw != nil && !ok {
		return fmt.Errorf("field isCorrect in CheckQuestionAnswerOutput: required")
	}
	type Plain CheckQuestionAnswerOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CheckQuestionAnswerOutput(plain)
	return nil
}

type CheckUserRecipeInput struct {
	// RecipeId corresponds to the JSON schema field "recipeId".
	RecipeId string `json:"recipeId" yaml:"recipeId" mapstructure:"recipeId"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CheckUserRecipeInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["recipeId"]; raw != nil && !ok {
		return fmt.Errorf("field recipeId in CheckUserRecipeInput: required")
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in CheckUserRecipeInput: required")
	}
	type Plain CheckUserRecipeInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CheckUserRecipeInput(plain)
	return nil
}

type CheckUserRecipeOutput struct {
	// HasRecipe corresponds to the JSON schema field "hasRecipe".
	HasRecipe bool `json:"hasRecipe" yaml:"hasRecipe" mapstructure:"hasRecipe"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CheckUserRecipeOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["hasRecipe"]; raw != nil && !ok {
		return fmt.Errorf("field hasRecipe in CheckUserRecipeOutput: required")
	}
	type Plain CheckUserRecipeOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CheckUserRecipeOutput(plain)
	return nil
}

type CloseServer struct {
	// ServerAppId corresponds to the JSON schema field "serverAppId".
	ServerAppId string `json:"serverAppId" yaml:"serverAppId" mapstructure:"serverAppId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CloseServer) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["serverAppId"]; raw != nil && !ok {
		return fmt.Errorf("field serverAppId in CloseServer: required")
	}
	type Plain CloseServer
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CloseServer(plain)
	return nil
}

type CollectionInput struct {
	// 建造Id
	BuildId int `json:"buildId" yaml:"buildId" mapstructure:"buildId"`

	// 地图id 为多地图准备
	MapId int `json:"mapId" yaml:"mapId" mapstructure:"mapId"`

	// 玩家id
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CollectionInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["buildId"]; raw != nil && !ok {
		return fmt.Errorf("field buildId in CollectionInput: required")
	}
	if _, ok := raw["mapId"]; raw != nil && !ok {
		return fmt.Errorf("field mapId in CollectionInput: required")
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in CollectionInput: required")
	}
	type Plain CollectionInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CollectionInput(plain)
	return nil
}

type CollectionOutput struct {
	// 失败, 则返回失败原因, 否则返回空字符串
	FailedReason string `json:"failedReason" yaml:"failedReason" mapstructure:"failedReason"`

	// 是否成功
	Success bool `json:"success" yaml:"success" mapstructure:"success"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CollectionOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["failedReason"]; raw != nil && !ok {
		return fmt.Errorf("field failedReason in CollectionOutput: required")
	}
	if _, ok := raw["success"]; raw != nil && !ok {
		return fmt.Errorf("field success in CollectionOutput: required")
	}
	type Plain CollectionOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CollectionOutput(plain)
	return nil
}

type CreatePVPRoomInput map[string]interface{}

type CreatePVPRoomOutput struct {
	// RoomId corresponds to the JSON schema field "roomId".
	RoomId string `json:"roomId" yaml:"roomId" mapstructure:"roomId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CreatePVPRoomOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["roomId"]; raw != nil && !ok {
		return fmt.Errorf("field roomId in CreatePVPRoomOutput: required")
	}
	type Plain CreatePVPRoomOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CreatePVPRoomOutput(plain)
	return nil
}

type DeductUserExpInput struct {
	// DeductExp corresponds to the JSON schema field "deductExp".
	DeductExp int `json:"deductExp" yaml:"deductExp" mapstructure:"deductExp"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DeductUserExpInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["deductExp"]; raw != nil && !ok {
		return fmt.Errorf("field deductExp in DeductUserExpInput: required")
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in DeductUserExpInput: required")
	}
	type Plain DeductUserExpInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = DeductUserExpInput(plain)
	return nil
}

type DeductUserExpOutput struct {
	// 是否扣除成功
	DeductSuccess bool `json:"deductSuccess" yaml:"deductSuccess" mapstructure:"deductSuccess"`

	// 如果扣除失败, 则返回失败原因, 否则返回空字符串
	FailedReason string `json:"failedReason" yaml:"failedReason" mapstructure:"failedReason"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DeductUserExpOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["deductSuccess"]; raw != nil && !ok {
		return fmt.Errorf("field deductSuccess in DeductUserExpOutput: required")
	}
	if _, ok := raw["failedReason"]; raw != nil && !ok {
		return fmt.Errorf("field failedReason in DeductUserExpOutput: required")
	}
	type Plain DeductUserExpOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = DeductUserExpOutput(plain)
	return nil
}

type DispatchGameMessage struct {
	// IsLarge corresponds to the JSON schema field "isLarge".
	IsLarge bool `json:"isLarge" yaml:"isLarge" mapstructure:"isLarge"`

	// MessageId corresponds to the JSON schema field "messageId".
	MessageId string `json:"messageId" yaml:"messageId" mapstructure:"messageId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DispatchGameMessage) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["isLarge"]; raw != nil && !ok {
		return fmt.Errorf("field isLarge in DispatchGameMessage: required")
	}
	if _, ok := raw["messageId"]; raw != nil && !ok {
		return fmt.Errorf("field messageId in DispatchGameMessage: required")
	}
	type Plain DispatchGameMessage
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = DispatchGameMessage(plain)
	return nil
}

type DistributeDungeonBonus struct {
	// Amount corresponds to the JSON schema field "amount".
	Amount string `json:"amount" yaml:"amount" mapstructure:"amount"`

	// AppId corresponds to the JSON schema field "appId".
	AppId string `json:"appId" yaml:"appId" mapstructure:"appId"`

	// BonusId corresponds to the JSON schema field "bonusId".
	BonusId int `json:"bonusId" yaml:"bonusId" mapstructure:"bonusId"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DistributeDungeonBonus) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["amount"]; raw != nil && !ok {
		return fmt.Errorf("field amount in DistributeDungeonBonus: required")
	}
	if _, ok := raw["appId"]; raw != nil && !ok {
		return fmt.Errorf("field appId in DistributeDungeonBonus: required")
	}
	if _, ok := raw["bonusId"]; raw != nil && !ok {
		return fmt.Errorf("field bonusId in DistributeDungeonBonus: required")
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in DistributeDungeonBonus: required")
	}
	type Plain DistributeDungeonBonus
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = DistributeDungeonBonus(plain)
	return nil
}

type DistributeLUAG1Input struct {
	// Amount corresponds to the JSON schema field "amount".
	Amount int `json:"amount" yaml:"amount" mapstructure:"amount"`

	// TaskId corresponds to the JSON schema field "taskId".
	TaskId string `json:"taskId" yaml:"taskId" mapstructure:"taskId"`

	// TaskPoolId corresponds to the JSON schema field "taskPoolId".
	TaskPoolId string `json:"taskPoolId" yaml:"taskPoolId" mapstructure:"taskPoolId"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DistributeLUAG1Input) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["amount"]; raw != nil && !ok {
		return fmt.Errorf("field amount in DistributeLUAG1Input: required")
	}
	if _, ok := raw["taskId"]; raw != nil && !ok {
		return fmt.Errorf("field taskId in DistributeLUAG1Input: required")
	}
	if _, ok := raw["taskPoolId"]; raw != nil && !ok {
		return fmt.Errorf("field taskPoolId in DistributeLUAG1Input: required")
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in DistributeLUAG1Input: required")
	}
	type Plain DistributeLUAG1Input
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = DistributeLUAG1Input(plain)
	return nil
}

type DistributeLUAG1Output struct {
	// GameMessageId corresponds to the JSON schema field "gameMessageId".
	GameMessageId string `json:"gameMessageId" yaml:"gameMessageId" mapstructure:"gameMessageId"`

	// Reason corresponds to the JSON schema field "reason".
	Reason string `json:"reason" yaml:"reason" mapstructure:"reason"`

	// Success corresponds to the JSON schema field "success".
	Success bool `json:"success" yaml:"success" mapstructure:"success"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DistributeLUAG1Output) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["gameMessageId"]; raw != nil && !ok {
		return fmt.Errorf("field gameMessageId in DistributeLUAG1Output: required")
	}
	if _, ok := raw["reason"]; raw != nil && !ok {
		return fmt.Errorf("field reason in DistributeLUAG1Output: required")
	}
	if _, ok := raw["success"]; raw != nil && !ok {
		return fmt.Errorf("field success in DistributeLUAG1Output: required")
	}
	type Plain DistributeLUAG1Output
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = DistributeLUAG1Output(plain)
	return nil
}

type DistributeLUAUSDInput struct {
	// Amount corresponds to the JSON schema field "amount".
	Amount string `json:"amount" yaml:"amount" mapstructure:"amount"`

	// TaskId corresponds to the JSON schema field "taskId".
	TaskId string `json:"taskId" yaml:"taskId" mapstructure:"taskId"`

	// TaskPoolId corresponds to the JSON schema field "taskPoolId".
	TaskPoolId string `json:"taskPoolId" yaml:"taskPoolId" mapstructure:"taskPoolId"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DistributeLUAUSDInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["amount"]; raw != nil && !ok {
		return fmt.Errorf("field amount in DistributeLUAUSDInput: required")
	}
	if _, ok := raw["taskId"]; raw != nil && !ok {
		return fmt.Errorf("field taskId in DistributeLUAUSDInput: required")
	}
	if _, ok := raw["taskPoolId"]; raw != nil && !ok {
		return fmt.Errorf("field taskPoolId in DistributeLUAUSDInput: required")
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in DistributeLUAUSDInput: required")
	}
	type Plain DistributeLUAUSDInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = DistributeLUAUSDInput(plain)
	return nil
}

type DistributeLUAUSDOutput struct {
	// GameMessageId corresponds to the JSON schema field "gameMessageId".
	GameMessageId string `json:"gameMessageId" yaml:"gameMessageId" mapstructure:"gameMessageId"`

	// Reason corresponds to the JSON schema field "reason".
	Reason string `json:"reason" yaml:"reason" mapstructure:"reason"`

	// Success corresponds to the JSON schema field "success".
	Success bool `json:"success" yaml:"success" mapstructure:"success"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DistributeLUAUSDOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["gameMessageId"]; raw != nil && !ok {
		return fmt.Errorf("field gameMessageId in DistributeLUAUSDOutput: required")
	}
	if _, ok := raw["reason"]; raw != nil && !ok {
		return fmt.Errorf("field reason in DistributeLUAUSDOutput: required")
	}
	if _, ok := raw["success"]; raw != nil && !ok {
		return fmt.Errorf("field success in DistributeLUAUSDOutput: required")
	}
	type Plain DistributeLUAUSDOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = DistributeLUAUSDOutput(plain)
	return nil
}

type DivestDungeonInput struct {
	// DungeonId corresponds to the JSON schema field "dungeonId".
	DungeonId int `json:"dungeonId" yaml:"dungeonId" mapstructure:"dungeonId"`

	// MinOutAmount corresponds to the JSON schema field "minOutAmount".
	MinOutAmount string `json:"minOutAmount" yaml:"minOutAmount" mapstructure:"minOutAmount"`

	// RemoveBaseLP corresponds to the JSON schema field "removeBaseLP".
	RemoveBaseLP string `json:"removeBaseLP" yaml:"removeBaseLP" mapstructure:"removeBaseLP"`

	// TotemNFTId corresponds to the JSON schema field "totemNFTId".
	TotemNFTId string `json:"totemNFTId" yaml:"totemNFTId" mapstructure:"totemNFTId"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DivestDungeonInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["dungeonId"]; raw != nil && !ok {
		return fmt.Errorf("field dungeonId in DivestDungeonInput: required")
	}
	if _, ok := raw["minOutAmount"]; raw != nil && !ok {
		return fmt.Errorf("field minOutAmount in DivestDungeonInput: required")
	}
	if _, ok := raw["removeBaseLP"]; raw != nil && !ok {
		return fmt.Errorf("field removeBaseLP in DivestDungeonInput: required")
	}
	if _, ok := raw["totemNFTId"]; raw != nil && !ok {
		return fmt.Errorf("field totemNFTId in DivestDungeonInput: required")
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in DivestDungeonInput: required")
	}
	type Plain DivestDungeonInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = DivestDungeonInput(plain)
	return nil
}

type DivestDungeonOutput struct {
	// Reason corresponds to the JSON schema field "reason".
	Reason string `json:"reason" yaml:"reason" mapstructure:"reason"`

	// Success corresponds to the JSON schema field "success".
	Success bool `json:"success" yaml:"success" mapstructure:"success"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DivestDungeonOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["reason"]; raw != nil && !ok {
		return fmt.Errorf("field reason in DivestDungeonOutput: required")
	}
	if _, ok := raw["success"]; raw != nil && !ok {
		return fmt.Errorf("field success in DivestDungeonOutput: required")
	}
	type Plain DivestDungeonOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = DivestDungeonOutput(plain)
	return nil
}

type DungeonExtraDropPool struct {
	// Created corresponds to the JSON schema field "created".
	Created bool `json:"created" yaml:"created" mapstructure:"created"`

	// Id corresponds to the JSON schema field "id".
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// LevelRangeIdx corresponds to the JSON schema field "levelRangeIdx".
	LevelRangeIdx int `json:"levelRangeIdx" yaml:"levelRangeIdx" mapstructure:"levelRangeIdx"`

	// RaffleTicketNFTId corresponds to the JSON schema field "raffleTicketNFTId".
	RaffleTicketNFTId string `json:"raffleTicketNFTId" yaml:"raffleTicketNFTId" mapstructure:"raffleTicketNFTId"`

	// RaffleTicketNFTItemId corresponds to the JSON schema field
	// "raffleTicketNFTItemId".
	RaffleTicketNFTItemId string `json:"raffleTicketNFTItemId" yaml:"raffleTicketNFTItemId" mapstructure:"raffleTicketNFTItemId"`

	// RaffleTicketTotal corresponds to the JSON schema field "raffleTicketTotal".
	RaffleTicketTotal int `json:"raffleTicketTotal" yaml:"raffleTicketTotal" mapstructure:"raffleTicketTotal"`

	// Talent corresponds to the JSON schema field "talent".
	Talent int `json:"talent" yaml:"talent" mapstructure:"talent"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DungeonExtraDropPool) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["created"]; raw != nil && !ok {
		return fmt.Errorf("field created in DungeonExtraDropPool: required")
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in DungeonExtraDropPool: required")
	}
	if _, ok := raw["levelRangeIdx"]; raw != nil && !ok {
		return fmt.Errorf("field levelRangeIdx in DungeonExtraDropPool: required")
	}
	if _, ok := raw["raffleTicketNFTId"]; raw != nil && !ok {
		return fmt.Errorf("field raffleTicketNFTId in DungeonExtraDropPool: required")
	}
	if _, ok := raw["raffleTicketNFTItemId"]; raw != nil && !ok {
		return fmt.Errorf("field raffleTicketNFTItemId in DungeonExtraDropPool: required")
	}
	if _, ok := raw["raffleTicketTotal"]; raw != nil && !ok {
		return fmt.Errorf("field raffleTicketTotal in DungeonExtraDropPool: required")
	}
	if _, ok := raw["talent"]; raw != nil && !ok {
		return fmt.Errorf("field talent in DungeonExtraDropPool: required")
	}
	type Plain DungeonExtraDropPool
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = DungeonExtraDropPool(plain)
	return nil
}

type DungeonInvestData struct {
	// CurInvest corresponds to the JSON schema field "curInvest".
	CurInvest string `json:"curInvest" yaml:"curInvest" mapstructure:"curInvest"`

	// DungeonId corresponds to the JSON schema field "dungeonId".
	DungeonId int `json:"dungeonId" yaml:"dungeonId" mapstructure:"dungeonId"`

	// MaxChallenageBonus corresponds to the JSON schema field "maxChallenageBonus".
	MaxChallenageBonus string `json:"maxChallenageBonus" yaml:"maxChallenageBonus" mapstructure:"maxChallenageBonus"`

	// TotalBaseLP corresponds to the JSON schema field "totalBaseLP".
	TotalBaseLP string `json:"totalBaseLP" yaml:"totalBaseLP" mapstructure:"totalBaseLP"`

	// TotalInvest corresponds to the JSON schema field "totalInvest".
	TotalInvest string `json:"totalInvest" yaml:"totalInvest" mapstructure:"totalInvest"`

	// TotalRewardLP corresponds to the JSON schema field "totalRewardLP".
	TotalRewardLP string `json:"totalRewardLP" yaml:"totalRewardLP" mapstructure:"totalRewardLP"`

	// TotemAAmount corresponds to the JSON schema field "totemAAmount".
	TotemAAmount int `json:"totemAAmount" yaml:"totemAAmount" mapstructure:"totemAAmount"`

	// TotemARadio corresponds to the JSON schema field "totemARadio".
	TotemARadio int `json:"totemARadio" yaml:"totemARadio" mapstructure:"totemARadio"`

	// TotemARewardBoostPrecent corresponds to the JSON schema field
	// "totemARewardBoostPrecent".
	TotemARewardBoostPrecent int `json:"totemARewardBoostPrecent" yaml:"totemARewardBoostPrecent" mapstructure:"totemARewardBoostPrecent"`

	// TotemBAmount corresponds to the JSON schema field "totemBAmount".
	TotemBAmount int `json:"totemBAmount" yaml:"totemBAmount" mapstructure:"totemBAmount"`

	// TotemBRadio corresponds to the JSON schema field "totemBRadio".
	TotemBRadio int `json:"totemBRadio" yaml:"totemBRadio" mapstructure:"totemBRadio"`

	// TotemBRewardBoostPrecent corresponds to the JSON schema field
	// "totemBRewardBoostPrecent".
	TotemBRewardBoostPrecent int `json:"totemBRewardBoostPrecent" yaml:"totemBRewardBoostPrecent" mapstructure:"totemBRewardBoostPrecent"`

	// TotemCAmount corresponds to the JSON schema field "totemCAmount".
	TotemCAmount int `json:"totemCAmount" yaml:"totemCAmount" mapstructure:"totemCAmount"`

	// TotemCRadio corresponds to the JSON schema field "totemCRadio".
	TotemCRadio int `json:"totemCRadio" yaml:"totemCRadio" mapstructure:"totemCRadio"`

	// TotemCRewardBoostPrecent corresponds to the JSON schema field
	// "totemCRewardBoostPrecent".
	TotemCRewardBoostPrecent int `json:"totemCRewardBoostPrecent" yaml:"totemCRewardBoostPrecent" mapstructure:"totemCRewardBoostPrecent"`

	// TotemDAmount corresponds to the JSON schema field "totemDAmount".
	TotemDAmount int `json:"totemDAmount" yaml:"totemDAmount" mapstructure:"totemDAmount"`

	// TotemDRadio corresponds to the JSON schema field "totemDRadio".
	TotemDRadio int `json:"totemDRadio" yaml:"totemDRadio" mapstructure:"totemDRadio"`

	// TotemDRewardBoostPrecent corresponds to the JSON schema field
	// "totemDRewardBoostPrecent".
	TotemDRewardBoostPrecent int `json:"totemDRewardBoostPrecent" yaml:"totemDRewardBoostPrecent" mapstructure:"totemDRewardBoostPrecent"`

	// TotemEAmount corresponds to the JSON schema field "totemEAmount".
	TotemEAmount int `json:"totemEAmount" yaml:"totemEAmount" mapstructure:"totemEAmount"`

	// TotemERadio corresponds to the JSON schema field "totemERadio".
	TotemERadio int `json:"totemERadio" yaml:"totemERadio" mapstructure:"totemERadio"`

	// TotemERewardBoostPrecent corresponds to the JSON schema field
	// "totemERewardBoostPrecent".
	TotemERewardBoostPrecent int `json:"totemERewardBoostPrecent" yaml:"totemERewardBoostPrecent" mapstructure:"totemERewardBoostPrecent"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DungeonInvestData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["curInvest"]; raw != nil && !ok {
		return fmt.Errorf("field curInvest in DungeonInvestData: required")
	}
	if _, ok := raw["dungeonId"]; raw != nil && !ok {
		return fmt.Errorf("field dungeonId in DungeonInvestData: required")
	}
	if _, ok := raw["maxChallenageBonus"]; raw != nil && !ok {
		return fmt.Errorf("field maxChallenageBonus in DungeonInvestData: required")
	}
	if _, ok := raw["totalBaseLP"]; raw != nil && !ok {
		return fmt.Errorf("field totalBaseLP in DungeonInvestData: required")
	}
	if _, ok := raw["totalInvest"]; raw != nil && !ok {
		return fmt.Errorf("field totalInvest in DungeonInvestData: required")
	}
	if _, ok := raw["totalRewardLP"]; raw != nil && !ok {
		return fmt.Errorf("field totalRewardLP in DungeonInvestData: required")
	}
	if _, ok := raw["totemAAmount"]; raw != nil && !ok {
		return fmt.Errorf("field totemAAmount in DungeonInvestData: required")
	}
	if _, ok := raw["totemARadio"]; raw != nil && !ok {
		return fmt.Errorf("field totemARadio in DungeonInvestData: required")
	}
	if _, ok := raw["totemARewardBoostPrecent"]; raw != nil && !ok {
		return fmt.Errorf("field totemARewardBoostPrecent in DungeonInvestData: required")
	}
	if _, ok := raw["totemBAmount"]; raw != nil && !ok {
		return fmt.Errorf("field totemBAmount in DungeonInvestData: required")
	}
	if _, ok := raw["totemBRadio"]; raw != nil && !ok {
		return fmt.Errorf("field totemBRadio in DungeonInvestData: required")
	}
	if _, ok := raw["totemBRewardBoostPrecent"]; raw != nil && !ok {
		return fmt.Errorf("field totemBRewardBoostPrecent in DungeonInvestData: required")
	}
	if _, ok := raw["totemCAmount"]; raw != nil && !ok {
		return fmt.Errorf("field totemCAmount in DungeonInvestData: required")
	}
	if _, ok := raw["totemCRadio"]; raw != nil && !ok {
		return fmt.Errorf("field totemCRadio in DungeonInvestData: required")
	}
	if _, ok := raw["totemCRewardBoostPrecent"]; raw != nil && !ok {
		return fmt.Errorf("field totemCRewardBoostPrecent in DungeonInvestData: required")
	}
	if _, ok := raw["totemDAmount"]; raw != nil && !ok {
		return fmt.Errorf("field totemDAmount in DungeonInvestData: required")
	}
	if _, ok := raw["totemDRadio"]; raw != nil && !ok {
		return fmt.Errorf("field totemDRadio in DungeonInvestData: required")
	}
	if _, ok := raw["totemDRewardBoostPrecent"]; raw != nil && !ok {
		return fmt.Errorf("field totemDRewardBoostPrecent in DungeonInvestData: required")
	}
	if _, ok := raw["totemEAmount"]; raw != nil && !ok {
		return fmt.Errorf("field totemEAmount in DungeonInvestData: required")
	}
	if _, ok := raw["totemERadio"]; raw != nil && !ok {
		return fmt.Errorf("field totemERadio in DungeonInvestData: required")
	}
	if _, ok := raw["totemERewardBoostPrecent"]; raw != nil && !ok {
		return fmt.Errorf("field totemERewardBoostPrecent in DungeonInvestData: required")
	}
	type Plain DungeonInvestData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = DungeonInvestData(plain)
	return nil
}

type DungeonPVEPStart struct {
	// AppId corresponds to the JSON schema field "appId".
	AppId string `json:"appId" yaml:"appId" mapstructure:"appId"`

	// DungeonId corresponds to the JSON schema field "dungeonId".
	DungeonId int `json:"dungeonId" yaml:"dungeonId" mapstructure:"dungeonId"`

	// UserIds corresponds to the JSON schema field "userIds".
	UserIds []string `json:"userIds" yaml:"userIds" mapstructure:"userIds"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DungeonPVEPStart) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["appId"]; raw != nil && !ok {
		return fmt.Errorf("field appId in DungeonPVEPStart: required")
	}
	if _, ok := raw["dungeonId"]; raw != nil && !ok {
		return fmt.Errorf("field dungeonId in DungeonPVEPStart: required")
	}
	if _, ok := raw["userIds"]; raw != nil && !ok {
		return fmt.Errorf("field userIds in DungeonPVEPStart: required")
	}
	type Plain DungeonPVEPStart
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = DungeonPVEPStart(plain)
	return nil
}

type DungeonStartPVEPCallback struct {
	// AppId corresponds to the JSON schema field "appId".
	AppId string `json:"appId" yaml:"appId" mapstructure:"appId"`

	// ChallengeBonus corresponds to the JSON schema field "challengeBonus".
	ChallengeBonus string `json:"challengeBonus" yaml:"challengeBonus" mapstructure:"challengeBonus"`

	// DungeonId corresponds to the JSON schema field "dungeonId".
	DungeonId int `json:"dungeonId" yaml:"dungeonId" mapstructure:"dungeonId"`

	// FailedUserIds corresponds to the JSON schema field "failedUserIds".
	FailedUserIds []string `json:"failedUserIds" yaml:"failedUserIds" mapstructure:"failedUserIds"`

	// InvestBonus corresponds to the JSON schema field "investBonus".
	InvestBonus string `json:"investBonus" yaml:"investBonus" mapstructure:"investBonus"`

	// Success corresponds to the JSON schema field "success".
	Success bool `json:"success" yaml:"success" mapstructure:"success"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DungeonStartPVEPCallback) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["appId"]; raw != nil && !ok {
		return fmt.Errorf("field appId in DungeonStartPVEPCallback: required")
	}
	if _, ok := raw["challengeBonus"]; raw != nil && !ok {
		return fmt.Errorf("field challengeBonus in DungeonStartPVEPCallback: required")
	}
	if _, ok := raw["dungeonId"]; raw != nil && !ok {
		return fmt.Errorf("field dungeonId in DungeonStartPVEPCallback: required")
	}
	if _, ok := raw["failedUserIds"]; raw != nil && !ok {
		return fmt.Errorf("field failedUserIds in DungeonStartPVEPCallback: required")
	}
	if _, ok := raw["investBonus"]; raw != nil && !ok {
		return fmt.Errorf("field investBonus in DungeonStartPVEPCallback: required")
	}
	if _, ok := raw["success"]; raw != nil && !ok {
		return fmt.Errorf("field success in DungeonStartPVEPCallback: required")
	}
	type Plain DungeonStartPVEPCallback
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = DungeonStartPVEPCallback(plain)
	return nil
}

type EnhanceEquipmentDeductionStatus string

const EnhanceEquipmentDeductionStatusFailed EnhanceEquipmentDeductionStatus = "failed"
const EnhanceEquipmentDeductionStatusPending EnhanceEquipmentDeductionStatus = "pending"
const EnhanceEquipmentDeductionStatusSuccess EnhanceEquipmentDeductionStatus = "success"

var enumValues_EnhanceEquipmentDeductionStatus = []interface{}{
	"failed",
	"pending",
	"success",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EnhanceEquipmentDeductionStatus) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_EnhanceEquipmentDeductionStatus {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_EnhanceEquipmentDeductionStatus, v)
	}
	*j = EnhanceEquipmentDeductionStatus(v)
	return nil
}

type EnhanceEquipmentEvent struct {
	// Data corresponds to the JSON schema field "data".
	Data EnhanceEquipmentLog `json:"data" yaml:"data" mapstructure:"data"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EnhanceEquipmentEvent) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["data"]; raw != nil && !ok {
		return fmt.Errorf("field data in EnhanceEquipmentEvent: required")
	}
	type Plain EnhanceEquipmentEvent
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = EnhanceEquipmentEvent(plain)
	return nil
}

type EnhanceEquipmentInput struct {
	// AvatarNftId corresponds to the JSON schema field "avatarNftId".
	AvatarNftId string `json:"avatarNftId" yaml:"avatarNftId" mapstructure:"avatarNftId"`

	// FromAvatarNftId corresponds to the JSON schema field "fromAvatarNftId".
	FromAvatarNftId string `json:"fromAvatarNftId" yaml:"fromAvatarNftId" mapstructure:"fromAvatarNftId"`

	// SceneAppId corresponds to the JSON schema field "sceneAppId".
	SceneAppId string `json:"sceneAppId" yaml:"sceneAppId" mapstructure:"sceneAppId"`

	// TotemNftId corresponds to the JSON schema field "totemNftId".
	TotemNftId string `json:"totemNftId" yaml:"totemNftId" mapstructure:"totemNftId"`

	// TotemOwner corresponds to the JSON schema field "totemOwner".
	TotemOwner string `json:"totemOwner" yaml:"totemOwner" mapstructure:"totemOwner"`

	// UseProtectiveStone corresponds to the JSON schema field "useProtectiveStone".
	UseProtectiveStone bool `json:"useProtectiveStone" yaml:"useProtectiveStone" mapstructure:"useProtectiveStone"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EnhanceEquipmentInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["avatarNftId"]; raw != nil && !ok {
		return fmt.Errorf("field avatarNftId in EnhanceEquipmentInput: required")
	}
	if _, ok := raw["fromAvatarNftId"]; raw != nil && !ok {
		return fmt.Errorf("field fromAvatarNftId in EnhanceEquipmentInput: required")
	}
	if _, ok := raw["sceneAppId"]; raw != nil && !ok {
		return fmt.Errorf("field sceneAppId in EnhanceEquipmentInput: required")
	}
	if _, ok := raw["totemNftId"]; raw != nil && !ok {
		return fmt.Errorf("field totemNftId in EnhanceEquipmentInput: required")
	}
	if _, ok := raw["totemOwner"]; raw != nil && !ok {
		return fmt.Errorf("field totemOwner in EnhanceEquipmentInput: required")
	}
	if _, ok := raw["useProtectiveStone"]; raw != nil && !ok {
		return fmt.Errorf("field useProtectiveStone in EnhanceEquipmentInput: required")
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in EnhanceEquipmentInput: required")
	}
	type Plain EnhanceEquipmentInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = EnhanceEquipmentInput(plain)
	return nil
}

type EnhanceEquipmentLog struct {
	// AttributeList corresponds to the JSON schema field "AttributeList".
	AttributeList []AttributeChangeData `json:"AttributeList" yaml:"AttributeList" mapstructure:"AttributeList"`

	// ActionId corresponds to the JSON schema field "actionId".
	ActionId string `json:"actionId" yaml:"actionId" mapstructure:"actionId"`

	// BeginTime corresponds to the JSON schema field "beginTime".
	BeginTime int `json:"beginTime" yaml:"beginTime" mapstructure:"beginTime"`

	// EnhanceEquipmentItemId corresponds to the JSON schema field
	// "enhanceEquipmentItemId".
	EnhanceEquipmentItemId int `json:"enhanceEquipmentItemId" yaml:"enhanceEquipmentItemId" mapstructure:"enhanceEquipmentItemId"`

	// EnhanceEquipmentNFTId corresponds to the JSON schema field
	// "enhanceEquipmentNFTId".
	EnhanceEquipmentNFTId string `json:"enhanceEquipmentNFTId" yaml:"enhanceEquipmentNFTId" mapstructure:"enhanceEquipmentNFTId"`

	// EnhanceEquipmentQuality corresponds to the JSON schema field
	// "enhanceEquipmentQuality".
	EnhanceEquipmentQuality string `json:"enhanceEquipmentQuality" yaml:"enhanceEquipmentQuality" mapstructure:"enhanceEquipmentQuality"`

	// EnhanceLevel corresponds to the JSON schema field "enhanceLevel".
	EnhanceLevel int `json:"enhanceLevel" yaml:"enhanceLevel" mapstructure:"enhanceLevel"`

	// FinishTime corresponds to the JSON schema field "finishTime".
	FinishTime int `json:"finishTime" yaml:"finishTime" mapstructure:"finishTime"`

	// FromAvatarItemId corresponds to the JSON schema field "fromAvatarItemId".
	FromAvatarItemId int `json:"fromAvatarItemId" yaml:"fromAvatarItemId" mapstructure:"fromAvatarItemId"`

	// FromAvatarNftId corresponds to the JSON schema field "fromAvatarNftId".
	FromAvatarNftId string `json:"fromAvatarNftId" yaml:"fromAvatarNftId" mapstructure:"fromAvatarNftId"`

	// OriginLevel corresponds to the JSON schema field "originLevel".
	OriginLevel int `json:"originLevel" yaml:"originLevel" mapstructure:"originLevel"`

	// Price corresponds to the JSON schema field "price".
	Price string `json:"price" yaml:"price" mapstructure:"price"`

	// Raffle corresponds to the JSON schema field "raffle".
	Raffle EnhanceEquipmentRaffle `json:"raffle" yaml:"raffle" mapstructure:"raffle"`

	// RaffleTxHash corresponds to the JSON schema field "raffleTxHash".
	RaffleTxHash string `json:"raffleTxHash" yaml:"raffleTxHash" mapstructure:"raffleTxHash"`

	// Status corresponds to the JSON schema field "status".
	Status string `json:"status" yaml:"status" mapstructure:"status"`

	// Totem corresponds to the JSON schema field "totem".
	Totem WorldTotemData `json:"totem" yaml:"totem" mapstructure:"totem"`

	// UseProtectiveStone corresponds to the JSON schema field "useProtectiveStone".
	UseProtectiveStone bool `json:"useProtectiveStone" yaml:"useProtectiveStone" mapstructure:"useProtectiveStone"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`

	// UserName corresponds to the JSON schema field "userName".
	UserName string `json:"userName" yaml:"userName" mapstructure:"userName"`
}

type EnhanceEquipmentLogInput struct {
	// FilterExtract corresponds to the JSON schema field "filterExtract".
	FilterExtract bool `json:"filterExtract" yaml:"filterExtract" mapstructure:"filterExtract"`

	// Index corresponds to the JSON schema field "index".
	Index int `json:"index" yaml:"index" mapstructure:"index"`

	// Num corresponds to the JSON schema field "num".
	Num int `json:"num" yaml:"num" mapstructure:"num"`

	// TotemNftId corresponds to the JSON schema field "totemNftId".
	TotemNftId string `json:"totemNftId" yaml:"totemNftId" mapstructure:"totemNftId"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EnhanceEquipmentLogInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["filterExtract"]; raw != nil && !ok {
		return fmt.Errorf("field filterExtract in EnhanceEquipmentLogInput: required")
	}
	if _, ok := raw["index"]; raw != nil && !ok {
		return fmt.Errorf("field index in EnhanceEquipmentLogInput: required")
	}
	if _, ok := raw["num"]; raw != nil && !ok {
		return fmt.Errorf("field num in EnhanceEquipmentLogInput: required")
	}
	if _, ok := raw["totemNftId"]; raw != nil && !ok {
		return fmt.Errorf("field totemNftId in EnhanceEquipmentLogInput: required")
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in EnhanceEquipmentLogInput: required")
	}
	type Plain EnhanceEquipmentLogInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = EnhanceEquipmentLogInput(plain)
	return nil
}

type EnhanceEquipmentLogOutput struct {
	// Logs corresponds to the JSON schema field "logs".
	Logs []EnhanceEquipmentLog `json:"logs" yaml:"logs" mapstructure:"logs"`

	// LogsCount corresponds to the JSON schema field "logsCount".
	LogsCount int `json:"logsCount" yaml:"logsCount" mapstructure:"logsCount"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EnhanceEquipmentLogOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["logs"]; raw != nil && !ok {
		return fmt.Errorf("field logs in EnhanceEquipmentLogOutput: required")
	}
	if _, ok := raw["logsCount"]; raw != nil && !ok {
		return fmt.Errorf("field logsCount in EnhanceEquipmentLogOutput: required")
	}
	type Plain EnhanceEquipmentLogOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = EnhanceEquipmentLogOutput(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EnhanceEquipmentLog) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["AttributeList"]; raw != nil && !ok {
		return fmt.Errorf("field AttributeList in EnhanceEquipmentLog: required")
	}
	if _, ok := raw["actionId"]; raw != nil && !ok {
		return fmt.Errorf("field actionId in EnhanceEquipmentLog: required")
	}
	if _, ok := raw["beginTime"]; raw != nil && !ok {
		return fmt.Errorf("field beginTime in EnhanceEquipmentLog: required")
	}
	if _, ok := raw["enhanceEquipmentItemId"]; raw != nil && !ok {
		return fmt.Errorf("field enhanceEquipmentItemId in EnhanceEquipmentLog: required")
	}
	if _, ok := raw["enhanceEquipmentNFTId"]; raw != nil && !ok {
		return fmt.Errorf("field enhanceEquipmentNFTId in EnhanceEquipmentLog: required")
	}
	if _, ok := raw["enhanceEquipmentQuality"]; raw != nil && !ok {
		return fmt.Errorf("field enhanceEquipmentQuality in EnhanceEquipmentLog: required")
	}
	if _, ok := raw["enhanceLevel"]; raw != nil && !ok {
		return fmt.Errorf("field enhanceLevel in EnhanceEquipmentLog: required")
	}
	if _, ok := raw["finishTime"]; raw != nil && !ok {
		return fmt.Errorf("field finishTime in EnhanceEquipmentLog: required")
	}
	if _, ok := raw["fromAvatarItemId"]; raw != nil && !ok {
		return fmt.Errorf("field fromAvatarItemId in EnhanceEquipmentLog: required")
	}
	if _, ok := raw["fromAvatarNftId"]; raw != nil && !ok {
		return fmt.Errorf("field fromAvatarNftId in EnhanceEquipmentLog: required")
	}
	if _, ok := raw["originLevel"]; raw != nil && !ok {
		return fmt.Errorf("field originLevel in EnhanceEquipmentLog: required")
	}
	if _, ok := raw["price"]; raw != nil && !ok {
		return fmt.Errorf("field price in EnhanceEquipmentLog: required")
	}
	if _, ok := raw["raffle"]; raw != nil && !ok {
		return fmt.Errorf("field raffle in EnhanceEquipmentLog: required")
	}
	if _, ok := raw["raffleTxHash"]; raw != nil && !ok {
		return fmt.Errorf("field raffleTxHash in EnhanceEquipmentLog: required")
	}
	if _, ok := raw["status"]; raw != nil && !ok {
		return fmt.Errorf("field status in EnhanceEquipmentLog: required")
	}
	if _, ok := raw["totem"]; raw != nil && !ok {
		return fmt.Errorf("field totem in EnhanceEquipmentLog: required")
	}
	if _, ok := raw["useProtectiveStone"]; raw != nil && !ok {
		return fmt.Errorf("field useProtectiveStone in EnhanceEquipmentLog: required")
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in EnhanceEquipmentLog: required")
	}
	if _, ok := raw["userName"]; raw != nil && !ok {
		return fmt.Errorf("field userName in EnhanceEquipmentLog: required")
	}
	type Plain EnhanceEquipmentLog
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = EnhanceEquipmentLog(plain)
	return nil
}

type EnhanceEquipmentOutput struct {
	// AttributeList corresponds to the JSON schema field "attributeList".
	AttributeList []AttributeChangeData `json:"attributeList" yaml:"attributeList" mapstructure:"attributeList"`

	// EnhanceLevel corresponds to the JSON schema field "enhanceLevel".
	EnhanceLevel int `json:"enhanceLevel" yaml:"enhanceLevel" mapstructure:"enhanceLevel"`

	// FailedReason corresponds to the JSON schema field "failedReason".
	FailedReason string `json:"failedReason" yaml:"failedReason" mapstructure:"failedReason"`

	// OriginLevel corresponds to the JSON schema field "originLevel".
	OriginLevel int `json:"originLevel" yaml:"originLevel" mapstructure:"originLevel"`

	// Success corresponds to the JSON schema field "success".
	Success bool `json:"success" yaml:"success" mapstructure:"success"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EnhanceEquipmentOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["attributeList"]; raw != nil && !ok {
		return fmt.Errorf("field attributeList in EnhanceEquipmentOutput: required")
	}
	if _, ok := raw["enhanceLevel"]; raw != nil && !ok {
		return fmt.Errorf("field enhanceLevel in EnhanceEquipmentOutput: required")
	}
	if _, ok := raw["failedReason"]; raw != nil && !ok {
		return fmt.Errorf("field failedReason in EnhanceEquipmentOutput: required")
	}
	if _, ok := raw["originLevel"]; raw != nil && !ok {
		return fmt.Errorf("field originLevel in EnhanceEquipmentOutput: required")
	}
	if _, ok := raw["success"]; raw != nil && !ok {
		return fmt.Errorf("field success in EnhanceEquipmentOutput: required")
	}
	type Plain EnhanceEquipmentOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = EnhanceEquipmentOutput(plain)
	return nil
}

type EnhanceEquipmentRaffle struct {
	// AwardAmount corresponds to the JSON schema field "awardAmount".
	AwardAmount string `json:"awardAmount" yaml:"awardAmount" mapstructure:"awardAmount"`

	// ContributeAmount corresponds to the JSON schema field "contributeAmount".
	ContributeAmount string `json:"contributeAmount" yaml:"contributeAmount" mapstructure:"contributeAmount"`

	// IsAward corresponds to the JSON schema field "isAward".
	IsAward bool `json:"isAward" yaml:"isAward" mapstructure:"isAward"`

	// PoolAmount corresponds to the JSON schema field "poolAmount".
	PoolAmount string `json:"poolAmount" yaml:"poolAmount" mapstructure:"poolAmount"`

	// Probability corresponds to the JSON schema field "probability".
	Probability int `json:"probability" yaml:"probability" mapstructure:"probability"`

	// Status corresponds to the JSON schema field "status".
	Status EnhanceEquipmentRaffleStatus `json:"status" yaml:"status" mapstructure:"status"`

	// TotemOwnerExpense corresponds to the JSON schema field "totemOwnerExpense".
	TotemOwnerExpense string `json:"totemOwnerExpense" yaml:"totemOwnerExpense" mapstructure:"totemOwnerExpense"`
}

type EnhanceEquipmentRaffleStatus string

const EnhanceEquipmentRaffleStatusPending EnhanceEquipmentRaffleStatus = "pending"
const EnhanceEquipmentRaffleStatusSuccess EnhanceEquipmentRaffleStatus = "success"

var enumValues_EnhanceEquipmentRaffleStatus = []interface{}{
	"pending",
	"success",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EnhanceEquipmentRaffleStatus) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_EnhanceEquipmentRaffleStatus {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_EnhanceEquipmentRaffleStatus, v)
	}
	*j = EnhanceEquipmentRaffleStatus(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EnhanceEquipmentRaffle) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["awardAmount"]; raw != nil && !ok {
		return fmt.Errorf("field awardAmount in EnhanceEquipmentRaffle: required")
	}
	if _, ok := raw["contributeAmount"]; raw != nil && !ok {
		return fmt.Errorf("field contributeAmount in EnhanceEquipmentRaffle: required")
	}
	if _, ok := raw["isAward"]; raw != nil && !ok {
		return fmt.Errorf("field isAward in EnhanceEquipmentRaffle: required")
	}
	if _, ok := raw["poolAmount"]; raw != nil && !ok {
		return fmt.Errorf("field poolAmount in EnhanceEquipmentRaffle: required")
	}
	if _, ok := raw["probability"]; raw != nil && !ok {
		return fmt.Errorf("field probability in EnhanceEquipmentRaffle: required")
	}
	if _, ok := raw["status"]; raw != nil && !ok {
		return fmt.Errorf("field status in EnhanceEquipmentRaffle: required")
	}
	if _, ok := raw["totemOwnerExpense"]; raw != nil && !ok {
		return fmt.Errorf("field totemOwnerExpense in EnhanceEquipmentRaffle: required")
	}
	type Plain EnhanceEquipmentRaffle
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = EnhanceEquipmentRaffle(plain)
	return nil
}

type EnhanceEquipmentStatus string

const EnhanceEquipmentStatusExtracted EnhanceEquipmentStatus = "extracted"
const EnhanceEquipmentStatusFailed EnhanceEquipmentStatus = "failed"
const EnhanceEquipmentStatusPending EnhanceEquipmentStatus = "pending"
const EnhanceEquipmentStatusSuccess EnhanceEquipmentStatus = "success"

var enumValues_EnhanceEquipmentStatus = []interface{}{
	"extracted",
	"failed",
	"pending",
	"success",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EnhanceEquipmentStatus) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_EnhanceEquipmentStatus {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_EnhanceEquipmentStatus, v)
	}
	*j = EnhanceEquipmentStatus(v)
	return nil
}

type EnhanceEquipmentTotemRaffleLogType string

const EnhanceEquipmentTotemRaffleLogTypeClosed EnhanceEquipmentTotemRaffleLogType = "closed"
const EnhanceEquipmentTotemRaffleLogTypeContribute EnhanceEquipmentTotemRaffleLogType = "contribute"
const EnhanceEquipmentTotemRaffleLogTypeCreate EnhanceEquipmentTotemRaffleLogType = "create"
const EnhanceEquipmentTotemRaffleLogTypeDeposit EnhanceEquipmentTotemRaffleLogType = "deposit"
const EnhanceEquipmentTotemRaffleLogTypePrize EnhanceEquipmentTotemRaffleLogType = "prize"
const EnhanceEquipmentTotemRaffleLogTypeWithdraw EnhanceEquipmentTotemRaffleLogType = "withdraw"

var enumValues_EnhanceEquipmentTotemRaffleLogType = []interface{}{
	"closed",
	"contribute",
	"create",
	"deposit",
	"prize",
	"withdraw",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EnhanceEquipmentTotemRaffleLogType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_EnhanceEquipmentTotemRaffleLogType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_EnhanceEquipmentTotemRaffleLogType, v)
	}
	*j = EnhanceEquipmentTotemRaffleLogType(v)
	return nil
}

type EnhanceEquipmentTotemRaffleStatus string

const EnhanceEquipmentTotemRaffleStatusClose EnhanceEquipmentTotemRaffleStatus = "close"
const EnhanceEquipmentTotemRaffleStatusOpen EnhanceEquipmentTotemRaffleStatus = "open"
const EnhanceEquipmentTotemRaffleStatusPending EnhanceEquipmentTotemRaffleStatus = "pending"

var enumValues_EnhanceEquipmentTotemRaffleStatus = []interface{}{
	"close",
	"open",
	"pending",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EnhanceEquipmentTotemRaffleStatus) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_EnhanceEquipmentTotemRaffleStatus {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_EnhanceEquipmentTotemRaffleStatus, v)
	}
	*j = EnhanceEquipmentTotemRaffleStatus(v)
	return nil
}

type EstimateDivestDungeonInput struct {
	// DungeonId corresponds to the JSON schema field "dungeonId".
	DungeonId int `json:"dungeonId" yaml:"dungeonId" mapstructure:"dungeonId"`

	// RemoveBaseLP corresponds to the JSON schema field "removeBaseLP".
	RemoveBaseLP string `json:"removeBaseLP" yaml:"removeBaseLP" mapstructure:"removeBaseLP"`

	// TotemNFTId corresponds to the JSON schema field "totemNFTId".
	TotemNFTId string `json:"totemNFTId" yaml:"totemNFTId" mapstructure:"totemNFTId"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EstimateDivestDungeonInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["dungeonId"]; raw != nil && !ok {
		return fmt.Errorf("field dungeonId in EstimateDivestDungeonInput: required")
	}
	if _, ok := raw["removeBaseLP"]; raw != nil && !ok {
		return fmt.Errorf("field removeBaseLP in EstimateDivestDungeonInput: required")
	}
	if _, ok := raw["totemNFTId"]; raw != nil && !ok {
		return fmt.Errorf("field totemNFTId in EstimateDivestDungeonInput: required")
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in EstimateDivestDungeonInput: required")
	}
	type Plain EstimateDivestDungeonInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = EstimateDivestDungeonInput(plain)
	return nil
}

type EstimateDivestDungeonOutput struct {
	// NewBaseLP corresponds to the JSON schema field "newBaseLP".
	NewBaseLP string `json:"newBaseLP" yaml:"newBaseLP" mapstructure:"newBaseLP"`

	// NewBaseLPRadio corresponds to the JSON schema field "newBaseLPRadio".
	NewBaseLPRadio int `json:"newBaseLPRadio" yaml:"newBaseLPRadio" mapstructure:"newBaseLPRadio"`

	// NewRewardLP corresponds to the JSON schema field "newRewardLP".
	NewRewardLP string `json:"newRewardLP" yaml:"newRewardLP" mapstructure:"newRewardLP"`

	// NewRewardLPRadio corresponds to the JSON schema field "newRewardLPRadio".
	NewRewardLPRadio int `json:"newRewardLPRadio" yaml:"newRewardLPRadio" mapstructure:"newRewardLPRadio"`

	// OutAmount corresponds to the JSON schema field "outAmount".
	OutAmount string `json:"outAmount" yaml:"outAmount" mapstructure:"outAmount"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EstimateDivestDungeonOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["newBaseLP"]; raw != nil && !ok {
		return fmt.Errorf("field newBaseLP in EstimateDivestDungeonOutput: required")
	}
	if _, ok := raw["newBaseLPRadio"]; raw != nil && !ok {
		return fmt.Errorf("field newBaseLPRadio in EstimateDivestDungeonOutput: required")
	}
	if _, ok := raw["newRewardLP"]; raw != nil && !ok {
		return fmt.Errorf("field newRewardLP in EstimateDivestDungeonOutput: required")
	}
	if _, ok := raw["newRewardLPRadio"]; raw != nil && !ok {
		return fmt.Errorf("field newRewardLPRadio in EstimateDivestDungeonOutput: required")
	}
	if _, ok := raw["outAmount"]; raw != nil && !ok {
		return fmt.Errorf("field outAmount in EstimateDivestDungeonOutput: required")
	}
	type Plain EstimateDivestDungeonOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = EstimateDivestDungeonOutput(plain)
	return nil
}

type EstimateInvestDungeonInput struct {
	// Amount corresponds to the JSON schema field "amount".
	Amount string `json:"amount" yaml:"amount" mapstructure:"amount"`

	// DungeonId corresponds to the JSON schema field "dungeonId".
	DungeonId int `json:"dungeonId" yaml:"dungeonId" mapstructure:"dungeonId"`

	// TotemNFTId corresponds to the JSON schema field "totemNFTId".
	TotemNFTId string `json:"totemNFTId" yaml:"totemNFTId" mapstructure:"totemNFTId"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EstimateInvestDungeonInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["amount"]; raw != nil && !ok {
		return fmt.Errorf("field amount in EstimateInvestDungeonInput: required")
	}
	if _, ok := raw["dungeonId"]; raw != nil && !ok {
		return fmt.Errorf("field dungeonId in EstimateInvestDungeonInput: required")
	}
	if _, ok := raw["totemNFTId"]; raw != nil && !ok {
		return fmt.Errorf("field totemNFTId in EstimateInvestDungeonInput: required")
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in EstimateInvestDungeonInput: required")
	}
	type Plain EstimateInvestDungeonInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = EstimateInvestDungeonInput(plain)
	return nil
}

type EstimateInvestDungeonOutput struct {
	// NewBaseLP corresponds to the JSON schema field "newBaseLP".
	NewBaseLP string `json:"newBaseLP" yaml:"newBaseLP" mapstructure:"newBaseLP"`

	// NewBaseLPRadio corresponds to the JSON schema field "newBaseLPRadio".
	NewBaseLPRadio int `json:"newBaseLPRadio" yaml:"newBaseLPRadio" mapstructure:"newBaseLPRadio"`

	// NewRewardLP corresponds to the JSON schema field "newRewardLP".
	NewRewardLP string `json:"newRewardLP" yaml:"newRewardLP" mapstructure:"newRewardLP"`

	// NewRewardLPRadio corresponds to the JSON schema field "newRewardLPRadio".
	NewRewardLPRadio int `json:"newRewardLPRadio" yaml:"newRewardLPRadio" mapstructure:"newRewardLPRadio"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EstimateInvestDungeonOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["newBaseLP"]; raw != nil && !ok {
		return fmt.Errorf("field newBaseLP in EstimateInvestDungeonOutput: required")
	}
	if _, ok := raw["newBaseLPRadio"]; raw != nil && !ok {
		return fmt.Errorf("field newBaseLPRadio in EstimateInvestDungeonOutput: required")
	}
	if _, ok := raw["newRewardLP"]; raw != nil && !ok {
		return fmt.Errorf("field newRewardLP in EstimateInvestDungeonOutput: required")
	}
	if _, ok := raw["newRewardLPRadio"]; raw != nil && !ok {
		return fmt.Errorf("field newRewardLPRadio in EstimateInvestDungeonOutput: required")
	}
	type Plain EstimateInvestDungeonOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = EstimateInvestDungeonOutput(plain)
	return nil
}

type ExecGameMessageInput struct {
	// Data corresponds to the JSON schema field "data".
	Data string `json:"data" yaml:"data" mapstructure:"data"`

	// EventId corresponds to the JSON schema field "eventId".
	EventId string `json:"eventId" yaml:"eventId" mapstructure:"eventId"`

	// GasFee corresponds to the JSON schema field "gasFee".
	GasFee string `json:"gasFee" yaml:"gasFee" mapstructure:"gasFee"`

	// Remark corresponds to the JSON schema field "remark".
	Remark string `json:"remark" yaml:"remark" mapstructure:"remark"`

	// Target corresponds to the JSON schema field "target".
	Target string `json:"target" yaml:"target" mapstructure:"target"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ExecGameMessageInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["data"]; raw != nil && !ok {
		return fmt.Errorf("field data in ExecGameMessageInput: required")
	}
	if _, ok := raw["eventId"]; raw != nil && !ok {
		return fmt.Errorf("field eventId in ExecGameMessageInput: required")
	}
	if _, ok := raw["gasFee"]; raw != nil && !ok {
		return fmt.Errorf("field gasFee in ExecGameMessageInput: required")
	}
	if _, ok := raw["remark"]; raw != nil && !ok {
		return fmt.Errorf("field remark in ExecGameMessageInput: required")
	}
	if _, ok := raw["target"]; raw != nil && !ok {
		return fmt.Errorf("field target in ExecGameMessageInput: required")
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in ExecGameMessageInput: required")
	}
	type Plain ExecGameMessageInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ExecGameMessageInput(plain)
	return nil
}

type ExecGameMessageOutput struct {
	// MessageId corresponds to the JSON schema field "messageId".
	MessageId string `json:"messageId" yaml:"messageId" mapstructure:"messageId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ExecGameMessageOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["messageId"]; raw != nil && !ok {
		return fmt.Errorf("field messageId in ExecGameMessageOutput: required")
	}
	type Plain ExecGameMessageOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ExecGameMessageOutput(plain)
	return nil
}

type ExtractEquipmentInput struct {
	// ActionId corresponds to the JSON schema field "actionId".
	ActionId string `json:"actionId" yaml:"actionId" mapstructure:"actionId"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ExtractEquipmentInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["actionId"]; raw != nil && !ok {
		return fmt.Errorf("field actionId in ExtractEquipmentInput: required")
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in ExtractEquipmentInput: required")
	}
	type Plain ExtractEquipmentInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ExtractEquipmentInput(plain)
	return nil
}

type ExtractEquipmentOutput struct {
	// ActionId corresponds to the JSON schema field "actionId".
	ActionId string `json:"actionId" yaml:"actionId" mapstructure:"actionId"`

	// FailedReason corresponds to the JSON schema field "failedReason".
	FailedReason string `json:"failedReason" yaml:"failedReason" mapstructure:"failedReason"`

	// Success corresponds to the JSON schema field "success".
	Success bool `json:"success" yaml:"success" mapstructure:"success"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ExtractEquipmentOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["actionId"]; raw != nil && !ok {
		return fmt.Errorf("field actionId in ExtractEquipmentOutput: required")
	}
	if _, ok := raw["failedReason"]; raw != nil && !ok {
		return fmt.Errorf("field failedReason in ExtractEquipmentOutput: required")
	}
	if _, ok := raw["success"]; raw != nil && !ok {
		return fmt.Errorf("field success in ExtractEquipmentOutput: required")
	}
	type Plain ExtractEquipmentOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ExtractEquipmentOutput(plain)
	return nil
}

type FetchDungeonExtraDropPoolsInput struct {
	// Timestamp corresponds to the JSON schema field "timestamp".
	Timestamp int `json:"timestamp" yaml:"timestamp" mapstructure:"timestamp"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *FetchDungeonExtraDropPoolsInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["timestamp"]; raw != nil && !ok {
		return fmt.Errorf("field timestamp in FetchDungeonExtraDropPoolsInput: required")
	}
	type Plain FetchDungeonExtraDropPoolsInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = FetchDungeonExtraDropPoolsInput(plain)
	return nil
}

type FetchDungeonExtraDropPoolsOutput struct {
	// Pools corresponds to the JSON schema field "pools".
	Pools []DungeonExtraDropPool `json:"pools" yaml:"pools" mapstructure:"pools"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *FetchDungeonExtraDropPoolsOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["pools"]; raw != nil && !ok {
		return fmt.Errorf("field pools in FetchDungeonExtraDropPoolsOutput: required")
	}
	type Plain FetchDungeonExtraDropPoolsOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = FetchDungeonExtraDropPoolsOutput(plain)
	return nil
}

type FetchTaskPoolsInput struct {
	// Timestamp corresponds to the JSON schema field "timestamp".
	Timestamp int `json:"timestamp" yaml:"timestamp" mapstructure:"timestamp"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *FetchTaskPoolsInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["timestamp"]; raw != nil && !ok {
		return fmt.Errorf("field timestamp in FetchTaskPoolsInput: required")
	}
	type Plain FetchTaskPoolsInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = FetchTaskPoolsInput(plain)
	return nil
}

type FetchTaskPoolsOutput struct {
	// TaskPools corresponds to the JSON schema field "taskPools".
	TaskPools []TaskPool `json:"taskPools" yaml:"taskPools" mapstructure:"taskPools"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *FetchTaskPoolsOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["taskPools"]; raw != nil && !ok {
		return fmt.Errorf("field taskPools in FetchTaskPoolsOutput: required")
	}
	type Plain FetchTaskPoolsOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = FetchTaskPoolsOutput(plain)
	return nil
}

type FetchTaskUseNFTSupplyListInput map[string]interface{}

type FetchTaskUseNFTSupplyListOutput struct {
	// NftSupplyList corresponds to the JSON schema field "nftSupplyList".
	NftSupplyList []NFTSupply `json:"nftSupplyList" yaml:"nftSupplyList" mapstructure:"nftSupplyList"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *FetchTaskUseNFTSupplyListOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["nftSupplyList"]; raw != nil && !ok {
		return fmt.Errorf("field nftSupplyList in FetchTaskUseNFTSupplyListOutput: required")
	}
	type Plain FetchTaskUseNFTSupplyListOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = FetchTaskUseNFTSupplyListOutput(plain)
	return nil
}

type FindRaffleRrawLogsInput struct {
	// BeginIdx corresponds to the JSON schema field "beginIdx".
	BeginIdx int `json:"beginIdx" yaml:"beginIdx" mapstructure:"beginIdx"`

	// Num corresponds to the JSON schema field "num".
	Num int `json:"num" yaml:"num" mapstructure:"num"`

	// UserId corresponds to the JSON schema field "userId".
	UserId *string `json:"userId,omitempty" yaml:"userId,omitempty" mapstructure:"userId,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *FindRaffleRrawLogsInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["beginIdx"]; raw != nil && !ok {
		return fmt.Errorf("field beginIdx in FindRaffleRrawLogsInput: required")
	}
	if _, ok := raw["num"]; raw != nil && !ok {
		return fmt.Errorf("field num in FindRaffleRrawLogsInput: required")
	}
	type Plain FindRaffleRrawLogsInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = FindRaffleRrawLogsInput(plain)
	return nil
}

type FindRaffleRrawLogsOutput struct {
	// Logs corresponds to the JSON schema field "logs".
	Logs []RaffleDrawLog `json:"logs" yaml:"logs" mapstructure:"logs"`

	// LogsCount corresponds to the JSON schema field "logsCount".
	LogsCount int `json:"logsCount" yaml:"logsCount" mapstructure:"logsCount"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *FindRaffleRrawLogsOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["logs"]; raw != nil && !ok {
		return fmt.Errorf("field logs in FindRaffleRrawLogsOutput: required")
	}
	if _, ok := raw["logsCount"]; raw != nil && !ok {
		return fmt.Errorf("field logsCount in FindRaffleRrawLogsOutput: required")
	}
	type Plain FindRaffleRrawLogsOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = FindRaffleRrawLogsOutput(plain)
	return nil
}

type FinishQuestion struct {
	// DiffcultyChange corresponds to the JSON schema field "diffcultyChange".
	DiffcultyChange float64 `json:"diffcultyChange" yaml:"diffcultyChange" mapstructure:"diffcultyChange"`

	// 消息版本号
	Etag int `json:"etag" yaml:"etag" mapstructure:"etag"`

	// Level corresponds to the JSON schema field "level".
	Level string `json:"level" yaml:"level" mapstructure:"level"`

	// QuestionId corresponds to the JSON schema field "questionId".
	QuestionId string `json:"questionId" yaml:"questionId" mapstructure:"questionId"`

	// Result corresponds to the JSON schema field "result".
	Result string `json:"result" yaml:"result" mapstructure:"result"`

	// Type corresponds to the JSON schema field "type".
	Type string `json:"type" yaml:"type" mapstructure:"type"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *FinishQuestion) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["diffcultyChange"]; raw != nil && !ok {
		return fmt.Errorf("field diffcultyChange in FinishQuestion: required")
	}
	if _, ok := raw["etag"]; raw != nil && !ok {
		return fmt.Errorf("field etag in FinishQuestion: required")
	}
	if _, ok := raw["level"]; raw != nil && !ok {
		return fmt.Errorf("field level in FinishQuestion: required")
	}
	if _, ok := raw["questionId"]; raw != nil && !ok {
		return fmt.Errorf("field questionId in FinishQuestion: required")
	}
	if _, ok := raw["result"]; raw != nil && !ok {
		return fmt.Errorf("field result in FinishQuestion: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in FinishQuestion: required")
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in FinishQuestion: required")
	}
	type Plain FinishQuestion
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = FinishQuestion(plain)
	return nil
}

type GameDataServiceAction string

const GameDataServiceActionCheckUserRecipe GameDataServiceAction = "CheckUserRecipe"
const GameDataServiceActionDeductUserExp GameDataServiceAction = "DeductUserExp"
const GameDataServiceActionGetPlayerItemSlots GameDataServiceAction = "GetPlayerItemSlots"
const GameDataServiceActionGetPlayerUsingNftsByUserId GameDataServiceAction = "GetPlayerUsingNftsByUserId"
const GameDataServiceActionGetUserRecipes GameDataServiceAction = "GetUserRecipes"
const GameDataServiceActionGetWorldTotemData GameDataServiceAction = "GetWorldTotemData"
const GameDataServiceActionLandUsingSkill GameDataServiceAction = "LandUsingSkill"
const GameDataServiceActionMultiGetPlayerInfoByUserId GameDataServiceAction = "MultiGetPlayerInfoByUserId"
const GameDataServiceActionMultiGetPlayerUsingNftsByUserId GameDataServiceAction = "MultiGetPlayerUsingNftsByUserId"
const GameDataServiceActionUpgradePlayerItemSlots GameDataServiceAction = "UpgradePlayerItemSlots"

var enumValues_GameDataServiceAction = []interface{}{
	"CheckUserRecipe",
	"DeductUserExp",
	"GetPlayerItemSlots",
	"GetPlayerUsingNftsByUserId",
	"GetUserRecipes",
	"GetWorldTotemData",
	"LandUsingSkill",
	"MultiGetPlayerInfoByUserId",
	"MultiGetPlayerUsingNftsByUserId",
	"UpgradePlayerItemSlots",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GameDataServiceAction) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_GameDataServiceAction {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_GameDataServiceAction, v)
	}
	*j = GameDataServiceAction(v)
	return nil
}

type GameMessageResult struct {
	// Executed corresponds to the JSON schema field "executed".
	Executed bool `json:"executed" yaml:"executed" mapstructure:"executed"`

	// MessageId corresponds to the JSON schema field "messageId".
	MessageId string `json:"messageId" yaml:"messageId" mapstructure:"messageId"`

	// Reason corresponds to the JSON schema field "reason".
	Reason string `json:"reason" yaml:"reason" mapstructure:"reason"`

	// Success corresponds to the JSON schema field "success".
	Success bool `json:"success" yaml:"success" mapstructure:"success"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GameMessageResult) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["executed"]; raw != nil && !ok {
		return fmt.Errorf("field executed in GameMessageResult: required")
	}
	if _, ok := raw["messageId"]; raw != nil && !ok {
		return fmt.Errorf("field messageId in GameMessageResult: required")
	}
	if _, ok := raw["reason"]; raw != nil && !ok {
		return fmt.Errorf("field reason in GameMessageResult: required")
	}
	if _, ok := raw["success"]; raw != nil && !ok {
		return fmt.Errorf("field success in GameMessageResult: required")
	}
	type Plain GameMessageResult
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GameMessageResult(plain)
	return nil
}

type GameServiceRankAction string

const GameServiceRankActionGetUserReputationScore GameServiceRankAction = "GetUserReputationScore"

var enumValues_GameServiceRankAction = []interface{}{
	"GetUserReputationScore",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GameServiceRankAction) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_GameServiceRankAction {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_GameServiceRankAction, v)
	}
	*j = GameServiceRankAction(v)
	return nil
}

type GetAllBuildDataInput struct {
	// 地图id 为多地图准备
	MapId int `json:"mapId" yaml:"mapId" mapstructure:"mapId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetAllBuildDataInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["mapId"]; raw != nil && !ok {
		return fmt.Errorf("field mapId in GetAllBuildDataInput: required")
	}
	type Plain GetAllBuildDataInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetAllBuildDataInput(plain)
	return nil
}

type GetAllBuildDataOutput struct {
	// 全量建造物数据
	AllBuild []BuildData `json:"allBuild,omitempty" yaml:"allBuild,omitempty" mapstructure:"allBuild,omitempty"`

	// 失败, 则返回失败原因, 否则返回空字符串
	FailedReason string `json:"failedReason" yaml:"failedReason" mapstructure:"failedReason"`

	// 是否成功
	Success bool `json:"success" yaml:"success" mapstructure:"success"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetAllBuildDataOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["failedReason"]; raw != nil && !ok {
		return fmt.Errorf("field failedReason in GetAllBuildDataOutput: required")
	}
	if _, ok := raw["success"]; raw != nil && !ok {
		return fmt.Errorf("field success in GetAllBuildDataOutput: required")
	}
	type Plain GetAllBuildDataOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetAllBuildDataOutput(plain)
	return nil
}

type GetAllDungeonInvestDataInput map[string]interface{}

type GetAllDungeonInvestDataOutput struct {
	// InvestDatas corresponds to the JSON schema field "investDatas".
	InvestDatas []DungeonInvestData `json:"investDatas" yaml:"investDatas" mapstructure:"investDatas"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetAllDungeonInvestDataOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["investDatas"]; raw != nil && !ok {
		return fmt.Errorf("field investDatas in GetAllDungeonInvestDataOutput: required")
	}
	type Plain GetAllDungeonInvestDataOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetAllDungeonInvestDataOutput(plain)
	return nil
}

type GetAllLandDataInput struct {
	// 地图id 为多地图准备
	MapId int `json:"mapId" yaml:"mapId" mapstructure:"mapId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetAllLandDataInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["mapId"]; raw != nil && !ok {
		return fmt.Errorf("field mapId in GetAllLandDataInput: required")
	}
	type Plain GetAllLandDataInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetAllLandDataInput(plain)
	return nil
}

type GetAllLandDataOutput struct {
	// 全量地格数据
	AllLandData []LandData `json:"allLandData,omitempty" yaml:"allLandData,omitempty" mapstructure:"allLandData,omitempty"`

	// 失败, 则返回失败原因, 否则返回空字符串
	FailedReason string `json:"failedReason" yaml:"failedReason" mapstructure:"failedReason"`

	// 是否成功
	Success bool `json:"success" yaml:"success" mapstructure:"success"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetAllLandDataOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["failedReason"]; raw != nil && !ok {
		return fmt.Errorf("field failedReason in GetAllLandDataOutput: required")
	}
	if _, ok := raw["success"]; raw != nil && !ok {
		return fmt.Errorf("field success in GetAllLandDataOutput: required")
	}
	type Plain GetAllLandDataOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetAllLandDataOutput(plain)
	return nil
}

type GetCurrentPkSessionIdInput struct {
	// Player corresponds to the JSON schema field "player".
	Player PVPPlayer `json:"player" yaml:"player" mapstructure:"player"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetCurrentPkSessionIdInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["player"]; raw != nil && !ok {
		return fmt.Errorf("field player in GetCurrentPkSessionIdInput: required")
	}
	type Plain GetCurrentPkSessionIdInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetCurrentPkSessionIdInput(plain)
	return nil
}

type GetCurrentPkSessionIdOutput struct {
	// PkSessionId corresponds to the JSON schema field "pkSessionId".
	PkSessionId string `json:"pkSessionId" yaml:"pkSessionId" mapstructure:"pkSessionId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetCurrentPkSessionIdOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["pkSessionId"]; raw != nil && !ok {
		return fmt.Errorf("field pkSessionId in GetCurrentPkSessionIdOutput: required")
	}
	type Plain GetCurrentPkSessionIdOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetCurrentPkSessionIdOutput(plain)
	return nil
}

type GetGameMessageStatusByIdInput struct {
	// MessageId corresponds to the JSON schema field "messageId".
	MessageId string `json:"messageId" yaml:"messageId" mapstructure:"messageId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetGameMessageStatusByIdInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["messageId"]; raw != nil && !ok {
		return fmt.Errorf("field messageId in GetGameMessageStatusByIdInput: required")
	}
	type Plain GetGameMessageStatusByIdInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetGameMessageStatusByIdInput(plain)
	return nil
}

type GetGameMessageStatusByIdOutput struct {
	// Executed corresponds to the JSON schema field "executed".
	Executed bool `json:"executed" yaml:"executed" mapstructure:"executed"`

	// Reason corresponds to the JSON schema field "reason".
	Reason string `json:"reason" yaml:"reason" mapstructure:"reason"`

	// Success corresponds to the JSON schema field "success".
	Success bool `json:"success" yaml:"success" mapstructure:"success"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetGameMessageStatusByIdOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["executed"]; raw != nil && !ok {
		return fmt.Errorf("field executed in GetGameMessageStatusByIdOutput: required")
	}
	if _, ok := raw["reason"]; raw != nil && !ok {
		return fmt.Errorf("field reason in GetGameMessageStatusByIdOutput: required")
	}
	if _, ok := raw["success"]; raw != nil && !ok {
		return fmt.Errorf("field success in GetGameMessageStatusByIdOutput: required")
	}
	type Plain GetGameMessageStatusByIdOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetGameMessageStatusByIdOutput(plain)
	return nil
}

type GetGameTokenPriceInput map[string]interface{}

type GetGameTokenPriceOutput struct {
	// ExpireTime corresponds to the JSON schema field "expireTime".
	ExpireTime int `json:"expireTime" yaml:"expireTime" mapstructure:"expireTime"`

	// Price corresponds to the JSON schema field "price".
	Price string `json:"price" yaml:"price" mapstructure:"price"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetGameTokenPriceOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["expireTime"]; raw != nil && !ok {
		return fmt.Errorf("field expireTime in GetGameTokenPriceOutput: required")
	}
	if _, ok := raw["price"]; raw != nil && !ok {
		return fmt.Errorf("field price in GetGameTokenPriceOutput: required")
	}
	type Plain GetGameTokenPriceOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetGameTokenPriceOutput(plain)
	return nil
}

type GetInvestHavestLogsInput struct {
	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetInvestHavestLogsInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in GetInvestHavestLogsInput: required")
	}
	type Plain GetInvestHavestLogsInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetInvestHavestLogsInput(plain)
	return nil
}

type GetInvestHavestLogsOutput struct {
	// Logs corresponds to the JSON schema field "logs".
	Logs []InvestHavestLog `json:"logs" yaml:"logs" mapstructure:"logs"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetInvestHavestLogsOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["logs"]; raw != nil && !ok {
		return fmt.Errorf("field logs in GetInvestHavestLogsOutput: required")
	}
	type Plain GetInvestHavestLogsOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetInvestHavestLogsOutput(plain)
	return nil
}

type GetPlayerItemSlotsInput struct {
	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetPlayerItemSlotsInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in GetPlayerItemSlotsInput: required")
	}
	type Plain GetPlayerItemSlotsInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetPlayerItemSlotsInput(plain)
	return nil
}

type GetPlayerItemSlotsOutput struct {
	// ItemSlots corresponds to the JSON schema field "itemSlots".
	ItemSlots []PlayerItemSlot `json:"itemSlots" yaml:"itemSlots" mapstructure:"itemSlots"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetPlayerItemSlotsOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["itemSlots"]; raw != nil && !ok {
		return fmt.Errorf("field itemSlots in GetPlayerItemSlotsOutput: required")
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in GetPlayerItemSlotsOutput: required")
	}
	type Plain GetPlayerItemSlotsOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetPlayerItemSlotsOutput(plain)
	return nil
}

type GetPlayerPvpProfileInput struct {
	// PlayerId corresponds to the JSON schema field "playerId".
	PlayerId string `json:"playerId" yaml:"playerId" mapstructure:"playerId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetPlayerPvpProfileInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["playerId"]; raw != nil && !ok {
		return fmt.Errorf("field playerId in GetPlayerPvpProfileInput: required")
	}
	type Plain GetPlayerPvpProfileInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetPlayerPvpProfileInput(plain)
	return nil
}

type GetPlayerPvpProfileOutput struct {
	// Profile corresponds to the JSON schema field "profile".
	Profile PvpPlayerProfile `json:"profile" yaml:"profile" mapstructure:"profile"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetPlayerPvpProfileOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["profile"]; raw != nil && !ok {
		return fmt.Errorf("field profile in GetPlayerPvpProfileOutput: required")
	}
	type Plain GetPlayerPvpProfileOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetPlayerPvpProfileOutput(plain)
	return nil
}

type GetPlayerPvpRankInput struct {
	// PlayerId corresponds to the JSON schema field "playerId".
	PlayerId string `json:"playerId" yaml:"playerId" mapstructure:"playerId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetPlayerPvpRankInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["playerId"]; raw != nil && !ok {
		return fmt.Errorf("field playerId in GetPlayerPvpRankInput: required")
	}
	type Plain GetPlayerPvpRankInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetPlayerPvpRankInput(plain)
	return nil
}

type GetPlayerPvpRankOutput struct {
	// RankList corresponds to the JSON schema field "rankList".
	RankList []PvpPlayerRank `json:"rankList" yaml:"rankList" mapstructure:"rankList"`

	// SelfRank corresponds to the JSON schema field "selfRank".
	SelfRank PvpPlayerRank `json:"selfRank" yaml:"selfRank" mapstructure:"selfRank"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetPlayerPvpRankOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["rankList"]; raw != nil && !ok {
		return fmt.Errorf("field rankList in GetPlayerPvpRankOutput: required")
	}
	if _, ok := raw["selfRank"]; raw != nil && !ok {
		return fmt.Errorf("field selfRank in GetPlayerPvpRankOutput: required")
	}
	type Plain GetPlayerPvpRankOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetPlayerPvpRankOutput(plain)
	return nil
}

type GetPlayerUsingNftsByUserIdInput struct {
	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetPlayerUsingNftsByUserIdInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in GetPlayerUsingNftsByUserIdInput: required")
	}
	type Plain GetPlayerUsingNftsByUserIdInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetPlayerUsingNftsByUserIdInput(plain)
	return nil
}

type GetPlayerUsingNftsByUserIdOutput struct {
	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`

	// UsingNfts corresponds to the JSON schema field "usingNfts".
	UsingNfts []UsingNFT `json:"usingNfts" yaml:"usingNfts" mapstructure:"usingNfts"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetPlayerUsingNftsByUserIdOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in GetPlayerUsingNftsByUserIdOutput: required")
	}
	if _, ok := raw["usingNfts"]; raw != nil && !ok {
		return fmt.Errorf("field usingNfts in GetPlayerUsingNftsByUserIdOutput: required")
	}
	type Plain GetPlayerUsingNftsByUserIdOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetPlayerUsingNftsByUserIdOutput(plain)
	return nil
}

type GetPvpHistoryInput struct {
	// PlayerId corresponds to the JSON schema field "playerId".
	PlayerId string `json:"playerId" yaml:"playerId" mapstructure:"playerId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetPvpHistoryInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["playerId"]; raw != nil && !ok {
		return fmt.Errorf("field playerId in GetPvpHistoryInput: required")
	}
	type Plain GetPvpHistoryInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetPvpHistoryInput(plain)
	return nil
}

type GetPvpHistoryOutput struct {
	// HistoryList corresponds to the JSON schema field "historyList".
	HistoryList []PvpHistory `json:"historyList" yaml:"historyList" mapstructure:"historyList"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetPvpHistoryOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["historyList"]; raw != nil && !ok {
		return fmt.Errorf("field historyList in GetPvpHistoryOutput: required")
	}
	type Plain GetPvpHistoryOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetPvpHistoryOutput(plain)
	return nil
}

type GetQuestionResourcesByTypesInput struct {
	// Types corresponds to the JSON schema field "types".
	Types []string `json:"types" yaml:"types" mapstructure:"types"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetQuestionResourcesByTypesInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["types"]; raw != nil && !ok {
		return fmt.Errorf("field types in GetQuestionResourcesByTypesInput: required")
	}
	type Plain GetQuestionResourcesByTypesInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetQuestionResourcesByTypesInput(plain)
	return nil
}

type GetQuestionResourcesByTypesOutput struct {
	// Prefetchs corresponds to the JSON schema field "prefetchs".
	Prefetchs []Prefetch `json:"prefetchs" yaml:"prefetchs" mapstructure:"prefetchs"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetQuestionResourcesByTypesOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["prefetchs"]; raw != nil && !ok {
		return fmt.Errorf("field prefetchs in GetQuestionResourcesByTypesOutput: required")
	}
	type Plain GetQuestionResourcesByTypesOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetQuestionResourcesByTypesOutput(plain)
	return nil
}

type GetQuestionsByTypesRandomInput struct {
	// Limit corresponds to the JSON schema field "limit".
	Limit int `json:"limit" yaml:"limit" mapstructure:"limit"`

	// Types corresponds to the JSON schema field "types".
	Types []string `json:"types" yaml:"types" mapstructure:"types"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetQuestionsByTypesRandomInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["limit"]; raw != nil && !ok {
		return fmt.Errorf("field limit in GetQuestionsByTypesRandomInput: required")
	}
	if _, ok := raw["types"]; raw != nil && !ok {
		return fmt.Errorf("field types in GetQuestionsByTypesRandomInput: required")
	}
	type Plain GetQuestionsByTypesRandomInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetQuestionsByTypesRandomInput(plain)
	return nil
}

type GetQuestionsByTypesRandomOutput struct {
	// Questions corresponds to the JSON schema field "questions".
	Questions []Question `json:"questions" yaml:"questions" mapstructure:"questions"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetQuestionsByTypesRandomOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["questions"]; raw != nil && !ok {
		return fmt.Errorf("field questions in GetQuestionsByTypesRandomOutput: required")
	}
	type Plain GetQuestionsByTypesRandomOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetQuestionsByTypesRandomOutput(plain)
	return nil
}

type GetRoninNFTMoveLogsInput struct {
	// BeginIdx corresponds to the JSON schema field "beginIdx".
	BeginIdx int `json:"beginIdx" yaml:"beginIdx" mapstructure:"beginIdx"`

	// Num corresponds to the JSON schema field "num".
	Num int `json:"num" yaml:"num" mapstructure:"num"`

	// Status corresponds to the JSON schema field "status".
	Status int `json:"status" yaml:"status" mapstructure:"status"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetRoninNFTMoveLogsInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["beginIdx"]; raw != nil && !ok {
		return fmt.Errorf("field beginIdx in GetRoninNFTMoveLogsInput: required")
	}
	if _, ok := raw["num"]; raw != nil && !ok {
		return fmt.Errorf("field num in GetRoninNFTMoveLogsInput: required")
	}
	if _, ok := raw["status"]; raw != nil && !ok {
		return fmt.Errorf("field status in GetRoninNFTMoveLogsInput: required")
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in GetRoninNFTMoveLogsInput: required")
	}
	type Plain GetRoninNFTMoveLogsInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetRoninNFTMoveLogsInput(plain)
	return nil
}

type GetRoninNFTMoveLogsOutput struct {
	// Logs corresponds to the JSON schema field "logs".
	Logs []NFTMoveLog `json:"logs" yaml:"logs" mapstructure:"logs"`

	// LogsCount corresponds to the JSON schema field "logsCount".
	LogsCount int `json:"logsCount" yaml:"logsCount" mapstructure:"logsCount"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetRoninNFTMoveLogsOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["logs"]; raw != nil && !ok {
		return fmt.Errorf("field logs in GetRoninNFTMoveLogsOutput: required")
	}
	if _, ok := raw["logsCount"]; raw != nil && !ok {
		return fmt.Errorf("field logsCount in GetRoninNFTMoveLogsOutput: required")
	}
	type Plain GetRoninNFTMoveLogsOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetRoninNFTMoveLogsOutput(plain)
	return nil
}

type GetTowerRafflePoolsInput struct {
	// Timestamp corresponds to the JSON schema field "timestamp".
	Timestamp int `json:"timestamp" yaml:"timestamp" mapstructure:"timestamp"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetTowerRafflePoolsInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["timestamp"]; raw != nil && !ok {
		return fmt.Errorf("field timestamp in GetTowerRafflePoolsInput: required")
	}
	type Plain GetTowerRafflePoolsInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetTowerRafflePoolsInput(plain)
	return nil
}

type GetTowerRafflePoolsOutput struct {
	// Pools corresponds to the JSON schema field "pools".
	Pools []TowerRafflePoolData `json:"pools" yaml:"pools" mapstructure:"pools"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetTowerRafflePoolsOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["pools"]; raw != nil && !ok {
		return fmt.Errorf("field pools in GetTowerRafflePoolsOutput: required")
	}
	type Plain GetTowerRafflePoolsOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetTowerRafflePoolsOutput(plain)
	return nil
}

type GetUserAllTotemInvestDataInput struct {
	// DungeonId corresponds to the JSON schema field "dungeonId".
	DungeonId *float64 `json:"dungeonId,omitempty" yaml:"dungeonId,omitempty" mapstructure:"dungeonId,omitempty"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserAllTotemInvestDataInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in GetUserAllTotemInvestDataInput: required")
	}
	type Plain GetUserAllTotemInvestDataInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserAllTotemInvestDataInput(plain)
	return nil
}

type GetUserAllTotemInvestDataOutput struct {
	// InvestDatas corresponds to the JSON schema field "investDatas".
	InvestDatas []TotemInvestData `json:"investDatas" yaml:"investDatas" mapstructure:"investDatas"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserAllTotemInvestDataOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["investDatas"]; raw != nil && !ok {
		return fmt.Errorf("field investDatas in GetUserAllTotemInvestDataOutput: required")
	}
	type Plain GetUserAllTotemInvestDataOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserAllTotemInvestDataOutput(plain)
	return nil
}

type GetUserExternalNFTsInput struct {
	// FilterByAssetAddress corresponds to the JSON schema field
	// "filterByAssetAddress".
	FilterByAssetAddress *string `json:"filterByAssetAddress,omitempty" yaml:"filterByAssetAddress,omitempty" mapstructure:"filterByAssetAddress,omitempty"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserExternalNFTsInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in GetUserExternalNFTsInput: required")
	}
	type Plain GetUserExternalNFTsInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserExternalNFTsInput(plain)
	return nil
}

type GetUserExternalNFTsOutput struct {
	// 消息版本号
	Etag int `json:"etag" yaml:"etag" mapstructure:"etag"`

	// user all nfts
	Nfts []NFT `json:"nfts" yaml:"nfts" mapstructure:"nfts"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserExternalNFTsOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["etag"]; raw != nil && !ok {
		return fmt.Errorf("field etag in GetUserExternalNFTsOutput: required")
	}
	if _, ok := raw["nfts"]; raw != nil && !ok {
		return fmt.Errorf("field nfts in GetUserExternalNFTsOutput: required")
	}
	type Plain GetUserExternalNFTsOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserExternalNFTsOutput(plain)
	return nil
}

type GetUserIdByAddressInput struct {
	// BlockchainAddress corresponds to the JSON schema field "blockchainAddress".
	BlockchainAddress string `json:"blockchainAddress" yaml:"blockchainAddress" mapstructure:"blockchainAddress"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserIdByAddressInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["blockchainAddress"]; raw != nil && !ok {
		return fmt.Errorf("field blockchainAddress in GetUserIdByAddressInput: required")
	}
	type Plain GetUserIdByAddressInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserIdByAddressInput(plain)
	return nil
}

type GetUserIdByAddressOutput struct {
	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserIdByAddressOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in GetUserIdByAddressOutput: required")
	}
	type Plain GetUserIdByAddressOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserIdByAddressOutput(plain)
	return nil
}

type GetUserMintOnChainCountInput struct {
	// Timestamp corresponds to the JSON schema field "timestamp".
	Timestamp int `json:"timestamp" yaml:"timestamp" mapstructure:"timestamp"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserMintOnChainCountInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["timestamp"]; raw != nil && !ok {
		return fmt.Errorf("field timestamp in GetUserMintOnChainCountInput: required")
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in GetUserMintOnChainCountInput: required")
	}
	type Plain GetUserMintOnChainCountInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserMintOnChainCountInput(plain)
	return nil
}

type GetUserMintOnChainCountOutput struct {
	// MintOnChainCount corresponds to the JSON schema field "mintOnChainCount".
	MintOnChainCount int `json:"mintOnChainCount" yaml:"mintOnChainCount" mapstructure:"mintOnChainCount"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserMintOnChainCountOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["mintOnChainCount"]; raw != nil && !ok {
		return fmt.Errorf("field mintOnChainCount in GetUserMintOnChainCountOutput: required")
	}
	type Plain GetUserMintOnChainCountOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserMintOnChainCountOutput(plain)
	return nil
}

type GetUserNFTsByUserIdAndAddressInput struct {
	// 用户钱包地址
	BlockchainAddress string `json:"blockchainAddress" yaml:"blockchainAddress" mapstructure:"blockchainAddress"`

	// 用户id
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserNFTsByUserIdAndAddressInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["blockchainAddress"]; raw != nil && !ok {
		return fmt.Errorf("field blockchainAddress in GetUserNFTsByUserIdAndAddressInput: required")
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in GetUserNFTsByUserIdAndAddressInput: required")
	}
	type Plain GetUserNFTsByUserIdAndAddressInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserNFTsByUserIdAndAddressInput(plain)
	return nil
}

type GetUserNFTsByUserIdAndAddressOutput struct {
	// Nfts corresponds to the JSON schema field "nfts".
	Nfts []NFT `json:"nfts" yaml:"nfts" mapstructure:"nfts"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserNFTsByUserIdAndAddressOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["nfts"]; raw != nil && !ok {
		return fmt.Errorf("field nfts in GetUserNFTsByUserIdAndAddressOutput: required")
	}
	type Plain GetUserNFTsByUserIdAndAddressOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserNFTsByUserIdAndAddressOutput(plain)
	return nil
}

type GetUserNFTsInput struct {
	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserNFTsInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in GetUserNFTsInput: required")
	}
	type Plain GetUserNFTsInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserNFTsInput(plain)
	return nil
}

type GetUserNFTsOutput struct {
	// 消息版本号
	Etag int `json:"etag" yaml:"etag" mapstructure:"etag"`

	// user all nfts
	Nfts []NFT `json:"nfts" yaml:"nfts" mapstructure:"nfts"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserNFTsOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["etag"]; raw != nil && !ok {
		return fmt.Errorf("field etag in GetUserNFTsOutput: required")
	}
	if _, ok := raw["nfts"]; raw != nil && !ok {
		return fmt.Errorf("field nfts in GetUserNFTsOutput: required")
	}
	type Plain GetUserNFTsOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserNFTsOutput(plain)
	return nil
}

type GetUserOffchainNFTsInput struct {
	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserOffchainNFTsInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in GetUserOffchainNFTsInput: required")
	}
	type Plain GetUserOffchainNFTsInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserOffchainNFTsInput(plain)
	return nil
}

type GetUserOffchainNFTsOutput struct {
	// 消息版本号
	Etag int `json:"etag" yaml:"etag" mapstructure:"etag"`

	// user all nfts
	Nfts []NFT `json:"nfts" yaml:"nfts" mapstructure:"nfts"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserOffchainNFTsOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["etag"]; raw != nil && !ok {
		return fmt.Errorf("field etag in GetUserOffchainNFTsOutput: required")
	}
	if _, ok := raw["nfts"]; raw != nil && !ok {
		return fmt.Errorf("field nfts in GetUserOffchainNFTsOutput: required")
	}
	type Plain GetUserOffchainNFTsOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserOffchainNFTsOutput(plain)
	return nil
}

type GetUserOnchainNFTsInput struct {
	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserOnchainNFTsInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in GetUserOnchainNFTsInput: required")
	}
	type Plain GetUserOnchainNFTsInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserOnchainNFTsInput(plain)
	return nil
}

type GetUserOnchainNFTsOutput struct {
	// 消息版本号
	Etag int `json:"etag" yaml:"etag" mapstructure:"etag"`

	// user all nfts
	Nfts []NFT `json:"nfts" yaml:"nfts" mapstructure:"nfts"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserOnchainNFTsOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["etag"]; raw != nil && !ok {
		return fmt.Errorf("field etag in GetUserOnchainNFTsOutput: required")
	}
	if _, ok := raw["nfts"]; raw != nil && !ok {
		return fmt.Errorf("field nfts in GetUserOnchainNFTsOutput: required")
	}
	type Plain GetUserOnchainNFTsOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserOnchainNFTsOutput(plain)
	return nil
}

type GetUserRecipesInput struct {
	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserRecipesInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in GetUserRecipesInput: required")
	}
	type Plain GetUserRecipesInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserRecipesInput(plain)
	return nil
}

type GetUserRecipesOutput struct {
	// RecipeIds corresponds to the JSON schema field "recipeIds".
	RecipeIds []string `json:"recipeIds" yaml:"recipeIds" mapstructure:"recipeIds"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserRecipesOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["recipeIds"]; raw != nil && !ok {
		return fmt.Errorf("field recipeIds in GetUserRecipesOutput: required")
	}
	type Plain GetUserRecipesOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserRecipesOutput(plain)
	return nil
}

type GetUserReputationScoreInput struct {
	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserReputationScoreInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in GetUserReputationScoreInput: required")
	}
	type Plain GetUserReputationScoreInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserReputationScoreInput(plain)
	return nil
}

type GetUserReputationScoreOutput struct {
	// ReputationScore corresponds to the JSON schema field "reputationScore".
	ReputationScore int `json:"reputationScore" yaml:"reputationScore" mapstructure:"reputationScore"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserReputationScoreOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["reputationScore"]; raw != nil && !ok {
		return fmt.Errorf("field reputationScore in GetUserReputationScoreOutput: required")
	}
	type Plain GetUserReputationScoreOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserReputationScoreOutput(plain)
	return nil
}

type GetUserRoninchainNFTsInput struct {
	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserRoninchainNFTsInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in GetUserRoninchainNFTsInput: required")
	}
	type Plain GetUserRoninchainNFTsInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserRoninchainNFTsInput(plain)
	return nil
}

type GetUserRoninchainNFTsOutput struct {
	// 消息版本号
	Etag int `json:"etag" yaml:"etag" mapstructure:"etag"`

	// user all nfts
	Nfts []NFT `json:"nfts" yaml:"nfts" mapstructure:"nfts"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserRoninchainNFTsOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["etag"]; raw != nil && !ok {
		return fmt.Errorf("field etag in GetUserRoninchainNFTsOutput: required")
	}
	if _, ok := raw["nfts"]; raw != nil && !ok {
		return fmt.Errorf("field nfts in GetUserRoninchainNFTsOutput: required")
	}
	type Plain GetUserRoninchainNFTsOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserRoninchainNFTsOutput(plain)
	return nil
}

type GetUserTrackInput struct {
	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserTrackInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in GetUserTrackInput: required")
	}
	type Plain GetUserTrackInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserTrackInput(plain)
	return nil
}

type GetUserTrackOutput struct {
	// DitaminAmount corresponds to the JSON schema field "ditamin_amount".
	DitaminAmount int `json:"ditamin_amount" yaml:"ditamin_amount" mapstructure:"ditamin_amount"`

	// OccupiedLandNum corresponds to the JSON schema field "occupied_land_num".
	OccupiedLandNum int `json:"occupied_land_num" yaml:"occupied_land_num" mapstructure:"occupied_land_num"`

	// StakeVipname corresponds to the JSON schema field "stake_vipname".
	StakeVipname string `json:"stake_vipname" yaml:"stake_vipname" mapstructure:"stake_vipname"`

	// TicketLandNum corresponds to the JSON schema field "ticket_land_num".
	TicketLandNum int `json:"ticket_land_num" yaml:"ticket_land_num" mapstructure:"ticket_land_num"`

	// VipLandNum corresponds to the JSON schema field "vip_land_num".
	VipLandNum int `json:"vip_land_num" yaml:"vip_land_num" mapstructure:"vip_land_num"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserTrackOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["ditamin_amount"]; raw != nil && !ok {
		return fmt.Errorf("field ditamin_amount in GetUserTrackOutput: required")
	}
	if _, ok := raw["occupied_land_num"]; raw != nil && !ok {
		return fmt.Errorf("field occupied_land_num in GetUserTrackOutput: required")
	}
	if _, ok := raw["stake_vipname"]; raw != nil && !ok {
		return fmt.Errorf("field stake_vipname in GetUserTrackOutput: required")
	}
	if _, ok := raw["ticket_land_num"]; raw != nil && !ok {
		return fmt.Errorf("field ticket_land_num in GetUserTrackOutput: required")
	}
	if _, ok := raw["vip_land_num"]; raw != nil && !ok {
		return fmt.Errorf("field vip_land_num in GetUserTrackOutput: required")
	}
	type Plain GetUserTrackOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserTrackOutput(plain)
	return nil
}

type GetUserWeb3ProfileInput struct {
	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserWeb3ProfileInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in GetUserWeb3ProfileInput: required")
	}
	type Plain GetUserWeb3ProfileInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserWeb3ProfileInput(plain)
	return nil
}

type GetUserWeb3ProfileOutput struct {
	// BlockchainAddress corresponds to the JSON schema field "blockchainAddress".
	BlockchainAddress string `json:"blockchainAddress" yaml:"blockchainAddress" mapstructure:"blockchainAddress"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetUserWeb3ProfileOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["blockchainAddress"]; raw != nil && !ok {
		return fmt.Errorf("field blockchainAddress in GetUserWeb3ProfileOutput: required")
	}
	type Plain GetUserWeb3ProfileOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetUserWeb3ProfileOutput(plain)
	return nil
}

type GetWorldTotemDataInput struct {
	// TotemNftId corresponds to the JSON schema field "totemNftId".
	TotemNftId string `json:"totemNftId" yaml:"totemNftId" mapstructure:"totemNftId"`

	// TotemOwner corresponds to the JSON schema field "totemOwner".
	TotemOwner string `json:"totemOwner" yaml:"totemOwner" mapstructure:"totemOwner"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetWorldTotemDataInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["totemNftId"]; raw != nil && !ok {
		return fmt.Errorf("field totemNftId in GetWorldTotemDataInput: required")
	}
	if _, ok := raw["totemOwner"]; raw != nil && !ok {
		return fmt.Errorf("field totemOwner in GetWorldTotemDataInput: required")
	}
	type Plain GetWorldTotemDataInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetWorldTotemDataInput(plain)
	return nil
}

type GetWorldTotemDataOutput struct {
	// Exist corresponds to the JSON schema field "exist".
	Exist bool `json:"exist" yaml:"exist" mapstructure:"exist"`

	// Totem corresponds to the JSON schema field "totem".
	Totem WorldTotemData `json:"totem" yaml:"totem" mapstructure:"totem"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetWorldTotemDataOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["exist"]; raw != nil && !ok {
		return fmt.Errorf("field exist in GetWorldTotemDataOutput: required")
	}
	if _, ok := raw["totem"]; raw != nil && !ok {
		return fmt.Errorf("field totem in GetWorldTotemDataOutput: required")
	}
	type Plain GetWorldTotemDataOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetWorldTotemDataOutput(plain)
	return nil
}

type GraphqlServiceAction string

const GraphqlServiceActionCanBuildNFT GraphqlServiceAction = "CanBuildNFT"
const GraphqlServiceActionCheckQuestionAnswer GraphqlServiceAction = "CheckQuestionAnswer"
const GraphqlServiceActionGetQuestionResourcesByTypes GraphqlServiceAction = "GetQuestionResourcesByTypes"
const GraphqlServiceActionGetQuestionsByTypesRandom GraphqlServiceAction = "GetQuestionsByTypesRandom"
const GraphqlServiceActionGetUserIdByAddress GraphqlServiceAction = "GetUserIdByAddress"
const GraphqlServiceActionGetUserNFTs GraphqlServiceAction = "GetUserNFTs"
const GraphqlServiceActionGetUserTrack GraphqlServiceAction = "GetUserTrack"
const GraphqlServiceActionGetUserWeb3Profile GraphqlServiceAction = "GetUserWeb3Profile"

var enumValues_GraphqlServiceAction = []interface{}{
	"CanBuildNFT",
	"CheckQuestionAnswer",
	"GetQuestionResourcesByTypes",
	"GetQuestionsByTypesRandom",
	"GetUserIdByAddress",
	"GetUserNFTs",
	"GetUserTrack",
	"GetUserWeb3Profile",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GraphqlServiceAction) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_GraphqlServiceAction {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_GraphqlServiceAction, v)
	}
	*j = GraphqlServiceAction(v)
	return nil
}

type HandleGameMessageCallback struct {
	// Executed corresponds to the JSON schema field "executed".
	Executed bool `json:"executed" yaml:"executed" mapstructure:"executed"`

	// MessageId corresponds to the JSON schema field "messageId".
	MessageId string `json:"messageId" yaml:"messageId" mapstructure:"messageId"`

	// Reason corresponds to the JSON schema field "reason".
	Reason string `json:"reason" yaml:"reason" mapstructure:"reason"`

	// Success corresponds to the JSON schema field "success".
	Success bool `json:"success" yaml:"success" mapstructure:"success"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *HandleGameMessageCallback) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["executed"]; raw != nil && !ok {
		return fmt.Errorf("field executed in HandleGameMessageCallback: required")
	}
	if _, ok := raw["messageId"]; raw != nil && !ok {
		return fmt.Errorf("field messageId in HandleGameMessageCallback: required")
	}
	if _, ok := raw["reason"]; raw != nil && !ok {
		return fmt.Errorf("field reason in HandleGameMessageCallback: required")
	}
	if _, ok := raw["success"]; raw != nil && !ok {
		return fmt.Errorf("field success in HandleGameMessageCallback: required")
	}
	type Plain HandleGameMessageCallback
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = HandleGameMessageCallback(plain)
	return nil
}

type HarvestInput struct {
	// 建造id
	BuildId int `json:"buildId" yaml:"buildId" mapstructure:"buildId"`

	// 地图id 为多地图准备
	MapId int `json:"mapId" yaml:"mapId" mapstructure:"mapId"`

	// 玩家id
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *HarvestInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["buildId"]; raw != nil && !ok {
		return fmt.Errorf("field buildId in HarvestInput: required")
	}
	if _, ok := raw["mapId"]; raw != nil && !ok {
		return fmt.Errorf("field mapId in HarvestInput: required")
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in HarvestInput: required")
	}
	type Plain HarvestInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = HarvestInput(plain)
	return nil
}

type HarvestOutput struct {
	// 失败, 则返回失败原因, 否则返回空字符串
	FailedReason string `json:"failedReason" yaml:"failedReason" mapstructure:"failedReason"`

	// 是否成功
	Success bool `json:"success" yaml:"success" mapstructure:"success"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *HarvestOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["failedReason"]; raw != nil && !ok {
		return fmt.Errorf("field failedReason in HarvestOutput: required")
	}
	if _, ok := raw["success"]; raw != nil && !ok {
		return fmt.Errorf("field success in HarvestOutput: required")
	}
	type Plain HarvestOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = HarvestOutput(plain)
	return nil
}

type HavestDungeonInvestRewardInput struct {
	// Amount corresponds to the JSON schema field "amount".
	Amount string `json:"amount" yaml:"amount" mapstructure:"amount"`

	// HavestType corresponds to the JSON schema field "havestType".
	HavestType int `json:"havestType" yaml:"havestType" mapstructure:"havestType"`

	// OwnerUserId corresponds to the JSON schema field "ownerUserId".
	OwnerUserId string `json:"ownerUserId" yaml:"ownerUserId" mapstructure:"ownerUserId"`

	// ToUserId corresponds to the JSON schema field "toUserId".
	ToUserId string `json:"toUserId" yaml:"toUserId" mapstructure:"toUserId"`

	// TotemNFTId corresponds to the JSON schema field "totemNFTId".
	TotemNFTId string `json:"totemNFTId" yaml:"totemNFTId" mapstructure:"totemNFTId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *HavestDungeonInvestRewardInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["amount"]; raw != nil && !ok {
		return fmt.Errorf("field amount in HavestDungeonInvestRewardInput: required")
	}
	if _, ok := raw["havestType"]; raw != nil && !ok {
		return fmt.Errorf("field havestType in HavestDungeonInvestRewardInput: required")
	}
	if _, ok := raw["ownerUserId"]; raw != nil && !ok {
		return fmt.Errorf("field ownerUserId in HavestDungeonInvestRewardInput: required")
	}
	if _, ok := raw["toUserId"]; raw != nil && !ok {
		return fmt.Errorf("field toUserId in HavestDungeonInvestRewardInput: required")
	}
	if _, ok := raw["totemNFTId"]; raw != nil && !ok {
		return fmt.Errorf("field totemNFTId in HavestDungeonInvestRewardInput: required")
	}
	type Plain HavestDungeonInvestRewardInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = HavestDungeonInvestRewardInput(plain)
	return nil
}

type HavestDungeonInvestRewardOutput struct {
	// Reason corresponds to the JSON schema field "reason".
	Reason string `json:"reason" yaml:"reason" mapstructure:"reason"`

	// Success corresponds to the JSON schema field "success".
	Success bool `json:"success" yaml:"success" mapstructure:"success"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *HavestDungeonInvestRewardOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["reason"]; raw != nil && !ok {
		return fmt.Errorf("field reason in HavestDungeonInvestRewardOutput: required")
	}
	if _, ok := raw["success"]; raw != nil && !ok {
		return fmt.Errorf("field success in HavestDungeonInvestRewardOutput: required")
	}
	type Plain HavestDungeonInvestRewardOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = HavestDungeonInvestRewardOutput(plain)
	return nil
}

type Int32 int

type Integer float64

type InvestDungeonInput struct {
	// Amount corresponds to the JSON schema field "amount".
	Amount string `json:"amount" yaml:"amount" mapstructure:"amount"`

	// DungeonId corresponds to the JSON schema field "dungeonId".
	DungeonId int `json:"dungeonId" yaml:"dungeonId" mapstructure:"dungeonId"`

	// MinBaseLP corresponds to the JSON schema field "minBaseLP".
	MinBaseLP string `json:"minBaseLP" yaml:"minBaseLP" mapstructure:"minBaseLP"`

	// TotemNFTId corresponds to the JSON schema field "totemNFTId".
	TotemNFTId string `json:"totemNFTId" yaml:"totemNFTId" mapstructure:"totemNFTId"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *InvestDungeonInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["amount"]; raw != nil && !ok {
		return fmt.Errorf("field amount in InvestDungeonInput: required")
	}
	if _, ok := raw["dungeonId"]; raw != nil && !ok {
		return fmt.Errorf("field dungeonId in InvestDungeonInput: required")
	}
	if _, ok := raw["minBaseLP"]; raw != nil && !ok {
		return fmt.Errorf("field minBaseLP in InvestDungeonInput: required")
	}
	if _, ok := raw["totemNFTId"]; raw != nil && !ok {
		return fmt.Errorf("field totemNFTId in InvestDungeonInput: required")
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in InvestDungeonInput: required")
	}
	type Plain InvestDungeonInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = InvestDungeonInput(plain)
	return nil
}

type InvestDungeonOutput struct {
	// Reason corresponds to the JSON schema field "reason".
	Reason string `json:"reason" yaml:"reason" mapstructure:"reason"`

	// Success corresponds to the JSON schema field "success".
	Success bool `json:"success" yaml:"success" mapstructure:"success"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *InvestDungeonOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["reason"]; raw != nil && !ok {
		return fmt.Errorf("field reason in InvestDungeonOutput: required")
	}
	if _, ok := raw["success"]; raw != nil && !ok {
		return fmt.Errorf("field success in InvestDungeonOutput: required")
	}
	type Plain InvestDungeonOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = InvestDungeonOutput(plain)
	return nil
}

type InvestHavestLog struct {
	// Amount corresponds to the JSON schema field "amount".
	Amount string `json:"amount" yaml:"amount" mapstructure:"amount"`

	// HavestType corresponds to the JSON schema field "havestType".
	HavestType int `json:"havestType" yaml:"havestType" mapstructure:"havestType"`

	// Timestamp corresponds to the JSON schema field "timestamp".
	Timestamp string `json:"timestamp" yaml:"timestamp" mapstructure:"timestamp"`

	// TotemNFTId corresponds to the JSON schema field "totemNFTId".
	TotemNFTId string `json:"totemNFTId" yaml:"totemNFTId" mapstructure:"totemNFTId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *InvestHavestLog) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["amount"]; raw != nil && !ok {
		return fmt.Errorf("field amount in InvestHavestLog: required")
	}
	if _, ok := raw["havestType"]; raw != nil && !ok {
		return fmt.Errorf("field havestType in InvestHavestLog: required")
	}
	if _, ok := raw["timestamp"]; raw != nil && !ok {
		return fmt.Errorf("field timestamp in InvestHavestLog: required")
	}
	if _, ok := raw["totemNFTId"]; raw != nil && !ok {
		return fmt.Errorf("field totemNFTId in InvestHavestLog: required")
	}
	type Plain InvestHavestLog
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = InvestHavestLog(plain)
	return nil
}

// 地格数据结构
type LandData struct {
	// 地格id地图唯一
	Id int `json:"id" yaml:"id" mapstructure:"id"`

	// 地图id 为多地图准备
	MapId int `json:"mapId" yaml:"mapId" mapstructure:"mapId"`

	// 占领时间 单位秒
	OccupyAt int `json:"occupyAt" yaml:"occupyAt" mapstructure:"occupyAt"`

	// owner userId
	OwnerId string `json:"ownerId" yaml:"ownerId" mapstructure:"ownerId"`

	// 占领过期时间 单位秒
	// 当地块上存在有电量建筑物时，
	// 该时间戳无效 || 在充电时更新该时间戳
	TimeoutAt int `json:"timeoutAt" yaml:"timeoutAt" mapstructure:"timeoutAt"`

	// 地格坐标
	X float64 `json:"x" yaml:"x" mapstructure:"x"`

	// Y corresponds to the JSON schema field "y".
	Y float64 `json:"y" yaml:"y" mapstructure:"y"`

	// Z corresponds to the JSON schema field "z".
	Z float64 `json:"z" yaml:"z" mapstructure:"z"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in LandData: required")
	}
	if _, ok := raw["mapId"]; raw != nil && !ok {
		return fmt.Errorf("field mapId in LandData: required")
	}
	if _, ok := raw["occupyAt"]; raw != nil && !ok {
		return fmt.Errorf("field occupyAt in LandData: required")
	}
	if _, ok := raw["ownerId"]; raw != nil && !ok {
		return fmt.Errorf("field ownerId in LandData: required")
	}
	if _, ok := raw["timeoutAt"]; raw != nil && !ok {
		return fmt.Errorf("field timeoutAt in LandData: required")
	}
	if _, ok := raw["x"]; raw != nil && !ok {
		return fmt.Errorf("field x in LandData: required")
	}
	if _, ok := raw["y"]; raw != nil && !ok {
		return fmt.Errorf("field y in LandData: required")
	}
	if _, ok := raw["z"]; raw != nil && !ok {
		return fmt.Errorf("field z in LandData: required")
	}
	type Plain LandData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = LandData(plain)
	return nil
}

type LandServiceAction string

const LandServiceActionBuild LandServiceAction = "Build"
const LandServiceActionCharged LandServiceAction = "Charged"
const LandServiceActionCollection LandServiceAction = "Collection"
const LandServiceActionGetAllBuildData LandServiceAction = "GetAllBuildData"
const LandServiceActionGetAllLandData LandServiceAction = "GetAllLandData"
const LandServiceActionHarvest LandServiceAction = "Harvest"
const LandServiceActionMintBattery LandServiceAction = "MintBattery"
const LandServiceActionRecycling LandServiceAction = "Recycling"

var enumValues_LandServiceAction = []interface{}{
	"Build",
	"Charged",
	"Collection",
	"GetAllBuildData",
	"GetAllLandData",
	"Harvest",
	"MintBattery",
	"Recycling",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandServiceAction) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LandServiceAction {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LandServiceAction, v)
	}
	*j = LandServiceAction(v)
	return nil
}

// 攻占地格 请求地格中产生效果的skill
type LandUsingSkillInput struct {
	// 消息版本号
	Etag int `json:"etag" yaml:"etag" mapstructure:"etag"`

	// 地格ID
	TileId int `json:"tileId" yaml:"tileId" mapstructure:"tileId"`

	// 攻占者ID
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandUsingSkillInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["etag"]; raw != nil && !ok {
		return fmt.Errorf("field etag in LandUsingSkillInput: required")
	}
	if _, ok := raw["tileId"]; raw != nil && !ok {
		return fmt.Errorf("field tileId in LandUsingSkillInput: required")
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in LandUsingSkillInput: required")
	}
	type Plain LandUsingSkillInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = LandUsingSkillInput(plain)
	return nil
}

// 攻占地格 请求地格skill返回
type LandUsingSkillOutput struct {
	// 消息版本号
	Etag int `json:"etag" yaml:"etag" mapstructure:"etag"`

	// Skill List
	SkillList []Skill `json:"skillList" yaml:"skillList" mapstructure:"skillList"`

	// 地格ID
	TileId int `json:"tileId" yaml:"tileId" mapstructure:"tileId"`

	// 攻占者ID
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandUsingSkillOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["etag"]; raw != nil && !ok {
		return fmt.Errorf("field etag in LandUsingSkillOutput: required")
	}
	if _, ok := raw["skillList"]; raw != nil && !ok {
		return fmt.Errorf("field skillList in LandUsingSkillOutput: required")
	}
	if _, ok := raw["tileId"]; raw != nil && !ok {
		return fmt.Errorf("field tileId in LandUsingSkillOutput: required")
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in LandUsingSkillOutput: required")
	}
	type Plain LandUsingSkillOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = LandUsingSkillOutput(plain)
	return nil
}

// 有一些配置表格的数据不希望显示在opensea中, 但是为了方便统一解析。
// 生成到这个表格中.
type LumiAttribute struct {
	// TraitType corresponds to the JSON schema field "trait_type".
	TraitType string `json:"trait_type" yaml:"trait_type" mapstructure:"trait_type"`

	// Value corresponds to the JSON schema field "value".
	Value string `json:"value" yaml:"value" mapstructure:"value"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LumiAttribute) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["trait_type"]; raw != nil && !ok {
		return fmt.Errorf("field trait_type in LumiAttribute: required")
	}
	if _, ok := raw["value"]; raw != nil && !ok {
		return fmt.Errorf("field value in LumiAttribute: required")
	}
	type Plain LumiAttribute
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = LumiAttribute(plain)
	return nil
}

type MergeByRecipeInput struct {
	// 合成数量
	Amount int `json:"amount" yaml:"amount" mapstructure:"amount"`

	// 图鉴id
	RecipeId string `json:"recipeId" yaml:"recipeId" mapstructure:"recipeId"`

	// 合成的用户
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MergeByRecipeInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["amount"]; raw != nil && !ok {
		return fmt.Errorf("field amount in MergeByRecipeInput: required")
	}
	if _, ok := raw["recipeId"]; raw != nil && !ok {
		return fmt.Errorf("field recipeId in MergeByRecipeInput: required")
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in MergeByRecipeInput: required")
	}
	type Plain MergeByRecipeInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MergeByRecipeInput(plain)
	return nil
}

type MergeByRecipeOutput map[string]interface{}

type MintBatteryInput struct {
	// 赠送数量, 由前端传过来, 防止后端配表跟前端不一致时, 出现问题
	GiftNum int `json:"giftNum" yaml:"giftNum" mapstructure:"giftNum"`

	// mint 数量
	Num int `json:"num" yaml:"num" mapstructure:"num"`

	// 用户数量
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MintBatteryInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["giftNum"]; raw != nil && !ok {
		return fmt.Errorf("field giftNum in MintBatteryInput: required")
	}
	if _, ok := raw["num"]; raw != nil && !ok {
		return fmt.Errorf("field num in MintBatteryInput: required")
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in MintBatteryInput: required")
	}
	type Plain MintBatteryInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MintBatteryInput(plain)
	return nil
}

type MintBatteryOutput struct {
	// 失败, 则返回失败原因, 否则返回空字符串
	FailedReason string `json:"failedReason" yaml:"failedReason" mapstructure:"failedReason"`

	// 是否成功
	Success bool `json:"success" yaml:"success" mapstructure:"success"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MintBatteryOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["failedReason"]; raw != nil && !ok {
		return fmt.Errorf("field failedReason in MintBatteryOutput: required")
	}
	if _, ok := raw["success"]; raw != nil && !ok {
		return fmt.Errorf("field success in MintBatteryOutput: required")
	}
	type Plain MintBatteryOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MintBatteryOutput(plain)
	return nil
}

type MintNFTWithAttributes struct {
	// index和itemIds一一对应
	// 所有数量
	Amount int `json:"amount" yaml:"amount" mapstructure:"amount"`

	// Attributes corresponds to the JSON schema field "attributes".
	Attributes []NFTAttribute `json:"attributes" yaml:"attributes" mapstructure:"attributes"`

	// 需要mint的所有的itemId
	ItemId string `json:"itemId" yaml:"itemId" mapstructure:"itemId"`

	// NftTrackingMessage corresponds to the JSON schema field "nftTrackingMessage".
	NftTrackingMessage NFTTracking `json:"nftTrackingMessage" yaml:"nftTrackingMessage" mapstructure:"nftTrackingMessage"`

	// QualityVal corresponds to the JSON schema field "qualityVal".
	QualityVal string `json:"qualityVal" yaml:"qualityVal" mapstructure:"qualityVal"`

	// Remark corresponds to the JSON schema field "remark".
	Remark string `json:"remark" yaml:"remark" mapstructure:"remark"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MintNFTWithAttributes) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["amount"]; raw != nil && !ok {
		return fmt.Errorf("field amount in MintNFTWithAttributes: required")
	}
	if _, ok := raw["attributes"]; raw != nil && !ok {
		return fmt.Errorf("field attributes in MintNFTWithAttributes: required")
	}
	if _, ok := raw["itemId"]; raw != nil && !ok {
		return fmt.Errorf("field itemId in MintNFTWithAttributes: required")
	}
	if _, ok := raw["nftTrackingMessage"]; raw != nil && !ok {
		return fmt.Errorf("field nftTrackingMessage in MintNFTWithAttributes: required")
	}
	if _, ok := raw["qualityVal"]; raw != nil && !ok {
		return fmt.Errorf("field qualityVal in MintNFTWithAttributes: required")
	}
	if _, ok := raw["remark"]; raw != nil && !ok {
		return fmt.Errorf("field remark in MintNFTWithAttributes: required")
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in MintNFTWithAttributes: required")
	}
	type Plain MintNFTWithAttributes
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MintNFTWithAttributes(plain)
	return nil
}

type MintNFTWithSampleNFT struct {
	// Amount corresponds to the JSON schema field "amount".
	Amount int `json:"amount" yaml:"amount" mapstructure:"amount"`

	// Attributes corresponds to the JSON schema field "attributes".
	Attributes []NFTAttribute `json:"attributes" yaml:"attributes" mapstructure:"attributes"`

	// ItemId corresponds to the JSON schema field "itemId".
	ItemId string `json:"itemId" yaml:"itemId" mapstructure:"itemId"`

	// QualityVal corresponds to the JSON schema field "qualityVal".
	QualityVal string `json:"qualityVal" yaml:"qualityVal" mapstructure:"qualityVal"`

	// Remark corresponds to the JSON schema field "remark".
	Remark string `json:"remark" yaml:"remark" mapstructure:"remark"`

	// TokenId corresponds to the JSON schema field "tokenId".
	TokenId string `json:"tokenId" yaml:"tokenId" mapstructure:"tokenId"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MintNFTWithSampleNFT) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["amount"]; raw != nil && !ok {
		return fmt.Errorf("field amount in MintNFTWithSampleNFT: required")
	}
	if _, ok := raw["attributes"]; raw != nil && !ok {
		return fmt.Errorf("field attributes in MintNFTWithSampleNFT: required")
	}
	if _, ok := raw["itemId"]; raw != nil && !ok {
		return fmt.Errorf("field itemId in MintNFTWithSampleNFT: required")
	}
	if _, ok := raw["qualityVal"]; raw != nil && !ok {
		return fmt.Errorf("field qualityVal in MintNFTWithSampleNFT: required")
	}
	if _, ok := raw["remark"]; raw != nil && !ok {
		return fmt.Errorf("field remark in MintNFTWithSampleNFT: required")
	}
	if _, ok := raw["tokenId"]; raw != nil && !ok {
		return fmt.Errorf("field tokenId in MintNFTWithSampleNFT: required")
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in MintNFTWithSampleNFT: required")
	}
	type Plain MintNFTWithSampleNFT
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MintNFTWithSampleNFT(plain)
	return nil
}

type MintTaskTicketInput struct {
	// index和itemIds一一对应
	// 所有数量
	Amounts []int `json:"amounts" yaml:"amounts" mapstructure:"amounts"`

	// ItemIds corresponds to the JSON schema field "itemIds".
	ItemIds []string `json:"itemIds" yaml:"itemIds" mapstructure:"itemIds"`

	// MintId corresponds to the JSON schema field "mintId".
	MintId string `json:"mintId" yaml:"mintId" mapstructure:"mintId"`

	// TaskPoolId corresponds to the JSON schema field "taskPoolId".
	TaskPoolId string `json:"taskPoolId" yaml:"taskPoolId" mapstructure:"taskPoolId"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MintTaskTicketInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["amounts"]; raw != nil && !ok {
		return fmt.Errorf("field amounts in MintTaskTicketInput: required")
	}
	if _, ok := raw["itemIds"]; raw != nil && !ok {
		return fmt.Errorf("field itemIds in MintTaskTicketInput: required")
	}
	if _, ok := raw["mintId"]; raw != nil && !ok {
		return fmt.Errorf("field mintId in MintTaskTicketInput: required")
	}
	if _, ok := raw["taskPoolId"]; raw != nil && !ok {
		return fmt.Errorf("field taskPoolId in MintTaskTicketInput: required")
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in MintTaskTicketInput: required")
	}
	type Plain MintTaskTicketInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MintTaskTicketInput(plain)
	return nil
}

type MintTaskTicketOutput struct {
	// GameMessageId corresponds to the JSON schema field "gameMessageId".
	GameMessageId string `json:"gameMessageId" yaml:"gameMessageId" mapstructure:"gameMessageId"`

	// Reason corresponds to the JSON schema field "reason".
	Reason string `json:"reason" yaml:"reason" mapstructure:"reason"`

	// Success corresponds to the JSON schema field "success".
	Success bool `json:"success" yaml:"success" mapstructure:"success"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MintTaskTicketOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["gameMessageId"]; raw != nil && !ok {
		return fmt.Errorf("field gameMessageId in MintTaskTicketOutput: required")
	}
	if _, ok := raw["reason"]; raw != nil && !ok {
		return fmt.Errorf("field reason in MintTaskTicketOutput: required")
	}
	if _, ok := raw["success"]; raw != nil && !ok {
		return fmt.Errorf("field success in MintTaskTicketOutput: required")
	}
	type Plain MintTaskTicketOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MintTaskTicketOutput(plain)
	return nil
}

type MintUserTowerRewardInput struct {
	// Bonus corresponds to the JSON schema field "bonus".
	Bonus string `json:"bonus" yaml:"bonus" mapstructure:"bonus"`

	// index和itemIds一一对应
	// 所有数量
	ItemAmounts []int `json:"itemAmounts" yaml:"itemAmounts" mapstructure:"itemAmounts"`

	// ItemIds corresponds to the JSON schema field "itemIds".
	ItemIds []int `json:"itemIds" yaml:"itemIds" mapstructure:"itemIds"`

	// PoolId corresponds to the JSON schema field "poolId".
	PoolId string `json:"poolId" yaml:"poolId" mapstructure:"poolId"`

	// Remark corresponds to the JSON schema field "remark".
	Remark string `json:"remark" yaml:"remark" mapstructure:"remark"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MintUserTowerRewardInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["bonus"]; raw != nil && !ok {
		return fmt.Errorf("field bonus in MintUserTowerRewardInput: required")
	}
	if _, ok := raw["itemAmounts"]; raw != nil && !ok {
		return fmt.Errorf("field itemAmounts in MintUserTowerRewardInput: required")
	}
	if _, ok := raw["itemIds"]; raw != nil && !ok {
		return fmt.Errorf("field itemIds in MintUserTowerRewardInput: required")
	}
	if _, ok := raw["poolId"]; raw != nil && !ok {
		return fmt.Errorf("field poolId in MintUserTowerRewardInput: required")
	}
	if _, ok := raw["remark"]; raw != nil && !ok {
		return fmt.Errorf("field remark in MintUserTowerRewardInput: required")
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in MintUserTowerRewardInput: required")
	}
	type Plain MintUserTowerRewardInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MintUserTowerRewardInput(plain)
	return nil
}

type MintUserTowerRewardOutput struct {
	// GameMessageId corresponds to the JSON schema field "gameMessageId".
	GameMessageId string `json:"gameMessageId" yaml:"gameMessageId" mapstructure:"gameMessageId"`

	// Reason corresponds to the JSON schema field "reason".
	Reason string `json:"reason" yaml:"reason" mapstructure:"reason"`

	// Success corresponds to the JSON schema field "success".
	Success bool `json:"success" yaml:"success" mapstructure:"success"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MintUserTowerRewardOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["gameMessageId"]; raw != nil && !ok {
		return fmt.Errorf("field gameMessageId in MintUserTowerRewardOutput: required")
	}
	if _, ok := raw["reason"]; raw != nil && !ok {
		return fmt.Errorf("field reason in MintUserTowerRewardOutput: required")
	}
	if _, ok := raw["success"]; raw != nil && !ok {
		return fmt.Errorf("field success in MintUserTowerRewardOutput: required")
	}
	type Plain MintUserTowerRewardOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MintUserTowerRewardOutput(plain)
	return nil
}

type MoveNFTToOnchainInput struct {
	// Amount corresponds to the JSON schema field "amount".
	Amount int `json:"amount" yaml:"amount" mapstructure:"amount"`

	// NftId corresponds to the JSON schema field "nftId".
	NftId string `json:"nftId" yaml:"nftId" mapstructure:"nftId"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MoveNFTToOnchainInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["amount"]; raw != nil && !ok {
		return fmt.Errorf("field amount in MoveNFTToOnchainInput: required")
	}
	if _, ok := raw["nftId"]; raw != nil && !ok {
		return fmt.Errorf("field nftId in MoveNFTToOnchainInput: required")
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in MoveNFTToOnchainInput: required")
	}
	type Plain MoveNFTToOnchainInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MoveNFTToOnchainInput(plain)
	return nil
}

type MoveNFTToOnchainOutput struct {
	// GameMessageId corresponds to the JSON schema field "gameMessageId".
	GameMessageId string `json:"gameMessageId" yaml:"gameMessageId" mapstructure:"gameMessageId"`

	// Reason corresponds to the JSON schema field "reason".
	Reason string `json:"reason" yaml:"reason" mapstructure:"reason"`

	// Success corresponds to the JSON schema field "success".
	Success bool `json:"success" yaml:"success" mapstructure:"success"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MoveNFTToOnchainOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["gameMessageId"]; raw != nil && !ok {
		return fmt.Errorf("field gameMessageId in MoveNFTToOnchainOutput: required")
	}
	if _, ok := raw["reason"]; raw != nil && !ok {
		return fmt.Errorf("field reason in MoveNFTToOnchainOutput: required")
	}
	if _, ok := raw["success"]; raw != nil && !ok {
		return fmt.Errorf("field success in MoveNFTToOnchainOutput: required")
	}
	type Plain MoveNFTToOnchainOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MoveNFTToOnchainOutput(plain)
	return nil
}

type MoveNFTToRoninchainInput struct {
	// Amount corresponds to the JSON schema field "amount".
	Amount int `json:"amount" yaml:"amount" mapstructure:"amount"`

	// NftId corresponds to the JSON schema field "nftId".
	NftId string `json:"nftId" yaml:"nftId" mapstructure:"nftId"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MoveNFTToRoninchainInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["amount"]; raw != nil && !ok {
		return fmt.Errorf("field amount in MoveNFTToRoninchainInput: required")
	}
	if _, ok := raw["nftId"]; raw != nil && !ok {
		return fmt.Errorf("field nftId in MoveNFTToRoninchainInput: required")
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in MoveNFTToRoninchainInput: required")
	}
	type Plain MoveNFTToRoninchainInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MoveNFTToRoninchainInput(plain)
	return nil
}

type MoveNFTToRoninchainOutput struct {
	// GameMessageId corresponds to the JSON schema field "gameMessageId".
	GameMessageId string `json:"gameMessageId" yaml:"gameMessageId" mapstructure:"gameMessageId"`

	// Reason corresponds to the JSON schema field "reason".
	Reason string `json:"reason" yaml:"reason" mapstructure:"reason"`

	// Success corresponds to the JSON schema field "success".
	Success bool `json:"success" yaml:"success" mapstructure:"success"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MoveNFTToRoninchainOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["gameMessageId"]; raw != nil && !ok {
		return fmt.Errorf("field gameMessageId in MoveNFTToRoninchainOutput: required")
	}
	if _, ok := raw["reason"]; raw != nil && !ok {
		return fmt.Errorf("field reason in MoveNFTToRoninchainOutput: required")
	}
	if _, ok := raw["success"]; raw != nil && !ok {
		return fmt.Errorf("field success in MoveNFTToRoninchainOutput: required")
	}
	type Plain MoveNFTToRoninchainOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MoveNFTToRoninchainOutput(plain)
	return nil
}

type MoveRoninchainToGameInput struct {
	// Amount corresponds to the JSON schema field "amount".
	Amount int `json:"amount" yaml:"amount" mapstructure:"amount"`

	// NftId corresponds to the JSON schema field "nftId".
	NftId string `json:"nftId" yaml:"nftId" mapstructure:"nftId"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MoveRoninchainToGameInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["amount"]; raw != nil && !ok {
		return fmt.Errorf("field amount in MoveRoninchainToGameInput: required")
	}
	if _, ok := raw["nftId"]; raw != nil && !ok {
		return fmt.Errorf("field nftId in MoveRoninchainToGameInput: required")
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in MoveRoninchainToGameInput: required")
	}
	type Plain MoveRoninchainToGameInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MoveRoninchainToGameInput(plain)
	return nil
}

type MoveRoninchainToGameOutput struct {
	// GameMessageId corresponds to the JSON schema field "gameMessageId".
	GameMessageId string `json:"gameMessageId" yaml:"gameMessageId" mapstructure:"gameMessageId"`

	// Reason corresponds to the JSON schema field "reason".
	Reason string `json:"reason" yaml:"reason" mapstructure:"reason"`

	// Success corresponds to the JSON schema field "success".
	Success bool `json:"success" yaml:"success" mapstructure:"success"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MoveRoninchainToGameOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["gameMessageId"]; raw != nil && !ok {
		return fmt.Errorf("field gameMessageId in MoveRoninchainToGameOutput: required")
	}
	if _, ok := raw["reason"]; raw != nil && !ok {
		return fmt.Errorf("field reason in MoveRoninchainToGameOutput: required")
	}
	if _, ok := raw["success"]; raw != nil && !ok {
		return fmt.Errorf("field success in MoveRoninchainToGameOutput: required")
	}
	type Plain MoveRoninchainToGameOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MoveRoninchainToGameOutput(plain)
	return nil
}

type MultiBuildUpdateEvent struct {
	// 建造物信息
	BuildDatas []BuildData `json:"buildDatas" yaml:"buildDatas" mapstructure:"buildDatas"`

	// 消息版本号
	Etag int `json:"etag" yaml:"etag" mapstructure:"etag"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MultiBuildUpdateEvent) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["buildDatas"]; raw != nil && !ok {
		return fmt.Errorf("field buildDatas in MultiBuildUpdateEvent: required")
	}
	if _, ok := raw["etag"]; raw != nil && !ok {
		return fmt.Errorf("field etag in MultiBuildUpdateEvent: required")
	}
	type Plain MultiBuildUpdateEvent
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MultiBuildUpdateEvent(plain)
	return nil
}

type MultiGetPlayerInfoByUserIdInput struct {
	// UserIds corresponds to the JSON schema field "userIds".
	UserIds []string `json:"userIds" yaml:"userIds" mapstructure:"userIds"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MultiGetPlayerInfoByUserIdInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["userIds"]; raw != nil && !ok {
		return fmt.Errorf("field userIds in MultiGetPlayerInfoByUserIdInput: required")
	}
	type Plain MultiGetPlayerInfoByUserIdInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MultiGetPlayerInfoByUserIdInput(plain)
	return nil
}

type MultiGetPlayerInfoByUserIdOutput struct {
	// PlayerInfos corresponds to the JSON schema field "playerInfos".
	PlayerInfos []PlayerInfo `json:"playerInfos" yaml:"playerInfos" mapstructure:"playerInfos"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MultiGetPlayerInfoByUserIdOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["playerInfos"]; raw != nil && !ok {
		return fmt.Errorf("field playerInfos in MultiGetPlayerInfoByUserIdOutput: required")
	}
	type Plain MultiGetPlayerInfoByUserIdOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MultiGetPlayerInfoByUserIdOutput(plain)
	return nil
}

type MultiGetPlayerUsingNftsByUserIdInput struct {
	// UserIds corresponds to the JSON schema field "userIds".
	UserIds []string `json:"userIds" yaml:"userIds" mapstructure:"userIds"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MultiGetPlayerUsingNftsByUserIdInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["userIds"]; raw != nil && !ok {
		return fmt.Errorf("field userIds in MultiGetPlayerUsingNftsByUserIdInput: required")
	}
	type Plain MultiGetPlayerUsingNftsByUserIdInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MultiGetPlayerUsingNftsByUserIdInput(plain)
	return nil
}

type MultiGetPlayerUsingNftsByUserIdOutput struct {
	// UserUsingNfts corresponds to the JSON schema field "UserUsingNfts".
	UserUsingNfts []UserUsingNft `json:"UserUsingNfts" yaml:"UserUsingNfts" mapstructure:"UserUsingNfts"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MultiGetPlayerUsingNftsByUserIdOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["UserUsingNfts"]; raw != nil && !ok {
		return fmt.Errorf("field UserUsingNfts in MultiGetPlayerUsingNftsByUserIdOutput: required")
	}
	type Plain MultiGetPlayerUsingNftsByUserIdOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MultiGetPlayerUsingNftsByUserIdOutput(plain)
	return nil
}

type MultiGetWorldTotemPoolInput struct {
	// TotemNftIds corresponds to the JSON schema field "totemNftIds".
	TotemNftIds []string `json:"totemNftIds" yaml:"totemNftIds" mapstructure:"totemNftIds"`

	// userId[] 和 totemNftId[] 下标一一匹配
	TotemOwnerIds []string `json:"totemOwnerIds" yaml:"totemOwnerIds" mapstructure:"totemOwnerIds"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MultiGetWorldTotemPoolInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["totemNftIds"]; raw != nil && !ok {
		return fmt.Errorf("field totemNftIds in MultiGetWorldTotemPoolInput: required")
	}
	if _, ok := raw["totemOwnerIds"]; raw != nil && !ok {
		return fmt.Errorf("field totemOwnerIds in MultiGetWorldTotemPoolInput: required")
	}
	type Plain MultiGetWorldTotemPoolInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MultiGetWorldTotemPoolInput(plain)
	return nil
}

type MultiGetWorldTotemPoolOutput struct {
	// FailedReason corresponds to the JSON schema field "failedReason".
	FailedReason string `json:"failedReason" yaml:"failedReason" mapstructure:"failedReason"`

	// PoolList corresponds to the JSON schema field "poolList".
	PoolList []WorldTotemPool `json:"poolList" yaml:"poolList" mapstructure:"poolList"`

	// Success corresponds to the JSON schema field "success".
	Success bool `json:"success" yaml:"success" mapstructure:"success"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MultiGetWorldTotemPoolOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["failedReason"]; raw != nil && !ok {
		return fmt.Errorf("field failedReason in MultiGetWorldTotemPoolOutput: required")
	}
	if _, ok := raw["poolList"]; raw != nil && !ok {
		return fmt.Errorf("field poolList in MultiGetWorldTotemPoolOutput: required")
	}
	if _, ok := raw["success"]; raw != nil && !ok {
		return fmt.Errorf("field success in MultiGetWorldTotemPoolOutput: required")
	}
	type Plain MultiGetWorldTotemPoolOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MultiGetWorldTotemPoolOutput(plain)
	return nil
}

type MultiLandDataUpdateEvent struct {
	// 消息版本号
	Etag int `json:"etag" yaml:"etag" mapstructure:"etag"`

	// Lands corresponds to the JSON schema field "lands".
	Lands []LandData `json:"lands" yaml:"lands" mapstructure:"lands"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MultiLandDataUpdateEvent) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["etag"]; raw != nil && !ok {
		return fmt.Errorf("field etag in MultiLandDataUpdateEvent: required")
	}
	if _, ok := raw["lands"]; raw != nil && !ok {
		return fmt.Errorf("field lands in MultiLandDataUpdateEvent: required")
	}
	type Plain MultiLandDataUpdateEvent
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MultiLandDataUpdateEvent(plain)
	return nil
}

type MultiRecyclingEvent struct {
	// 消息版本号
	Etag int `json:"etag" yaml:"etag" mapstructure:"etag"`

	// RecyclingInfos corresponds to the JSON schema field "recyclingInfos".
	RecyclingInfos []RecyclingInfo `json:"recyclingInfos" yaml:"recyclingInfos" mapstructure:"recyclingInfos"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MultiRecyclingEvent) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["etag"]; raw != nil && !ok {
		return fmt.Errorf("field etag in MultiRecyclingEvent: required")
	}
	if _, ok := raw["recyclingInfos"]; raw != nil && !ok {
		return fmt.Errorf("field recyclingInfos in MultiRecyclingEvent: required")
	}
	type Plain MultiRecyclingEvent
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MultiRecyclingEvent(plain)
	return nil
}

type MultiUpdateUserNFT struct {
	// 消息版本号
	Etag int `json:"etag" yaml:"etag" mapstructure:"etag"`

	// 来源合成图鉴
	FromRecipeInfo *RecipeInfo `json:"fromRecipeInfo,omitempty" yaml:"fromRecipeInfo,omitempty" mapstructure:"fromRecipeInfo,omitempty"`

	// NFT信息
	Nfts []NFT `json:"nfts" yaml:"nfts" mapstructure:"nfts"`

	// 接收NFT的用户钱包地址
	RecipientBlockchainAddress *string `json:"recipientBlockchainAddress,omitempty" yaml:"recipientBlockchainAddress,omitempty" mapstructure:"recipientBlockchainAddress,omitempty"`

	// 发送NFT的用户钱包地址
	SenderBlockchainAddress *string `json:"senderBlockchainAddress,omitempty" yaml:"senderBlockchainAddress,omitempty" mapstructure:"senderBlockchainAddress,omitempty"`

	// 区块链交易hash
	Txn *string `json:"txn,omitempty" yaml:"txn,omitempty" mapstructure:"txn,omitempty"`

	// 归属用户id
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

type MultiUpdateUserNFTFromType string

const MultiUpdateUserNFTFromTypeRaffle MultiUpdateUserNFTFromType = "raffle"

var enumValues_MultiUpdateUserNFTFromType = []interface{}{
	"raffle",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MultiUpdateUserNFTFromType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_MultiUpdateUserNFTFromType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_MultiUpdateUserNFTFromType, v)
	}
	*j = MultiUpdateUserNFTFromType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MultiUpdateUserNFT) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["etag"]; raw != nil && !ok {
		return fmt.Errorf("field etag in MultiUpdateUserNFT: required")
	}
	if _, ok := raw["nfts"]; raw != nil && !ok {
		return fmt.Errorf("field nfts in MultiUpdateUserNFT: required")
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in MultiUpdateUserNFT: required")
	}
	type Plain MultiUpdateUserNFT
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MultiUpdateUserNFT(plain)
	return nil
}

type MultiUpdateUserOffchainNFT struct {
	// 消息版本号
	Etag int `json:"etag" yaml:"etag" mapstructure:"etag"`

	// NFT信息
	Nfts []NFT `json:"nfts" yaml:"nfts" mapstructure:"nfts"`

	// 归属用户id
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MultiUpdateUserOffchainNFT) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["etag"]; raw != nil && !ok {
		return fmt.Errorf("field etag in MultiUpdateUserOffchainNFT: required")
	}
	if _, ok := raw["nfts"]; raw != nil && !ok {
		return fmt.Errorf("field nfts in MultiUpdateUserOffchainNFT: required")
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in MultiUpdateUserOffchainNFT: required")
	}
	type Plain MultiUpdateUserOffchainNFT
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MultiUpdateUserOffchainNFT(plain)
	return nil
}

type MultiUpdateUserOnchainNFT struct {
	// 消息版本号
	Etag int `json:"etag" yaml:"etag" mapstructure:"etag"`

	// NFT信息
	Nfts []NFT `json:"nfts" yaml:"nfts" mapstructure:"nfts"`

	// 归属用户id
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MultiUpdateUserOnchainNFT) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["etag"]; raw != nil && !ok {
		return fmt.Errorf("field etag in MultiUpdateUserOnchainNFT: required")
	}
	if _, ok := raw["nfts"]; raw != nil && !ok {
		return fmt.Errorf("field nfts in MultiUpdateUserOnchainNFT: required")
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in MultiUpdateUserOnchainNFT: required")
	}
	type Plain MultiUpdateUserOnchainNFT
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MultiUpdateUserOnchainNFT(plain)
	return nil
}

type MultiUpdateUserRoninchainNFT struct {
	// 消息版本号
	Etag int `json:"etag" yaml:"etag" mapstructure:"etag"`

	// NFT信息
	Nfts []NFT `json:"nfts" yaml:"nfts" mapstructure:"nfts"`

	// 归属用户id
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MultiUpdateUserRoninchainNFT) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["etag"]; raw != nil && !ok {
		return fmt.Errorf("field etag in MultiUpdateUserRoninchainNFT: required")
	}
	if _, ok := raw["nfts"]; raw != nil && !ok {
		return fmt.Errorf("field nfts in MultiUpdateUserRoninchainNFT: required")
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in MultiUpdateUserRoninchainNFT: required")
	}
	type Plain MultiUpdateUserRoninchainNFT
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MultiUpdateUserRoninchainNFT(plain)
	return nil
}

type NFT struct {
	// NFT address
	Address string `json:"address" yaml:"address" mapstructure:"address"`

	// NFT amount
	Amount int `json:"amount" yaml:"amount" mapstructure:"amount"`

	// NFT 变化量
	// 默认值为0, 当某一个事件发出时, 若为n<0则表示此次事件导致的nft数量减少n, n>0则表示此次事件导致的nft数量增加n
	AmountOfChange int `json:"amountOfChange" yaml:"amountOfChange" mapstructure:"amountOfChange"`

	// CreatedAt corresponds to the JSON schema field "createdAt".
	CreatedAt int `json:"createdAt" yaml:"createdAt" mapstructure:"createdAt"`

	// NFT id
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// IsGame corresponds to the JSON schema field "isGame".
	IsGame bool `json:"isGame" yaml:"isGame" mapstructure:"isGame"`

	// 只有当isGame为true时, 才存在, 否则为空字符串
	ItemId string `json:"itemId" yaml:"itemId" mapstructure:"itemId"`

	// NFT metadata info
	// 如果非第三方则必须有metadata
	// 目前的实现是, 如果是第三方NFT, 则metadata为空, 直接将tokenURL返回给前端解析即可.
	// example: https://nftmetadata-service-release.lumiterra.net/placeable/80000031/1
	Metadata *NFTMetadata `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`

	// 描述当前nft存储于那条链上
	Network string `json:"network" yaml:"network" mapstructure:"network"`

	// product Id
	ProductId string `json:"productId" yaml:"productId" mapstructure:"productId"`

	// NFT token id
	TokenId string `json:"tokenId" yaml:"tokenId" mapstructure:"tokenId"`

	// NFT metadata url
	// https://nftmetadata-service-release.lumiterra.net/placeable/80000031/1
	TokenURL string `json:"tokenURL" yaml:"tokenURL" mapstructure:"tokenURL"`
}

// NFTAttribute 为产品定义的每个NFT的属性.
type NFTAttribute struct {
	// DisplayType corresponds to the JSON schema field "display_type".
	DisplayType *string `json:"display_type,omitempty" yaml:"display_type,omitempty" mapstructure:"display_type,omitempty"`

	// TraitType corresponds to the JSON schema field "trait_type".
	TraitType string `json:"trait_type" yaml:"trait_type" mapstructure:"trait_type"`

	// Value corresponds to the JSON schema field "value".
	Value string `json:"value" yaml:"value" mapstructure:"value"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NFTAttribute) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["trait_type"]; raw != nil && !ok {
		return fmt.Errorf("field trait_type in NFTAttribute: required")
	}
	if _, ok := raw["value"]; raw != nil && !ok {
		return fmt.Errorf("field value in NFTAttribute: required")
	}
	type Plain NFTAttribute
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = NFTAttribute(plain)
	return nil
}

// NFT metadata源信息
// https://docs.opensea.io/docs/metadata-standards
type NFTMetadata struct {
	// NFT gif animation url
	AnimationUrl *string `json:"animation_url,omitempty" yaml:"animation_url,omitempty" mapstructure:"animation_url,omitempty"`

	// NFT的额外属性.
	Attributes []NFTAttribute `json:"attributes" yaml:"attributes" mapstructure:"attributes"`

	// BackgroundColor corresponds to the JSON schema field "background_color".
	BackgroundColor *string `json:"background_color,omitempty" yaml:"background_color,omitempty" mapstructure:"background_color,omitempty"`

	// NFT description
	Description string `json:"description" yaml:"description" mapstructure:"description"`

	// NFT 扩展url
	// 有扩展URL的NFT社区会实现规范用户点击进行跳转。
	ExternalUrl *string `json:"external_url,omitempty" yaml:"external_url,omitempty" mapstructure:"external_url,omitempty"`

	// NFT image data.
	Image *string `json:"image,omitempty" yaml:"image,omitempty" mapstructure:"image,omitempty"`

	// ImageData corresponds to the JSON schema field "image_data".
	ImageData *string `json:"image_data,omitempty" yaml:"image_data,omitempty" mapstructure:"image_data,omitempty"`

	// ImageUrl corresponds to the JSON schema field "image_url".
	ImageUrl *string `json:"image_url,omitempty" yaml:"image_url,omitempty" mapstructure:"image_url,omitempty"`

	// NFT的原始数据. 只有Lumiterra的NFT才会携带
	// 基于策划的表格配置生成.
	LumiAttributes []LumiAttribute `json:"lumiAttributes,omitempty" yaml:"lumiAttributes,omitempty" mapstructure:"lumiAttributes,omitempty"`

	// NFT name
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Youtube video url
	YoutubeUrl *string `json:"youtube_url,omitempty" yaml:"youtube_url,omitempty" mapstructure:"youtube_url,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NFTMetadata) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["attributes"]; raw != nil && !ok {
		return fmt.Errorf("field attributes in NFTMetadata: required")
	}
	if _, ok := raw["description"]; raw != nil && !ok {
		return fmt.Errorf("field description in NFTMetadata: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in NFTMetadata: required")
	}
	type Plain NFTMetadata
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = NFTMetadata(plain)
	return nil
}

type NFTMoveLog struct {
	// Action corresponds to the JSON schema field "action".
	Action string `json:"action" yaml:"action" mapstructure:"action"`

	// Amount corresponds to the JSON schema field "amount".
	Amount int `json:"amount" yaml:"amount" mapstructure:"amount"`

	// CreatedAt corresponds to the JSON schema field "createdAt".
	CreatedAt int `json:"createdAt" yaml:"createdAt" mapstructure:"createdAt"`

	// Error corresponds to the JSON schema field "error".
	Error string `json:"error" yaml:"error" mapstructure:"error"`

	// ExectedAt corresponds to the JSON schema field "exectedAt".
	ExectedAt int `json:"exectedAt" yaml:"exectedAt" mapstructure:"exectedAt"`

	// ItemId corresponds to the JSON schema field "itemId".
	ItemId int `json:"itemId" yaml:"itemId" mapstructure:"itemId"`

	// NftId corresponds to the JSON schema field "nftId".
	NftId string `json:"nftId" yaml:"nftId" mapstructure:"nftId"`

	// StartAt corresponds to the JSON schema field "startAt".
	StartAt int `json:"startAt" yaml:"startAt" mapstructure:"startAt"`

	// Status corresponds to the JSON schema field "status".
	Status int `json:"status" yaml:"status" mapstructure:"status"`

	// TxHash corresponds to the JSON schema field "txHash".
	TxHash string `json:"txHash" yaml:"txHash" mapstructure:"txHash"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NFTMoveLog) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["action"]; raw != nil && !ok {
		return fmt.Errorf("field action in NFTMoveLog: required")
	}
	if _, ok := raw["amount"]; raw != nil && !ok {
		return fmt.Errorf("field amount in NFTMoveLog: required")
	}
	if _, ok := raw["createdAt"]; raw != nil && !ok {
		return fmt.Errorf("field createdAt in NFTMoveLog: required")
	}
	if _, ok := raw["error"]; raw != nil && !ok {
		return fmt.Errorf("field error in NFTMoveLog: required")
	}
	if _, ok := raw["exectedAt"]; raw != nil && !ok {
		return fmt.Errorf("field exectedAt in NFTMoveLog: required")
	}
	if _, ok := raw["itemId"]; raw != nil && !ok {
		return fmt.Errorf("field itemId in NFTMoveLog: required")
	}
	if _, ok := raw["nftId"]; raw != nil && !ok {
		return fmt.Errorf("field nftId in NFTMoveLog: required")
	}
	if _, ok := raw["startAt"]; raw != nil && !ok {
		return fmt.Errorf("field startAt in NFTMoveLog: required")
	}
	if _, ok := raw["status"]; raw != nil && !ok {
		return fmt.Errorf("field status in NFTMoveLog: required")
	}
	if _, ok := raw["txHash"]; raw != nil && !ok {
		return fmt.Errorf("field txHash in NFTMoveLog: required")
	}
	type Plain NFTMoveLog
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = NFTMoveLog(plain)
	return nil
}

type NFTSupply struct {
	// ItemId corresponds to the JSON schema field "itemId".
	ItemId string `json:"itemId" yaml:"itemId" mapstructure:"itemId"`

	// Supply corresponds to the JSON schema field "supply".
	Supply int `json:"supply" yaml:"supply" mapstructure:"supply"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NFTSupply) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["itemId"]; raw != nil && !ok {
		return fmt.Errorf("field itemId in NFTSupply: required")
	}
	if _, ok := raw["supply"]; raw != nil && !ok {
		return fmt.Errorf("field supply in NFTSupply: required")
	}
	type Plain NFTSupply
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = NFTSupply(plain)
	return nil
}

type NFTTracking struct {
	// Context corresponds to the JSON schema field "context".
	Context NFTTrackingContext `json:"context" yaml:"context" mapstructure:"context"`

	// Type corresponds to the JSON schema field "type".
	Type NFTTrackingType `json:"type" yaml:"type" mapstructure:"type"`
}

type NFTTrackingContext struct {
	// Data corresponds to the JSON schema field "data".
	Data interface{} `json:"data" yaml:"data" mapstructure:"data"`

	// Desc corresponds to the JSON schema field "desc".
	Desc string `json:"desc" yaml:"desc" mapstructure:"desc"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NFTTrackingContext) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["data"]; raw != nil && !ok {
		return fmt.Errorf("field data in NFTTrackingContext: required")
	}
	if _, ok := raw["desc"]; raw != nil && !ok {
		return fmt.Errorf("field desc in NFTTrackingContext: required")
	}
	type Plain NFTTrackingContext
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = NFTTrackingContext(plain)
	return nil
}

type NFTTrackingType string

const NFTTrackingTypeBoxStakeReward NFTTrackingType = "BoxStakeReward"
const NFTTrackingTypeDefault NFTTrackingType = "Default"
const NFTTrackingTypeDismantlingEquipment NFTTrackingType = "DismantlingEquipment"
const NFTTrackingTypeDungeon NFTTrackingType = "Dungeon"
const NFTTrackingTypeEnhanceEquipment NFTTrackingType = "EnhanceEquipment"
const NFTTrackingTypeEntityDrop NFTTrackingType = "EntityDrop"
const NFTTrackingTypeGraphQLService NFTTrackingType = "GraphQLService"
const NFTTrackingTypeMerge NFTTrackingType = "Merge"
const NFTTrackingTypePet NFTTrackingType = "Pet"
const NFTTrackingTypeTask NFTTrackingType = "Task"
const NFTTrackingTypeTotem NFTTrackingType = "Totem"
const NFTTrackingTypeUserAction NFTTrackingType = "UserAction"
const NFTTrackingTypeWagon NFTTrackingType = "Wagon"

var enumValues_NFTTrackingType = []interface{}{
	"BoxStakeReward",
	"Default",
	"DismantlingEquipment",
	"Dungeon",
	"EnhanceEquipment",
	"EntityDrop",
	"GraphQLService",
	"Merge",
	"Pet",
	"Task",
	"Totem",
	"UserAction",
	"Wagon",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NFTTrackingType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NFTTrackingType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NFTTrackingType, v)
	}
	*j = NFTTrackingType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NFTTracking) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["context"]; raw != nil && !ok {
		return fmt.Errorf("field context in NFTTracking: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in NFTTracking: required")
	}
	type Plain NFTTracking
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = NFTTracking(plain)
	return nil
}

// 核心技能id
type NFTTraitCoreSkillId interface{}

type NFTTraitPlaceableLands string

const NFTTraitPlaceableLandsOccupied NFTTraitPlaceableLands = "Occupied"
const NFTTraitPlaceableLandsTicket NFTTraitPlaceableLands = "Ticket"
const NFTTraitPlaceableLandsVIP NFTTraitPlaceableLands = "VIP"

var enumValues_NFTTraitPlaceableLands = []interface{}{
	"Occupied",
	"Ticket",
	"VIP",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NFTTraitPlaceableLands) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NFTTraitPlaceableLands {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NFTTraitPlaceableLands, v)
	}
	*j = NFTTraitPlaceableLands(v)
	return nil
}

type NFTTraitQuality string

const NFTTraitQualityAdvanced NFTTraitQuality = "Advanced"
const NFTTraitQualityBasic NFTTraitQuality = "Basic"
const NFTTraitQualityEnhanced NFTTraitQuality = "Enhanced"
const NFTTraitQualitySuper NFTTraitQuality = "Super"
const NFTTraitQualityUltimate NFTTraitQuality = "Ultimate"

var enumValues_NFTTraitQuality = []interface{}{
	"Advanced",
	"Basic",
	"Enhanced",
	"Super",
	"Ultimate",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NFTTraitQuality) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NFTTraitQuality {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NFTTraitQuality, v)
	}
	*j = NFTTraitQuality(v)
	return nil
}

type NFTTraitRarity string

const NFTTraitRarityCommon NFTTraitRarity = "common"
const NFTTraitRarityEpic NFTTraitRarity = "epic"
const NFTTraitRarityMythic NFTTraitRarity = "mythic"
const NFTTraitRarityRare NFTTraitRarity = "rare"
const NFTTraitRarityUnique NFTTraitRarity = "unique"

var enumValues_NFTTraitRarity = []interface{}{
	"common",
	"epic",
	"mythic",
	"rare",
	"unique",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NFTTraitRarity) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NFTTraitRarity {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NFTTraitRarity, v)
	}
	*j = NFTTraitRarity(v)
	return nil
}

type NFTTraitSkillLevel interface{}

type NFTTraitType string

const NFTTraitTypeBow NFTTraitType = "Bow"
const NFTTraitTypeChestArmor NFTTraitType = "Chest Armor"
const NFTTraitTypeConsumable NFTTraitType = "Consumable"
const NFTTraitTypeDagger NFTTraitType = "Dagger"
const NFTTraitTypeFeetArmor NFTTraitType = "Feet Armor"
const NFTTraitTypeHandsArmor NFTTraitType = "Hands Armor"
const NFTTraitTypeHeadArmor NFTTraitType = "Head Armor"
const NFTTraitTypeLegsArmor NFTTraitType = "Legs Armor"
const NFTTraitTypeMaterial NFTTraitType = "Material"
const NFTTraitTypeMysteryBox NFTTraitType = "MysteryBox"
const NFTTraitTypePetEgg NFTTraitType = "PetEgg"
const NFTTraitTypePlaceable NFTTraitType = "Placeable"
const NFTTraitTypeSpear NFTTraitType = "Spear"
const NFTTraitTypeSword NFTTraitType = "Sword"
const NFTTraitTypeTaskTicket NFTTraitType = "TaskTicket"
const NFTTraitTypeTotem NFTTraitType = "Totem"
const NFTTraitTypeTotemBase NFTTraitType = "Totem Base"
const NFTTraitTypeTotemRoof NFTTraitType = "Totem Roof"
const NFTTraitTypeWearable NFTTraitType = "Wearable"

var enumValues_NFTTraitType = []interface{}{
	"Bow",
	"Chest Armor",
	"Consumable",
	"Dagger",
	"Feet Armor",
	"Hands Armor",
	"Head Armor",
	"Legs Armor",
	"Material",
	"MysteryBox",
	"PetEgg",
	"Placeable",
	"Spear",
	"Sword",
	"TaskTicket",
	"Totem",
	"Totem Base",
	"Totem Roof",
	"Wearable",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NFTTraitType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NFTTraitType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NFTTraitType, v)
	}
	*j = NFTTraitType(v)
	return nil
}

type NFTTraitTypes string

const NFTTraitTypesAbilities NFTTraitTypes = "Abilities"
const NFTTraitTypesAttack NFTTraitTypes = "Attack"
const NFTTraitTypesAttackSpeed NFTTraitTypes = "Attack Speed"
const NFTTraitTypesCoreSkillId NFTTraitTypes = "CoreSkillId"
const NFTTraitTypesCreator NFTTraitTypes = "Creator"
const NFTTraitTypesCritDamage NFTTraitTypes = "Crit Damage"
const NFTTraitTypesCritPoints NFTTraitTypes = "Crit Points"
const NFTTraitTypesDefence NFTTraitTypes = "Defence"
const NFTTraitTypesDodgePoints NFTTraitTypes = "Dodge Points"
const NFTTraitTypesEnhanceLevel NFTTraitTypes = "EnhanceLevel"
const NFTTraitTypesExpireTime NFTTraitTypes = "Expire Time"
const NFTTraitTypesFertilize NFTTraitTypes = "Fertilize"
const NFTTraitTypesGender NFTTraitTypes = "Gender"
const NFTTraitTypesGetBuff NFTTraitTypes = "Get Buff"
const NFTTraitTypesHPRecovery NFTTraitTypes = "HP Recovery"
const NFTTraitTypesHitPoints NFTTraitTypes = "Hit Points"
const NFTTraitTypesLearnRecipe NFTTraitTypes = "Learn Recipe"
const NFTTraitTypesMaxEnhancementLevel NFTTraitTypes = "MaxEnhancementLevel"
const NFTTraitTypesMaxHP NFTTraitTypes = "MaxHP"
const NFTTraitTypesMoveSpeed NFTTraitTypes = "Move Speed"
const NFTTraitTypesOccupyLand NFTTraitTypes = "Occupy Land"
const NFTTraitTypesPetName NFTTraitTypes = "Pet Name"
const NFTTraitTypesPlaceableLands NFTTraitTypes = "Placeable Lands"
const NFTTraitTypesQuality NFTTraitTypes = "Quality"
const NFTTraitTypesRarity NFTTraitTypes = "Rarity"
const NFTTraitTypesRequiresLevel NFTTraitTypes = "Requires level"
const NFTTraitTypesRestoreHP NFTTraitTypes = "Restore HP"
const NFTTraitTypesSeries NFTTraitTypes = "Series"
const NFTTraitTypesSkillLevel NFTTraitTypes = "SkillLevel"
const NFTTraitTypesSowSeeds NFTTraitTypes = "Sow Seeds"
const NFTTraitTypesType NFTTraitTypes = "Type"
const NFTTraitTypesWearingPosition NFTTraitTypes = "Wearing Position"

var enumValues_NFTTraitTypes = []interface{}{
	"Abilities",
	"Attack",
	"Attack Speed",
	"CoreSkillId",
	"Creator",
	"Crit Damage",
	"Crit Points",
	"Defence",
	"Dodge Points",
	"EnhanceLevel",
	"Expire Time",
	"Fertilize",
	"Gender",
	"Get Buff",
	"HP Recovery",
	"Hit Points",
	"Learn Recipe",
	"MaxEnhancementLevel",
	"MaxHP",
	"Move Speed",
	"Occupy Land",
	"Pet Name",
	"Placeable Lands",
	"Quality",
	"Rarity",
	"Requires level",
	"Restore HP",
	"Series",
	"SkillLevel",
	"Sow Seeds",
	"Type",
	"Wearing Position",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NFTTraitTypes) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NFTTraitTypes {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NFTTraitTypes, v)
	}
	*j = NFTTraitTypes(v)
	return nil
}

type NFTTraitWearingPosition string

const NFTTraitWearingPositionGloves NFTTraitWearingPosition = "Gloves"
const NFTTraitWearingPositionHead NFTTraitWearingPosition = "Head"
const NFTTraitWearingPositionLowerBody NFTTraitWearingPosition = "Lower Body"
const NFTTraitWearingPositionShoes NFTTraitWearingPosition = "Shoes"
const NFTTraitWearingPositionUpperBody NFTTraitWearingPosition = "Upper Body"

var enumValues_NFTTraitWearingPosition = []interface{}{
	"Gloves",
	"Head",
	"Lower Body",
	"Shoes",
	"Upper Body",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NFTTraitWearingPosition) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NFTTraitWearingPosition {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NFTTraitWearingPosition, v)
	}
	*j = NFTTraitWearingPosition(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NFT) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["address"]; raw != nil && !ok {
		return fmt.Errorf("field address in NFT: required")
	}
	if _, ok := raw["amount"]; raw != nil && !ok {
		return fmt.Errorf("field amount in NFT: required")
	}
	if _, ok := raw["amountOfChange"]; raw != nil && !ok {
		return fmt.Errorf("field amountOfChange in NFT: required")
	}
	if _, ok := raw["createdAt"]; raw != nil && !ok {
		return fmt.Errorf("field createdAt in NFT: required")
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in NFT: required")
	}
	if _, ok := raw["isGame"]; raw != nil && !ok {
		return fmt.Errorf("field isGame in NFT: required")
	}
	if _, ok := raw["itemId"]; raw != nil && !ok {
		return fmt.Errorf("field itemId in NFT: required")
	}
	if _, ok := raw["network"]; raw != nil && !ok {
		return fmt.Errorf("field network in NFT: required")
	}
	if _, ok := raw["productId"]; raw != nil && !ok {
		return fmt.Errorf("field productId in NFT: required")
	}
	if _, ok := raw["tokenId"]; raw != nil && !ok {
		return fmt.Errorf("field tokenId in NFT: required")
	}
	if _, ok := raw["tokenURL"]; raw != nil && !ok {
		return fmt.Errorf("field tokenURL in NFT: required")
	}
	type Plain NFT
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = NFT(plain)
	return nil
}

type PVPEndType string

const PVPEndTypeEndTypeTie PVPEndType = "endTypeTie"
const PVPEndTypeEndTypeWin PVPEndType = "endTypeWin"

var enumValues_PVPEndType = []interface{}{
	"endTypeTie",
	"endTypeWin",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PVPEndType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PVPEndType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PVPEndType, v)
	}
	*j = PVPEndType(v)
	return nil
}

type PVPMatchEnterInput struct {
	// Player corresponds to the JSON schema field "player".
	Player PVPPlayer `json:"player" yaml:"player" mapstructure:"player"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PVPMatchEnterInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["player"]; raw != nil && !ok {
		return fmt.Errorf("field player in PVPMatchEnterInput: required")
	}
	type Plain PVPMatchEnterInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PVPMatchEnterInput(plain)
	return nil
}

type PVPMatchEnterOutput struct {
	// Succese corresponds to the JSON schema field "succese".
	Succese bool `json:"succese" yaml:"succese" mapstructure:"succese"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PVPMatchEnterOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["succese"]; raw != nil && !ok {
		return fmt.Errorf("field succese in PVPMatchEnterOutput: required")
	}
	type Plain PVPMatchEnterOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PVPMatchEnterOutput(plain)
	return nil
}

type PVPMatchLeaveInput struct {
	// Player corresponds to the JSON schema field "player".
	Player PVPPlayer `json:"player" yaml:"player" mapstructure:"player"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PVPMatchLeaveInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["player"]; raw != nil && !ok {
		return fmt.Errorf("field player in PVPMatchLeaveInput: required")
	}
	type Plain PVPMatchLeaveInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PVPMatchLeaveInput(plain)
	return nil
}

type PVPMatchLeaveOutput struct {
	// Succese corresponds to the JSON schema field "succese".
	Succese bool `json:"succese" yaml:"succese" mapstructure:"succese"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PVPMatchLeaveOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["succese"]; raw != nil && !ok {
		return fmt.Errorf("field succese in PVPMatchLeaveOutput: required")
	}
	type Plain PVPMatchLeaveOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PVPMatchLeaveOutput(plain)
	return nil
}

type PVPPKSessionStatus string

const PVPPKSessionStatusEnded PVPPKSessionStatus = "ended"
const PVPPKSessionStatusPreloading PVPPKSessionStatus = "preloading"
const PVPPKSessionStatusStarted PVPPKSessionStatus = "started"

var enumValues_PVPPKSessionStatus = []interface{}{
	"ended",
	"preloading",
	"started",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PVPPKSessionStatus) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PVPPKSessionStatus {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PVPPKSessionStatus, v)
	}
	*j = PVPPKSessionStatus(v)
	return nil
}

type PVPPlayer struct {
	// Id corresponds to the JSON schema field "id".
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// Type corresponds to the JSON schema field "type".
	Type PVPUserType `json:"type" yaml:"type" mapstructure:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PVPPlayer) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in PVPPlayer: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in PVPPlayer: required")
	}
	type Plain PVPPlayer
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PVPPlayer(plain)
	return nil
}

type PVPRoomPreLeaveInput struct {
	// Player corresponds to the JSON schema field "player".
	Player PVPPlayer `json:"player" yaml:"player" mapstructure:"player"`

	// RoomId corresponds to the JSON schema field "roomId".
	RoomId string `json:"roomId" yaml:"roomId" mapstructure:"roomId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PVPRoomPreLeaveInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["player"]; raw != nil && !ok {
		return fmt.Errorf("field player in PVPRoomPreLeaveInput: required")
	}
	if _, ok := raw["roomId"]; raw != nil && !ok {
		return fmt.Errorf("field roomId in PVPRoomPreLeaveInput: required")
	}
	type Plain PVPRoomPreLeaveInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PVPRoomPreLeaveInput(plain)
	return nil
}

type PVPRoomPreLeaveOutput struct {
	// CanLeave corresponds to the JSON schema field "canLeave".
	CanLeave bool `json:"canLeave" yaml:"canLeave" mapstructure:"canLeave"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PVPRoomPreLeaveOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["canLeave"]; raw != nil && !ok {
		return fmt.Errorf("field canLeave in PVPRoomPreLeaveOutput: required")
	}
	type Plain PVPRoomPreLeaveOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PVPRoomPreLeaveOutput(plain)
	return nil
}

type PVPRoomReadyInput struct {
	// Player corresponds to the JSON schema field "player".
	Player PVPPlayer `json:"player" yaml:"player" mapstructure:"player"`

	// PvpRoomId corresponds to the JSON schema field "pvpRoomId".
	PvpRoomId string `json:"pvpRoomId" yaml:"pvpRoomId" mapstructure:"pvpRoomId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PVPRoomReadyInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["player"]; raw != nil && !ok {
		return fmt.Errorf("field player in PVPRoomReadyInput: required")
	}
	if _, ok := raw["pvpRoomId"]; raw != nil && !ok {
		return fmt.Errorf("field pvpRoomId in PVPRoomReadyInput: required")
	}
	type Plain PVPRoomReadyInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PVPRoomReadyInput(plain)
	return nil
}

type PVPRoomReadyOutput map[string]interface{}

type PVPServiceAction string

const PVPServiceActionCreatePVPRoom PVPServiceAction = "CreatePVPRoom"
const PVPServiceActionGetCurrentPkSessionId PVPServiceAction = "GetCurrentPkSessionId"
const PVPServiceActionGetPlayerPvpProfile PVPServiceAction = "GetPlayerPvpProfile"
const PVPServiceActionGetPlayerPvpRank PVPServiceAction = "GetPlayerPvpRank"
const PVPServiceActionGetPvpHistory PVPServiceAction = "GetPvpHistory"
const PVPServiceActionPVPMatchEnter PVPServiceAction = "PVPMatchEnter"
const PVPServiceActionPVPMatchLeave PVPServiceAction = "PVPMatchLeave"
const PVPServiceActionPVPRoomPreLeave PVPServiceAction = "PVPRoomPreLeave"
const PVPServiceActionPVPRoomReady PVPServiceAction = "PVPRoomReady"
const PVPServiceActionPkSessionAgain PVPServiceAction = "PkSessionAgain"
const PVPServiceActionPkSessionDoQuestion PVPServiceAction = "PkSessionDoQuestion"
const PVPServiceActionPkSessionLoadSuccess PVPServiceAction = "PkSessionLoadSuccess"
const PVPServiceActionPkSessionUITick PVPServiceAction = "PkSessionUITick"
const PVPServiceActionPvpSurrender PVPServiceAction = "PvpSurrender"

var enumValues_PVPServiceAction = []interface{}{
	"CreatePVPRoom",
	"GetCurrentPkSessionId",
	"GetPlayerPvpProfile",
	"GetPlayerPvpRank",
	"GetPvpHistory",
	"PVPMatchEnter",
	"PVPMatchLeave",
	"PVPRoomPreLeave",
	"PVPRoomReady",
	"PkSessionAgain",
	"PkSessionDoQuestion",
	"PkSessionLoadSuccess",
	"PkSessionUITick",
	"PvpSurrender",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PVPServiceAction) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PVPServiceAction {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PVPServiceAction, v)
	}
	*j = PVPServiceAction(v)
	return nil
}

type PVPSubscriptionEvent string

const PVPSubscriptionEventPVPMatchBegin PVPSubscriptionEvent = "PVPMatchBegin"

var enumValues_PVPSubscriptionEvent = []interface{}{
	"PVPMatchBegin",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PVPSubscriptionEvent) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PVPSubscriptionEvent {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PVPSubscriptionEvent, v)
	}
	*j = PVPSubscriptionEvent(v)
	return nil
}

type PVPType string

const PVPTypePvpTypeMatch PVPType = "pvpTypeMatch"
const PVPTypePvpTypePk PVPType = "pvpTypePk"

var enumValues_PVPType = []interface{}{
	"pvpTypeMatch",
	"pvpTypePk",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PVPType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PVPType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PVPType, v)
	}
	*j = PVPType(v)
	return nil
}

type PVPUserType string

const PVPUserTypeGuest PVPUserType = "guest"
const PVPUserTypeUser PVPUserType = "user"

var enumValues_PVPUserType = []interface{}{
	"guest",
	"user",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PVPUserType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PVPUserType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PVPUserType, v)
	}
	*j = PVPUserType(v)
	return nil
}

type PageMeta struct {
	// Count corresponds to the JSON schema field "count".
	Count int `json:"count" yaml:"count" mapstructure:"count"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PageMeta) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["count"]; raw != nil && !ok {
		return fmt.Errorf("field count in PageMeta: required")
	}
	type Plain PageMeta
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PageMeta(plain)
	return nil
}

type PkSessionAgainInput struct {
	// PkSessionId corresponds to the JSON schema field "pkSessionId".
	PkSessionId string `json:"pkSessionId" yaml:"pkSessionId" mapstructure:"pkSessionId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PkSessionAgainInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["pkSessionId"]; raw != nil && !ok {
		return fmt.Errorf("field pkSessionId in PkSessionAgainInput: required")
	}
	type Plain PkSessionAgainInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PkSessionAgainInput(plain)
	return nil
}

type PkSessionAgainOutput struct {
	// PkRoomId corresponds to the JSON schema field "pkRoomId".
	PkRoomId string `json:"pkRoomId" yaml:"pkRoomId" mapstructure:"pkRoomId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PkSessionAgainOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["pkRoomId"]; raw != nil && !ok {
		return fmt.Errorf("field pkRoomId in PkSessionAgainOutput: required")
	}
	type Plain PkSessionAgainOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PkSessionAgainOutput(plain)
	return nil
}

type PkSessionDoQuestionInput struct {
	// AnswerSequentialMatch corresponds to the JSON schema field
	// "answerSequentialMatch".
	AnswerSequentialMatch []string `json:"answerSequentialMatch,omitempty" yaml:"answerSequentialMatch,omitempty" mapstructure:"answerSequentialMatch,omitempty"`

	// PkSessionId corresponds to the JSON schema field "pkSessionId".
	PkSessionId string `json:"pkSessionId" yaml:"pkSessionId" mapstructure:"pkSessionId"`

	// Player corresponds to the JSON schema field "player".
	Player PVPPlayer `json:"player" yaml:"player" mapstructure:"player"`

	// QuestionId corresponds to the JSON schema field "questionId".
	QuestionId string `json:"questionId" yaml:"questionId" mapstructure:"questionId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PkSessionDoQuestionInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["pkSessionId"]; raw != nil && !ok {
		return fmt.Errorf("field pkSessionId in PkSessionDoQuestionInput: required")
	}
	if _, ok := raw["player"]; raw != nil && !ok {
		return fmt.Errorf("field player in PkSessionDoQuestionInput: required")
	}
	if _, ok := raw["questionId"]; raw != nil && !ok {
		return fmt.Errorf("field questionId in PkSessionDoQuestionInput: required")
	}
	type Plain PkSessionDoQuestionInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PkSessionDoQuestionInput(plain)
	return nil
}

type PkSessionDoQuestionOutput struct {
	// IsCorrect corresponds to the JSON schema field "isCorrect".
	IsCorrect bool `json:"isCorrect" yaml:"isCorrect" mapstructure:"isCorrect"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PkSessionDoQuestionOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["isCorrect"]; raw != nil && !ok {
		return fmt.Errorf("field isCorrect in PkSessionDoQuestionOutput: required")
	}
	type Plain PkSessionDoQuestionOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PkSessionDoQuestionOutput(plain)
	return nil
}

type PkSessionLoadSuccessInput struct {
	// PkSessionId corresponds to the JSON schema field "pkSessionId".
	PkSessionId string `json:"pkSessionId" yaml:"pkSessionId" mapstructure:"pkSessionId"`

	// Player corresponds to the JSON schema field "player".
	Player PVPPlayer `json:"player" yaml:"player" mapstructure:"player"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PkSessionLoadSuccessInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["pkSessionId"]; raw != nil && !ok {
		return fmt.Errorf("field pkSessionId in PkSessionLoadSuccessInput: required")
	}
	if _, ok := raw["player"]; raw != nil && !ok {
		return fmt.Errorf("field player in PkSessionLoadSuccessInput: required")
	}
	type Plain PkSessionLoadSuccessInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PkSessionLoadSuccessInput(plain)
	return nil
}

type PkSessionLoadSuccessOutput map[string]interface{}

type PkSessionUITickInput struct {
	// Data corresponds to the JSON schema field "data".
	Data string `json:"data" yaml:"data" mapstructure:"data"`

	// PkSessionId corresponds to the JSON schema field "pkSessionId".
	PkSessionId string `json:"pkSessionId" yaml:"pkSessionId" mapstructure:"pkSessionId"`

	// Player corresponds to the JSON schema field "player".
	Player PVPPlayer `json:"player" yaml:"player" mapstructure:"player"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PkSessionUITickInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["data"]; raw != nil && !ok {
		return fmt.Errorf("field data in PkSessionUITickInput: required")
	}
	if _, ok := raw["pkSessionId"]; raw != nil && !ok {
		return fmt.Errorf("field pkSessionId in PkSessionUITickInput: required")
	}
	if _, ok := raw["player"]; raw != nil && !ok {
		return fmt.Errorf("field player in PkSessionUITickInput: required")
	}
	type Plain PkSessionUITickInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PkSessionUITickInput(plain)
	return nil
}

type PkSessionUITickOutput map[string]interface{}

type PlayerAvatar struct {
	// Cid corresponds to the JSON schema field "cid".
	Cid int `json:"cid" yaml:"cid" mapstructure:"cid"`

	// NftId corresponds to the JSON schema field "nftId".
	NftId string `json:"nftId" yaml:"nftId" mapstructure:"nftId"`

	// NftJson corresponds to the JSON schema field "nftJson".
	NftJson string `json:"nftJson" yaml:"nftJson" mapstructure:"nftJson"`

	// Pos corresponds to the JSON schema field "pos".
	Pos int `json:"pos" yaml:"pos" mapstructure:"pos"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PlayerAvatar) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["cid"]; raw != nil && !ok {
		return fmt.Errorf("field cid in PlayerAvatar: required")
	}
	if _, ok := raw["nftId"]; raw != nil && !ok {
		return fmt.Errorf("field nftId in PlayerAvatar: required")
	}
	if _, ok := raw["nftJson"]; raw != nil && !ok {
		return fmt.Errorf("field nftJson in PlayerAvatar: required")
	}
	if _, ok := raw["pos"]; raw != nil && !ok {
		return fmt.Errorf("field pos in PlayerAvatar: required")
	}
	type Plain PlayerAvatar
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PlayerAvatar(plain)
	return nil
}

// 玩家死亡事件, 当玩家死亡时触发
type PlayerDeath struct {
	// 玩家死亡的附近landId
	DeathLandId int `json:"deathLandId" yaml:"deathLandId" mapstructure:"deathLandId"`

	// 造成玩家死亡的生物或用户id
	KillerId string `json:"killerId" yaml:"killerId" mapstructure:"killerId"`

	// 造成玩家死亡的生物或用户名称
	KillerName string `json:"killerName" yaml:"killerName" mapstructure:"killerName"`

	// 最后造成死亡的数值
	LastDamage float64 `json:"lastDamage" yaml:"lastDamage" mapstructure:"lastDamage"`

	// 死亡的用户id
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PlayerDeath) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["deathLandId"]; raw != nil && !ok {
		return fmt.Errorf("field deathLandId in PlayerDeath: required")
	}
	if _, ok := raw["killerId"]; raw != nil && !ok {
		return fmt.Errorf("field killerId in PlayerDeath: required")
	}
	if _, ok := raw["killerName"]; raw != nil && !ok {
		return fmt.Errorf("field killerName in PlayerDeath: required")
	}
	if _, ok := raw["lastDamage"]; raw != nil && !ok {
		return fmt.Errorf("field lastDamage in PlayerDeath: required")
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in PlayerDeath: required")
	}
	type Plain PlayerDeath
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PlayerDeath(plain)
	return nil
}

type PlayerInfo struct {
	// Icon corresponds to the JSON schema field "icon".
	Icon string `json:"icon" yaml:"icon" mapstructure:"icon"`

	// InviteCode corresponds to the JSON schema field "inviteCode".
	InviteCode string `json:"inviteCode" yaml:"inviteCode" mapstructure:"inviteCode"`

	// Level corresponds to the JSON schema field "level".
	Level int `json:"level" yaml:"level" mapstructure:"level"`

	// PlayerName corresponds to the JSON schema field "playerName".
	PlayerName string `json:"playerName" yaml:"playerName" mapstructure:"playerName"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PlayerInfo) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["icon"]; raw != nil && !ok {
		return fmt.Errorf("field icon in PlayerInfo: required")
	}
	if _, ok := raw["inviteCode"]; raw != nil && !ok {
		return fmt.Errorf("field inviteCode in PlayerInfo: required")
	}
	if _, ok := raw["level"]; raw != nil && !ok {
		return fmt.Errorf("field level in PlayerInfo: required")
	}
	if _, ok := raw["playerName"]; raw != nil && !ok {
		return fmt.Errorf("field playerName in PlayerInfo: required")
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in PlayerInfo: required")
	}
	type Plain PlayerInfo
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PlayerInfo(plain)
	return nil
}

type PlayerItemSlot struct {
	// Level corresponds to the JSON schema field "level".
	Level int `json:"level" yaml:"level" mapstructure:"level"`

	// Position corresponds to the JSON schema field "position".
	Position int `json:"position" yaml:"position" mapstructure:"position"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PlayerItemSlot) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["level"]; raw != nil && !ok {
		return fmt.Errorf("field level in PlayerItemSlot: required")
	}
	if _, ok := raw["position"]; raw != nil && !ok {
		return fmt.Errorf("field position in PlayerItemSlot: required")
	}
	type Plain PlayerItemSlot
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PlayerItemSlot(plain)
	return nil
}

// 玩家击杀怪物
type PlayerKilled struct {
	// 怪物被击杀的坐标
	KilledLandId int `json:"killedLandId" yaml:"killedLandId" mapstructure:"killedLandId"`

	// 最后一击的伤害
	LastDamage float64 `json:"lastDamage" yaml:"lastDamage" mapstructure:"lastDamage"`

	// 击杀的目标id
	TargetId string `json:"targetId" yaml:"targetId" mapstructure:"targetId"`

	// 击杀的目标名称
	TargetName string `json:"targetName" yaml:"targetName" mapstructure:"targetName"`

	// 用户id
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PlayerKilled) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["killedLandId"]; raw != nil && !ok {
		return fmt.Errorf("field killedLandId in PlayerKilled: required")
	}
	if _, ok := raw["lastDamage"]; raw != nil && !ok {
		return fmt.Errorf("field lastDamage in PlayerKilled: required")
	}
	if _, ok := raw["targetId"]; raw != nil && !ok {
		return fmt.Errorf("field targetId in PlayerKilled: required")
	}
	if _, ok := raw["targetName"]; raw != nil && !ok {
		return fmt.Errorf("field targetName in PlayerKilled: required")
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in PlayerKilled: required")
	}
	type Plain PlayerKilled
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PlayerKilled(plain)
	return nil
}

// 玩家重生事件, 当玩家重生时, 会触发此事件
type PlayerReborn struct {
	// 重生的地格id
	RebornLandId int `json:"rebornLandId" yaml:"rebornLandId" mapstructure:"rebornLandId"`

	// 玩家重生类型
	Type PlayerRebornType `json:"type" yaml:"type" mapstructure:"type"`

	// 重生的玩家id
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

type PlayerRebornType string

const PlayerRebornTypeInPlace PlayerRebornType = "in_place"
const PlayerRebornTypeMainCity PlayerRebornType = "main_city"

var enumValues_PlayerRebornType = []interface{}{
	"in_place",
	"main_city",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PlayerRebornType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PlayerRebornType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PlayerRebornType, v)
	}
	*j = PlayerRebornType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PlayerReborn) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["rebornLandId"]; raw != nil && !ok {
		return fmt.Errorf("field rebornLandId in PlayerReborn: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in PlayerReborn: required")
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in PlayerReborn: required")
	}
	type Plain PlayerReborn
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PlayerReborn(plain)
	return nil
}

type Prefetch struct {
	// QuestionId corresponds to the JSON schema field "questionId".
	QuestionId string `json:"questionId" yaml:"questionId" mapstructure:"questionId"`

	// QuestionType corresponds to the JSON schema field "questionType".
	QuestionType QuestionType `json:"questionType" yaml:"questionType" mapstructure:"questionType"`

	// Resources corresponds to the JSON schema field "resources".
	Resources []string `json:"resources" yaml:"resources" mapstructure:"resources"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Prefetch) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["questionId"]; raw != nil && !ok {
		return fmt.Errorf("field questionId in Prefetch: required")
	}
	if _, ok := raw["questionType"]; raw != nil && !ok {
		return fmt.Errorf("field questionType in Prefetch: required")
	}
	if _, ok := raw["resources"]; raw != nil && !ok {
		return fmt.Errorf("field resources in Prefetch: required")
	}
	type Plain Prefetch
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Prefetch(plain)
	return nil
}

type PvpHistory struct {
	// EndType corresponds to the JSON schema field "endType".
	EndType string `json:"endType" yaml:"endType" mapstructure:"endType"`

	// Loser corresponds to the JSON schema field "loser".
	Loser string `json:"loser" yaml:"loser" mapstructure:"loser"`

	// LoserName corresponds to the JSON schema field "loserName".
	LoserName string `json:"loserName" yaml:"loserName" mapstructure:"loserName"`

	// LoserScore corresponds to the JSON schema field "loserScore".
	LoserScore int `json:"loserScore" yaml:"loserScore" mapstructure:"loserScore"`

	// PvpType corresponds to the JSON schema field "pvpType".
	PvpType string `json:"pvpType" yaml:"pvpType" mapstructure:"pvpType"`

	// ScoreOffset corresponds to the JSON schema field "scoreOffset".
	ScoreOffset int `json:"scoreOffset" yaml:"scoreOffset" mapstructure:"scoreOffset"`

	// TimeSec corresponds to the JSON schema field "timeSec".
	TimeSec int `json:"timeSec" yaml:"timeSec" mapstructure:"timeSec"`

	// Winner corresponds to the JSON schema field "winner".
	Winner string `json:"winner" yaml:"winner" mapstructure:"winner"`

	// WinnerName corresponds to the JSON schema field "winnerName".
	WinnerName string `json:"winnerName" yaml:"winnerName" mapstructure:"winnerName"`

	// WinnerScore corresponds to the JSON schema field "winnerScore".
	WinnerScore int `json:"winnerScore" yaml:"winnerScore" mapstructure:"winnerScore"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PvpHistory) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["endType"]; raw != nil && !ok {
		return fmt.Errorf("field endType in PvpHistory: required")
	}
	if _, ok := raw["loser"]; raw != nil && !ok {
		return fmt.Errorf("field loser in PvpHistory: required")
	}
	if _, ok := raw["loserName"]; raw != nil && !ok {
		return fmt.Errorf("field loserName in PvpHistory: required")
	}
	if _, ok := raw["loserScore"]; raw != nil && !ok {
		return fmt.Errorf("field loserScore in PvpHistory: required")
	}
	if _, ok := raw["pvpType"]; raw != nil && !ok {
		return fmt.Errorf("field pvpType in PvpHistory: required")
	}
	if _, ok := raw["scoreOffset"]; raw != nil && !ok {
		return fmt.Errorf("field scoreOffset in PvpHistory: required")
	}
	if _, ok := raw["timeSec"]; raw != nil && !ok {
		return fmt.Errorf("field timeSec in PvpHistory: required")
	}
	if _, ok := raw["winner"]; raw != nil && !ok {
		return fmt.Errorf("field winner in PvpHistory: required")
	}
	if _, ok := raw["winnerName"]; raw != nil && !ok {
		return fmt.Errorf("field winnerName in PvpHistory: required")
	}
	if _, ok := raw["winnerScore"]; raw != nil && !ok {
		return fmt.Errorf("field winnerScore in PvpHistory: required")
	}
	type Plain PvpHistory
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PvpHistory(plain)
	return nil
}

type PvpPlayerProfile struct {
	// Avatars corresponds to the JSON schema field "avatars".
	Avatars []PlayerAvatar `json:"avatars" yaml:"avatars" mapstructure:"avatars"`

	// BaseInfo corresponds to the JSON schema field "baseInfo".
	BaseInfo PlayerInfo `json:"baseInfo" yaml:"baseInfo" mapstructure:"baseInfo"`

	// ItemSlots corresponds to the JSON schema field "itemSlots".
	ItemSlots []PlayerItemSlot `json:"itemSlots" yaml:"itemSlots" mapstructure:"itemSlots"`

	// PlayerId corresponds to the JSON schema field "playerId".
	PlayerId string `json:"playerId" yaml:"playerId" mapstructure:"playerId"`

	// Score corresponds to the JSON schema field "score".
	Score int `json:"score" yaml:"score" mapstructure:"score"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PvpPlayerProfile) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["avatars"]; raw != nil && !ok {
		return fmt.Errorf("field avatars in PvpPlayerProfile: required")
	}
	if _, ok := raw["baseInfo"]; raw != nil && !ok {
		return fmt.Errorf("field baseInfo in PvpPlayerProfile: required")
	}
	if _, ok := raw["itemSlots"]; raw != nil && !ok {
		return fmt.Errorf("field itemSlots in PvpPlayerProfile: required")
	}
	if _, ok := raw["playerId"]; raw != nil && !ok {
		return fmt.Errorf("field playerId in PvpPlayerProfile: required")
	}
	if _, ok := raw["score"]; raw != nil && !ok {
		return fmt.Errorf("field score in PvpPlayerProfile: required")
	}
	type Plain PvpPlayerProfile
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PvpPlayerProfile(plain)
	return nil
}

type PvpPlayerRank struct {
	// Avatars corresponds to the JSON schema field "avatars".
	Avatars []PlayerAvatar `json:"avatars" yaml:"avatars" mapstructure:"avatars"`

	// BaseInfo corresponds to the JSON schema field "baseInfo".
	BaseInfo PlayerInfo `json:"baseInfo" yaml:"baseInfo" mapstructure:"baseInfo"`

	// PlayerId corresponds to the JSON schema field "playerId".
	PlayerId string `json:"playerId" yaml:"playerId" mapstructure:"playerId"`

	// Rank corresponds to the JSON schema field "rank".
	Rank int `json:"rank" yaml:"rank" mapstructure:"rank"`

	// Score corresponds to the JSON schema field "score".
	Score int `json:"score" yaml:"score" mapstructure:"score"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PvpPlayerRank) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["avatars"]; raw != nil && !ok {
		return fmt.Errorf("field avatars in PvpPlayerRank: required")
	}
	if _, ok := raw["baseInfo"]; raw != nil && !ok {
		return fmt.Errorf("field baseInfo in PvpPlayerRank: required")
	}
	if _, ok := raw["playerId"]; raw != nil && !ok {
		return fmt.Errorf("field playerId in PvpPlayerRank: required")
	}
	if _, ok := raw["rank"]; raw != nil && !ok {
		return fmt.Errorf("field rank in PvpPlayerRank: required")
	}
	if _, ok := raw["score"]; raw != nil && !ok {
		return fmt.Errorf("field score in PvpPlayerRank: required")
	}
	type Plain PvpPlayerRank
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PvpPlayerRank(plain)
	return nil
}

type PvpSurrenderInput struct {
	// PkSessionId corresponds to the JSON schema field "pkSessionId".
	PkSessionId string `json:"pkSessionId" yaml:"pkSessionId" mapstructure:"pkSessionId"`

	// PlayerId corresponds to the JSON schema field "playerId".
	PlayerId string `json:"playerId" yaml:"playerId" mapstructure:"playerId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PvpSurrenderInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["pkSessionId"]; raw != nil && !ok {
		return fmt.Errorf("field pkSessionId in PvpSurrenderInput: required")
	}
	if _, ok := raw["playerId"]; raw != nil && !ok {
		return fmt.Errorf("field playerId in PvpSurrenderInput: required")
	}
	type Plain PvpSurrenderInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PvpSurrenderInput(plain)
	return nil
}

type PvpSurrenderOutput struct {
	// Success corresponds to the JSON schema field "success".
	Success bool `json:"success" yaml:"success" mapstructure:"success"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PvpSurrenderOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["success"]; raw != nil && !ok {
		return fmt.Errorf("field success in PvpSurrenderOutput: required")
	}
	type Plain PvpSurrenderOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PvpSurrenderOutput(plain)
	return nil
}

type Question struct {
	// Id corresponds to the JSON schema field "id".
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// StructJSON corresponds to the JSON schema field "structJSON".
	StructJSON string `json:"structJSON" yaml:"structJSON" mapstructure:"structJSON"`
}

type QuestionType string

const QuestionTypeAdjustClock QuestionType = "AdjustClock"
const QuestionTypeBlockCompute QuestionType = "BlockCompute"
const QuestionTypeCageShuffle QuestionType = "CageShuffle"
const QuestionTypeCardMemory QuestionType = "CardMemory"
const QuestionTypeCuttingArt QuestionType = "CuttingArt"
const QuestionTypeHitBrick QuestionType = "HitBrick"
const QuestionTypeMatchingMouse QuestionType = "MatchingMouse"
const QuestionTypeQuickFlashMemory QuestionType = "QuickFlashMemory"
const QuestionTypeReverseMemory QuestionType = "ReverseMemory"
const QuestionTypeRotatingSilhouette QuestionType = "RotatingSilhouette"
const QuestionTypeSequenceBalloon QuestionType = "SequenceBalloon"
const QuestionTypeSingleChoice QuestionType = "SingleChoice"

var enumValues_QuestionType = []interface{}{
	"AdjustClock",
	"BlockCompute",
	"CageShuffle",
	"CardMemory",
	"CuttingArt",
	"HitBrick",
	"MatchingMouse",
	"QuickFlashMemory",
	"ReverseMemory",
	"RotatingSilhouette",
	"SequenceBalloon",
	"SingleChoice",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *QuestionType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_QuestionType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_QuestionType, v)
	}
	*j = QuestionType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Question) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in Question: required")
	}
	if _, ok := raw["structJSON"]; raw != nil && !ok {
		return fmt.Errorf("field structJSON in Question: required")
	}
	type Plain Question
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Question(plain)
	return nil
}

type RaffleDrawEvent struct {
	// Log corresponds to the JSON schema field "log".
	Log RaffleDrawLog `json:"log" yaml:"log" mapstructure:"log"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RaffleDrawEvent) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["log"]; raw != nil && !ok {
		return fmt.Errorf("field log in RaffleDrawEvent: required")
	}
	type Plain RaffleDrawEvent
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = RaffleDrawEvent(plain)
	return nil
}

type RaffleDrawInput struct {
	// Amount corresponds to the JSON schema field "amount".
	Amount int `json:"amount" yaml:"amount" mapstructure:"amount"`

	// RaffleTicketNFTId corresponds to the JSON schema field "raffleTicketNFTId".
	RaffleTicketNFTId string `json:"raffleTicketNFTId" yaml:"raffleTicketNFTId" mapstructure:"raffleTicketNFTId"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RaffleDrawInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["amount"]; raw != nil && !ok {
		return fmt.Errorf("field amount in RaffleDrawInput: required")
	}
	if _, ok := raw["raffleTicketNFTId"]; raw != nil && !ok {
		return fmt.Errorf("field raffleTicketNFTId in RaffleDrawInput: required")
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in RaffleDrawInput: required")
	}
	type Plain RaffleDrawInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = RaffleDrawInput(plain)
	return nil
}

type RaffleDrawLog struct {
	// Amount corresponds to the JSON schema field "amount".
	Amount int `json:"amount" yaml:"amount" mapstructure:"amount"`

	// BlockTime corresponds to the JSON schema field "blockTime".
	BlockTime int `json:"blockTime" yaml:"blockTime" mapstructure:"blockTime"`

	// PlayerName corresponds to the JSON schema field "playerName".
	PlayerName string `json:"playerName" yaml:"playerName" mapstructure:"playerName"`

	// RaffleTicketNFTId corresponds to the JSON schema field "raffleTicketNFTId".
	RaffleTicketNFTId string `json:"raffleTicketNFTId" yaml:"raffleTicketNFTId" mapstructure:"raffleTicketNFTId"`

	// RaffleTicketNFTItemId corresponds to the JSON schema field
	// "raffleTicketNFTItemId".
	RaffleTicketNFTItemId string `json:"raffleTicketNFTItemId" yaml:"raffleTicketNFTItemId" mapstructure:"raffleTicketNFTItemId"`

	// index和itemIds一一对应
	// 所有数量
	ResultAmounts []int `json:"resultAmounts" yaml:"resultAmounts" mapstructure:"resultAmounts"`

	// ResultItemIds corresponds to the JSON schema field "resultItemIds".
	ResultItemIds []string `json:"resultItemIds" yaml:"resultItemIds" mapstructure:"resultItemIds"`

	// TxHash corresponds to the JSON schema field "txHash".
	TxHash string `json:"txHash" yaml:"txHash" mapstructure:"txHash"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RaffleDrawLog) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["amount"]; raw != nil && !ok {
		return fmt.Errorf("field amount in RaffleDrawLog: required")
	}
	if _, ok := raw["blockTime"]; raw != nil && !ok {
		return fmt.Errorf("field blockTime in RaffleDrawLog: required")
	}
	if _, ok := raw["playerName"]; raw != nil && !ok {
		return fmt.Errorf("field playerName in RaffleDrawLog: required")
	}
	if _, ok := raw["raffleTicketNFTId"]; raw != nil && !ok {
		return fmt.Errorf("field raffleTicketNFTId in RaffleDrawLog: required")
	}
	if _, ok := raw["raffleTicketNFTItemId"]; raw != nil && !ok {
		return fmt.Errorf("field raffleTicketNFTItemId in RaffleDrawLog: required")
	}
	if _, ok := raw["resultAmounts"]; raw != nil && !ok {
		return fmt.Errorf("field resultAmounts in RaffleDrawLog: required")
	}
	if _, ok := raw["resultItemIds"]; raw != nil && !ok {
		return fmt.Errorf("field resultItemIds in RaffleDrawLog: required")
	}
	if _, ok := raw["txHash"]; raw != nil && !ok {
		return fmt.Errorf("field txHash in RaffleDrawLog: required")
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in RaffleDrawLog: required")
	}
	type Plain RaffleDrawLog
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = RaffleDrawLog(plain)
	return nil
}

type RaffleDrawOutput map[string]interface{}

type RecipeInfo struct {
	// 图鉴id
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// 图鉴名称
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RecipeInfo) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in RecipeInfo: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in RecipeInfo: required")
	}
	type Plain RecipeInfo
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = RecipeInfo(plain)
	return nil
}

type RecycleWorldTotemEvent struct {
	// TotemNftId corresponds to the JSON schema field "totemNftId".
	TotemNftId string `json:"totemNftId" yaml:"totemNftId" mapstructure:"totemNftId"`

	// TotemOwnerId corresponds to the JSON schema field "totemOwnerId".
	TotemOwnerId string `json:"totemOwnerId" yaml:"totemOwnerId" mapstructure:"totemOwnerId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RecycleWorldTotemEvent) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["totemNftId"]; raw != nil && !ok {
		return fmt.Errorf("field totemNftId in RecycleWorldTotemEvent: required")
	}
	if _, ok := raw["totemOwnerId"]; raw != nil && !ok {
		return fmt.Errorf("field totemOwnerId in RecycleWorldTotemEvent: required")
	}
	type Plain RecycleWorldTotemEvent
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = RecycleWorldTotemEvent(plain)
	return nil
}

type RecyclingInfo struct {
	// BuildId corresponds to the JSON schema field "buildId".
	BuildId int `json:"buildId" yaml:"buildId" mapstructure:"buildId"`

	// MapId corresponds to the JSON schema field "mapId".
	MapId int `json:"mapId" yaml:"mapId" mapstructure:"mapId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RecyclingInfo) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["buildId"]; raw != nil && !ok {
		return fmt.Errorf("field buildId in RecyclingInfo: required")
	}
	if _, ok := raw["mapId"]; raw != nil && !ok {
		return fmt.Errorf("field mapId in RecyclingInfo: required")
	}
	type Plain RecyclingInfo
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = RecyclingInfo(plain)
	return nil
}

type RecyclingInput struct {
	// 建造Id
	BuildId int `json:"buildId" yaml:"buildId" mapstructure:"buildId"`

	// 地图id 为多地图准备
	MapId int `json:"mapId" yaml:"mapId" mapstructure:"mapId"`

	// 玩家id
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RecyclingInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["buildId"]; raw != nil && !ok {
		return fmt.Errorf("field buildId in RecyclingInput: required")
	}
	if _, ok := raw["mapId"]; raw != nil && !ok {
		return fmt.Errorf("field mapId in RecyclingInput: required")
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in RecyclingInput: required")
	}
	type Plain RecyclingInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = RecyclingInput(plain)
	return nil
}

type RecyclingOutput struct {
	// 失败, 则返回失败原因, 否则返回空字符串
	FailedReason string `json:"failedReason" yaml:"failedReason" mapstructure:"failedReason"`

	// 是否成功
	Success bool `json:"success" yaml:"success" mapstructure:"success"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RecyclingOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["failedReason"]; raw != nil && !ok {
		return fmt.Errorf("field failedReason in RecyclingOutput: required")
	}
	if _, ok := raw["success"]; raw != nil && !ok {
		return fmt.Errorf("field success in RecyclingOutput: required")
	}
	type Plain RecyclingOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = RecyclingOutput(plain)
	return nil
}

type SceneDynamicServiceAction string

const SceneDynamicServiceActionStartServer SceneDynamicServiceAction = "StartServer"

var enumValues_SceneDynamicServiceAction = []interface{}{
	"StartServer",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SceneDynamicServiceAction) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SceneDynamicServiceAction {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SceneDynamicServiceAction, v)
	}
	*j = SceneDynamicServiceAction(v)
	return nil
}

type SendMetaTxInput struct {
	// Data corresponds to the JSON schema field "data".
	Data string `json:"data" yaml:"data" mapstructure:"data"`

	// From corresponds to the JSON schema field "from".
	From string `json:"from" yaml:"from" mapstructure:"from"`

	// Gas corresponds to the JSON schema field "gas".
	Gas float64 `json:"gas" yaml:"gas" mapstructure:"gas"`

	// Nonce corresponds to the JSON schema field "nonce".
	Nonce string `json:"nonce" yaml:"nonce" mapstructure:"nonce"`

	// Signature corresponds to the JSON schema field "signature".
	Signature string `json:"signature" yaml:"signature" mapstructure:"signature"`

	// To corresponds to the JSON schema field "to".
	To string `json:"to" yaml:"to" mapstructure:"to"`

	// Value corresponds to the JSON schema field "value".
	Value string `json:"value" yaml:"value" mapstructure:"value"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SendMetaTxInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["data"]; raw != nil && !ok {
		return fmt.Errorf("field data in SendMetaTxInput: required")
	}
	if _, ok := raw["from"]; raw != nil && !ok {
		return fmt.Errorf("field from in SendMetaTxInput: required")
	}
	if _, ok := raw["gas"]; raw != nil && !ok {
		return fmt.Errorf("field gas in SendMetaTxInput: required")
	}
	if _, ok := raw["nonce"]; raw != nil && !ok {
		return fmt.Errorf("field nonce in SendMetaTxInput: required")
	}
	if _, ok := raw["signature"]; raw != nil && !ok {
		return fmt.Errorf("field signature in SendMetaTxInput: required")
	}
	if _, ok := raw["to"]; raw != nil && !ok {
		return fmt.Errorf("field to in SendMetaTxInput: required")
	}
	if _, ok := raw["value"]; raw != nil && !ok {
		return fmt.Errorf("field value in SendMetaTxInput: required")
	}
	type Plain SendMetaTxInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SendMetaTxInput(plain)
	return nil
}

type SendMetaTxOutput struct {
	// TxId corresponds to the JSON schema field "txId".
	TxId string `json:"txId" yaml:"txId" mapstructure:"txId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SendMetaTxOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["txId"]; raw != nil && !ok {
		return fmt.Errorf("field txId in SendMetaTxOutput: required")
	}
	type Plain SendMetaTxOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SendMetaTxOutput(plain)
	return nil
}

type SendTxInput struct {
	// Data corresponds to the JSON schema field "data".
	Data string `json:"data" yaml:"data" mapstructure:"data"`

	// Gas corresponds to the JSON schema field "gas".
	Gas float64 `json:"gas" yaml:"gas" mapstructure:"gas"`

	// To corresponds to the JSON schema field "to".
	To string `json:"to" yaml:"to" mapstructure:"to"`

	// Value corresponds to the JSON schema field "value".
	Value string `json:"value" yaml:"value" mapstructure:"value"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SendTxInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["data"]; raw != nil && !ok {
		return fmt.Errorf("field data in SendTxInput: required")
	}
	if _, ok := raw["gas"]; raw != nil && !ok {
		return fmt.Errorf("field gas in SendTxInput: required")
	}
	if _, ok := raw["to"]; raw != nil && !ok {
		return fmt.Errorf("field to in SendTxInput: required")
	}
	if _, ok := raw["value"]; raw != nil && !ok {
		return fmt.Errorf("field value in SendTxInput: required")
	}
	type Plain SendTxInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SendTxInput(plain)
	return nil
}

type SendTxOutput struct {
	// TxId corresponds to the JSON schema field "txId".
	TxId string `json:"txId" yaml:"txId" mapstructure:"txId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SendTxOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["txId"]; raw != nil && !ok {
		return fmt.Errorf("field txId in SendTxOutput: required")
	}
	type Plain SendTxOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SendTxOutput(plain)
	return nil
}

type Sex string

const SexFEMALE Sex = "FEMALE"
const SexMALE Sex = "MALE"

var enumValues_Sex = []interface{}{
	"FEMALE",
	"MALE",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Sex) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Sex {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Sex, v)
	}
	*j = Sex(v)
	return nil
}

type Skill struct {
	// skill level
	Level int `json:"level" yaml:"level" mapstructure:"level"`

	// skill Id,  only key
	SkillId int `json:"skillId" yaml:"skillId" mapstructure:"skillId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Skill) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["level"]; raw != nil && !ok {
		return fmt.Errorf("field level in Skill: required")
	}
	if _, ok := raw["skillId"]; raw != nil && !ok {
		return fmt.Errorf("field skillId in Skill: required")
	}
	type Plain Skill
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Skill(plain)
	return nil
}

type SmapleNFT struct {
	// Amount corresponds to the JSON schema field "amount".
	Amount int `json:"amount" yaml:"amount" mapstructure:"amount"`

	// ItemId corresponds to the JSON schema field "itemId".
	ItemId string `json:"itemId" yaml:"itemId" mapstructure:"itemId"`

	// Metadata corresponds to the JSON schema field "metadata".
	Metadata NFTMetadata `json:"metadata" yaml:"metadata" mapstructure:"metadata"`

	// TokenId corresponds to the JSON schema field "tokenId".
	TokenId string `json:"tokenId" yaml:"tokenId" mapstructure:"tokenId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SmapleNFT) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["amount"]; raw != nil && !ok {
		return fmt.Errorf("field amount in SmapleNFT: required")
	}
	if _, ok := raw["itemId"]; raw != nil && !ok {
		return fmt.Errorf("field itemId in SmapleNFT: required")
	}
	if _, ok := raw["metadata"]; raw != nil && !ok {
		return fmt.Errorf("field metadata in SmapleNFT: required")
	}
	if _, ok := raw["tokenId"]; raw != nil && !ok {
		return fmt.Errorf("field tokenId in SmapleNFT: required")
	}
	type Plain SmapleNFT
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SmapleNFT(plain)
	return nil
}

type StartServerInput struct {
	// AgentCPU corresponds to the JSON schema field "agentCPU".
	AgentCPU int `json:"agentCPU" yaml:"agentCPU" mapstructure:"agentCPU"`

	// Args corresponds to the JSON schema field "args".
	Args string `json:"args" yaml:"args" mapstructure:"args"`

	// Envs corresponds to the JSON schema field "envs".
	Envs string `json:"envs" yaml:"envs" mapstructure:"envs"`

	// SceneCPU corresponds to the JSON schema field "sceneCPU".
	SceneCPU int `json:"sceneCPU" yaml:"sceneCPU" mapstructure:"sceneCPU"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StartServerInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["agentCPU"]; raw != nil && !ok {
		return fmt.Errorf("field agentCPU in StartServerInput: required")
	}
	if _, ok := raw["args"]; raw != nil && !ok {
		return fmt.Errorf("field args in StartServerInput: required")
	}
	if _, ok := raw["envs"]; raw != nil && !ok {
		return fmt.Errorf("field envs in StartServerInput: required")
	}
	if _, ok := raw["sceneCPU"]; raw != nil && !ok {
		return fmt.Errorf("field sceneCPU in StartServerInput: required")
	}
	type Plain StartServerInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = StartServerInput(plain)
	return nil
}

type StartServerOutput struct {
	// ServerAppId corresponds to the JSON schema field "serverAppId".
	ServerAppId string `json:"serverAppId" yaml:"serverAppId" mapstructure:"serverAppId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StartServerOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["serverAppId"]; raw != nil && !ok {
		return fmt.Errorf("field serverAppId in StartServerOutput: required")
	}
	type Plain StartServerOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = StartServerOutput(plain)
	return nil
}

type SubscriptionEvent string

const SubscriptionEventAccountMigrate SubscriptionEvent = "AccountMigrate"
const SubscriptionEventBatchBurnNFT SubscriptionEvent = "BatchBurnNFT"
const SubscriptionEventBatchMintNFT SubscriptionEvent = "BatchMintNFT"
const SubscriptionEventBatchTransferNFT SubscriptionEvent = "BatchTransferNFT"

type SubscriptionEventChannel string

type SubscriptionEventChannel2 string

const SubscriptionEventChannel2_HandleGameMessageCallback SubscriptionEventChannel2 = "HandleGameMessageCallback"

var enumValues_SubscriptionEventChannel2 = []interface{}{
	"HandleGameMessageCallback",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubscriptionEventChannel2) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SubscriptionEventChannel2 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SubscriptionEventChannel2, v)
	}
	*j = SubscriptionEventChannel2(v)
	return nil
}

const SubscriptionEventChannelPubsub SubscriptionEventChannel = "pubsub"
const SubscriptionEventChannelPubsub2 SubscriptionEventChannel = "pubsub2"

var enumValues_SubscriptionEventChannel = []interface{}{
	"pubsub",
	"pubsub2",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubscriptionEventChannel) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SubscriptionEventChannel {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SubscriptionEventChannel, v)
	}
	*j = SubscriptionEventChannel(v)
	return nil
}

const SubscriptionEventCloseServer SubscriptionEvent = "CloseServer"
const SubscriptionEventDispatchGameMessage SubscriptionEvent = "DispatchGameMessage"
const SubscriptionEventDistributeDungeonBonus SubscriptionEvent = "DistributeDungeonBonus"
const SubscriptionEventDungeonPVEPStart SubscriptionEvent = "DungeonPVEPStart"
const SubscriptionEventDungeonStartPVEPCallback SubscriptionEvent = "DungeonStartPVEPCallback"
const SubscriptionEventEnhanceEquipmentEvent SubscriptionEvent = "EnhanceEquipmentEvent"
const SubscriptionEventMintNFTWithAttributes SubscriptionEvent = "MintNFTWithAttributes"
const SubscriptionEventMultiBuildUpdateEvent SubscriptionEvent = "MultiBuildUpdateEvent"
const SubscriptionEventMultiLandDataUpdateEvent SubscriptionEvent = "MultiLandDataUpdateEvent"
const SubscriptionEventMultiRecyclingEvent SubscriptionEvent = "MultiRecyclingEvent"
const SubscriptionEventMultiUpdateUserNFT SubscriptionEvent = "MultiUpdateUserNFT"
const SubscriptionEventMultiUpdateUserOnchainNFT SubscriptionEvent = "MultiUpdateUserOnchainNFT"
const SubscriptionEventMultiUpdateUserRoninchainNFT SubscriptionEvent = "MultiUpdateUserRoninchainNFT"
const SubscriptionEventPlayerDeath SubscriptionEvent = "PlayerDeath"
const SubscriptionEventPlayerKilled SubscriptionEvent = "PlayerKilled"
const SubscriptionEventPlayerReborn SubscriptionEvent = "PlayerReborn"
const SubscriptionEventRaffleDrawEvent SubscriptionEvent = "RaffleDrawEvent"
const SubscriptionEventRecycleWorldTotemEvent SubscriptionEvent = "RecycleWorldTotemEvent"
const SubscriptionEventUnloadEquipment SubscriptionEvent = "UnloadEquipment"
const SubscriptionEventUpdateTotemInvestData SubscriptionEvent = "UpdateTotemInvestData"
const SubscriptionEventUpdateTowerRafflePool SubscriptionEvent = "UpdateTowerRafflePool"
const SubscriptionEventUpdateUpcomingUses SubscriptionEvent = "UpdateUpcomingUses"
const SubscriptionEventUseEquipment SubscriptionEvent = "UseEquipment"
const SubscriptionEventUseLUAUSD SubscriptionEvent = "UseLUAUSD"
const SubscriptionEventWorldTotemPoolUpdateEvent SubscriptionEvent = "WorldTotemPoolUpdateEvent"

var enumValues_SubscriptionEvent = []interface{}{
	"AccountMigrate",
	"BatchBurnNFT",
	"BatchMintNFT",
	"BatchTransferNFT",
	"CloseServer",
	"DispatchGameMessage",
	"DistributeDungeonBonus",
	"DungeonPVEPStart",
	"DungeonStartPVEPCallback",
	"EnhanceEquipmentEvent",
	"MintNFTWithAttributes",
	"MultiBuildUpdateEvent",
	"MultiLandDataUpdateEvent",
	"MultiRecyclingEvent",
	"MultiUpdateUserNFT",
	"MultiUpdateUserOnchainNFT",
	"MultiUpdateUserRoninchainNFT",
	"PlayerDeath",
	"PlayerKilled",
	"PlayerReborn",
	"RaffleDrawEvent",
	"RecycleWorldTotemEvent",
	"UnloadEquipment",
	"UpdateTotemInvestData",
	"UpdateTowerRafflePool",
	"UpdateUpcomingUses",
	"UseEquipment",
	"UseLUAUSD",
	"WorldTotemPoolUpdateEvent",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubscriptionEvent) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SubscriptionEvent {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SubscriptionEvent, v)
	}
	*j = SubscriptionEvent(v)
	return nil
}

type TaskPool struct {
	// BasicBonus corresponds to the JSON schema field "basicBonus".
	BasicBonus string `json:"basicBonus" yaml:"basicBonus" mapstructure:"basicBonus"`

	// BasicTotalBonus corresponds to the JSON schema field "basicTotalBonus".
	BasicTotalBonus string `json:"basicTotalBonus" yaml:"basicTotalBonus" mapstructure:"basicTotalBonus"`

	// Created corresponds to the JSON schema field "created".
	Created bool `json:"created" yaml:"created" mapstructure:"created"`

	// FloatBonusPrecent corresponds to the JSON schema field "floatBonusPrecent".
	FloatBonusPrecent int `json:"floatBonusPrecent" yaml:"floatBonusPrecent" mapstructure:"floatBonusPrecent"`

	// Id corresponds to the JSON schema field "id".
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// LevelRangeIdx corresponds to the JSON schema field "levelRangeIdx".
	LevelRangeIdx int `json:"levelRangeIdx" yaml:"levelRangeIdx" mapstructure:"levelRangeIdx"`

	// Luag1BasicBonus corresponds to the JSON schema field "luag1BasicBonus".
	Luag1BasicBonus int `json:"luag1BasicBonus" yaml:"luag1BasicBonus" mapstructure:"luag1BasicBonus"`

	// Luag1TokenTotal corresponds to the JSON schema field "luag1TokenTotal".
	Luag1TokenTotal int `json:"luag1TokenTotal" yaml:"luag1TokenTotal" mapstructure:"luag1TokenTotal"`

	// PoolExpireTime corresponds to the JSON schema field "poolExpireTime".
	PoolExpireTime int `json:"poolExpireTime" yaml:"poolExpireTime" mapstructure:"poolExpireTime"`

	// RaffleTaskTicketItemId corresponds to the JSON schema field
	// "raffleTaskTicketItemId".
	RaffleTaskTicketItemId string `json:"raffleTaskTicketItemId" yaml:"raffleTaskTicketItemId" mapstructure:"raffleTaskTicketItemId"`

	// RaffleTaskTicketNFTId corresponds to the JSON schema field
	// "raffleTaskTicketNFTId".
	RaffleTaskTicketNFTId string `json:"raffleTaskTicketNFTId" yaml:"raffleTaskTicketNFTId" mapstructure:"raffleTaskTicketNFTId"`

	// RaffleTicketBase corresponds to the JSON schema field "raffleTicketBase".
	RaffleTicketBase int `json:"raffleTicketBase" yaml:"raffleTicketBase" mapstructure:"raffleTicketBase"`

	// RaffleTicketItemId corresponds to the JSON schema field "raffleTicketItemId".
	RaffleTicketItemId string `json:"raffleTicketItemId" yaml:"raffleTicketItemId" mapstructure:"raffleTicketItemId"`

	// RaffleTicketTotal corresponds to the JSON schema field "raffleTicketTotal".
	RaffleTicketTotal int `json:"raffleTicketTotal" yaml:"raffleTicketTotal" mapstructure:"raffleTicketTotal"`

	// RefreshNFTId corresponds to the JSON schema field "refreshNFTId".
	RefreshNFTId string `json:"refreshNFTId" yaml:"refreshNFTId" mapstructure:"refreshNFTId"`

	// RefreshNFTItemId corresponds to the JSON schema field "refreshNFTItemId".
	RefreshNFTItemId string `json:"refreshNFTItemId" yaml:"refreshNFTItemId" mapstructure:"refreshNFTItemId"`

	// RemainBonus corresponds to the JSON schema field "remainBonus".
	RemainBonus string `json:"remainBonus" yaml:"remainBonus" mapstructure:"remainBonus"`

	// Talent corresponds to the JSON schema field "talent".
	Talent int `json:"talent" yaml:"talent" mapstructure:"talent"`

	// TaskTicketMintKPrecent corresponds to the JSON schema field
	// "taskTicketMintKPrecent".
	TaskTicketMintKPrecent int `json:"taskTicketMintKPrecent" yaml:"taskTicketMintKPrecent" mapstructure:"taskTicketMintKPrecent"`

	// TicketExpireTime corresponds to the JSON schema field "ticketExpireTime".
	TicketExpireTime int `json:"ticketExpireTime" yaml:"ticketExpireTime" mapstructure:"ticketExpireTime"`

	// TopTotalBonus corresponds to the JSON schema field "topTotalBonus".
	TopTotalBonus string `json:"topTotalBonus" yaml:"topTotalBonus" mapstructure:"topTotalBonus"`

	// Type corresponds to the JSON schema field "type".
	Type int `json:"type" yaml:"type" mapstructure:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TaskPool) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["basicBonus"]; raw != nil && !ok {
		return fmt.Errorf("field basicBonus in TaskPool: required")
	}
	if _, ok := raw["basicTotalBonus"]; raw != nil && !ok {
		return fmt.Errorf("field basicTotalBonus in TaskPool: required")
	}
	if _, ok := raw["created"]; raw != nil && !ok {
		return fmt.Errorf("field created in TaskPool: required")
	}
	if _, ok := raw["floatBonusPrecent"]; raw != nil && !ok {
		return fmt.Errorf("field floatBonusPrecent in TaskPool: required")
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in TaskPool: required")
	}
	if _, ok := raw["levelRangeIdx"]; raw != nil && !ok {
		return fmt.Errorf("field levelRangeIdx in TaskPool: required")
	}
	if _, ok := raw["luag1BasicBonus"]; raw != nil && !ok {
		return fmt.Errorf("field luag1BasicBonus in TaskPool: required")
	}
	if _, ok := raw["luag1TokenTotal"]; raw != nil && !ok {
		return fmt.Errorf("field luag1TokenTotal in TaskPool: required")
	}
	if _, ok := raw["poolExpireTime"]; raw != nil && !ok {
		return fmt.Errorf("field poolExpireTime in TaskPool: required")
	}
	if _, ok := raw["raffleTaskTicketItemId"]; raw != nil && !ok {
		return fmt.Errorf("field raffleTaskTicketItemId in TaskPool: required")
	}
	if _, ok := raw["raffleTaskTicketNFTId"]; raw != nil && !ok {
		return fmt.Errorf("field raffleTaskTicketNFTId in TaskPool: required")
	}
	if _, ok := raw["raffleTicketBase"]; raw != nil && !ok {
		return fmt.Errorf("field raffleTicketBase in TaskPool: required")
	}
	if _, ok := raw["raffleTicketItemId"]; raw != nil && !ok {
		return fmt.Errorf("field raffleTicketItemId in TaskPool: required")
	}
	if _, ok := raw["raffleTicketTotal"]; raw != nil && !ok {
		return fmt.Errorf("field raffleTicketTotal in TaskPool: required")
	}
	if _, ok := raw["refreshNFTId"]; raw != nil && !ok {
		return fmt.Errorf("field refreshNFTId in TaskPool: required")
	}
	if _, ok := raw["refreshNFTItemId"]; raw != nil && !ok {
		return fmt.Errorf("field refreshNFTItemId in TaskPool: required")
	}
	if _, ok := raw["remainBonus"]; raw != nil && !ok {
		return fmt.Errorf("field remainBonus in TaskPool: required")
	}
	if _, ok := raw["talent"]; raw != nil && !ok {
		return fmt.Errorf("field talent in TaskPool: required")
	}
	if _, ok := raw["taskTicketMintKPrecent"]; raw != nil && !ok {
		return fmt.Errorf("field taskTicketMintKPrecent in TaskPool: required")
	}
	if _, ok := raw["ticketExpireTime"]; raw != nil && !ok {
		return fmt.Errorf("field ticketExpireTime in TaskPool: required")
	}
	if _, ok := raw["topTotalBonus"]; raw != nil && !ok {
		return fmt.Errorf("field topTotalBonus in TaskPool: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in TaskPool: required")
	}
	type Plain TaskPool
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TaskPool(plain)
	return nil
}

type TemporaryToken struct {
	// CreatedAt corresponds to the JSON schema field "createdAt".
	CreatedAt time.Time `json:"createdAt" yaml:"createdAt" mapstructure:"createdAt"`

	// ExpiredAt corresponds to the JSON schema field "expiredAt".
	ExpiredAt time.Time `json:"expiredAt" yaml:"expiredAt" mapstructure:"expiredAt"`

	// Id corresponds to the JSON schema field "id".
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// TemporaryTokenExtraInfo corresponds to the JSON schema field
	// "temporaryTokenExtraInfo".
	TemporaryTokenExtraInfo *TemporaryTokenExtraInfo `json:"temporaryTokenExtraInfo,omitempty" yaml:"temporaryTokenExtraInfo,omitempty" mapstructure:"temporaryTokenExtraInfo,omitempty"`

	// Token corresponds to the JSON schema field "token".
	Token string `json:"token" yaml:"token" mapstructure:"token"`

	// UpdatedAt corresponds to the JSON schema field "updatedAt".
	UpdatedAt time.Time `json:"updatedAt" yaml:"updatedAt" mapstructure:"updatedAt"`

	// UsedAt corresponds to the JSON schema field "usedAt".
	UsedAt *time.Time `json:"usedAt,omitempty" yaml:"usedAt,omitempty" mapstructure:"usedAt,omitempty"`
}

type TemporaryTokenExtraInfo struct {
	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TemporaryTokenExtraInfo) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in TemporaryTokenExtraInfo: required")
	}
	type Plain TemporaryTokenExtraInfo
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TemporaryTokenExtraInfo(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TemporaryToken) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["createdAt"]; raw != nil && !ok {
		return fmt.Errorf("field createdAt in TemporaryToken: required")
	}
	if _, ok := raw["expiredAt"]; raw != nil && !ok {
		return fmt.Errorf("field expiredAt in TemporaryToken: required")
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in TemporaryToken: required")
	}
	if _, ok := raw["token"]; raw != nil && !ok {
		return fmt.Errorf("field token in TemporaryToken: required")
	}
	if _, ok := raw["updatedAt"]; raw != nil && !ok {
		return fmt.Errorf("field updatedAt in TemporaryToken: required")
	}
	type Plain TemporaryToken
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TemporaryToken(plain)
	return nil
}

type TotemInvestData struct {
	// BaseLP corresponds to the JSON schema field "baseLP".
	BaseLP string `json:"baseLP" yaml:"baseLP" mapstructure:"baseLP"`

	// BaseLPRadio corresponds to the JSON schema field "baseLPRadio".
	BaseLPRadio int `json:"baseLPRadio" yaml:"baseLPRadio" mapstructure:"baseLPRadio"`

	// ClaimableReward corresponds to the JSON schema field "claimableReward".
	ClaimableReward string `json:"claimableReward" yaml:"claimableReward" mapstructure:"claimableReward"`

	// DungeonId corresponds to the JSON schema field "dungeonId".
	DungeonId int `json:"dungeonId" yaml:"dungeonId" mapstructure:"dungeonId"`

	// RewardLP corresponds to the JSON schema field "rewardLP".
	RewardLP string `json:"rewardLP" yaml:"rewardLP" mapstructure:"rewardLP"`

	// RewardLPRadio corresponds to the JSON schema field "rewardLPRadio".
	RewardLPRadio int `json:"rewardLPRadio" yaml:"rewardLPRadio" mapstructure:"rewardLPRadio"`

	// TotemNFTId corresponds to the JSON schema field "totemNFTId".
	TotemNFTId string `json:"totemNFTId" yaml:"totemNFTId" mapstructure:"totemNFTId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TotemInvestData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["baseLP"]; raw != nil && !ok {
		return fmt.Errorf("field baseLP in TotemInvestData: required")
	}
	if _, ok := raw["baseLPRadio"]; raw != nil && !ok {
		return fmt.Errorf("field baseLPRadio in TotemInvestData: required")
	}
	if _, ok := raw["claimableReward"]; raw != nil && !ok {
		return fmt.Errorf("field claimableReward in TotemInvestData: required")
	}
	if _, ok := raw["dungeonId"]; raw != nil && !ok {
		return fmt.Errorf("field dungeonId in TotemInvestData: required")
	}
	if _, ok := raw["rewardLP"]; raw != nil && !ok {
		return fmt.Errorf("field rewardLP in TotemInvestData: required")
	}
	if _, ok := raw["rewardLPRadio"]; raw != nil && !ok {
		return fmt.Errorf("field rewardLPRadio in TotemInvestData: required")
	}
	if _, ok := raw["totemNFTId"]; raw != nil && !ok {
		return fmt.Errorf("field totemNFTId in TotemInvestData: required")
	}
	type Plain TotemInvestData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TotemInvestData(plain)
	return nil
}

type TotemTraitRarity string

const TotemTraitRarityA TotemTraitRarity = "A"
const TotemTraitRarityB TotemTraitRarity = "B"
const TotemTraitRarityC TotemTraitRarity = "C"
const TotemTraitRarityD TotemTraitRarity = "D"
const TotemTraitRarityE TotemTraitRarity = "E"

var enumValues_TotemTraitRarity = []interface{}{
	"A",
	"B",
	"C",
	"D",
	"E",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TotemTraitRarity) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TotemTraitRarity {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TotemTraitRarity, v)
	}
	*j = TotemTraitRarity(v)
	return nil
}

type TowerRafflePoolData struct {
	// BonusTotal corresponds to the JSON schema field "bonusTotal".
	BonusTotal string `json:"bonusTotal" yaml:"bonusTotal" mapstructure:"bonusTotal"`

	// ExpireTime corresponds to the JSON schema field "expireTime".
	ExpireTime int `json:"expireTime" yaml:"expireTime" mapstructure:"expireTime"`

	// Id corresponds to the JSON schema field "id".
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// index和itemIds一一对应
	// 所有数量
	ItemAmounts []int `json:"itemAmounts" yaml:"itemAmounts" mapstructure:"itemAmounts"`

	// ItemIds corresponds to the JSON schema field "itemIds".
	ItemIds []int `json:"itemIds" yaml:"itemIds" mapstructure:"itemIds"`

	// SceneAreaId corresponds to the JSON schema field "sceneAreaId".
	SceneAreaId string `json:"sceneAreaId" yaml:"sceneAreaId" mapstructure:"sceneAreaId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TowerRafflePoolData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["bonusTotal"]; raw != nil && !ok {
		return fmt.Errorf("field bonusTotal in TowerRafflePoolData: required")
	}
	if _, ok := raw["expireTime"]; raw != nil && !ok {
		return fmt.Errorf("field expireTime in TowerRafflePoolData: required")
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in TowerRafflePoolData: required")
	}
	if _, ok := raw["itemAmounts"]; raw != nil && !ok {
		return fmt.Errorf("field itemAmounts in TowerRafflePoolData: required")
	}
	if _, ok := raw["itemIds"]; raw != nil && !ok {
		return fmt.Errorf("field itemIds in TowerRafflePoolData: required")
	}
	if _, ok := raw["sceneAreaId"]; raw != nil && !ok {
		return fmt.Errorf("field sceneAreaId in TowerRafflePoolData: required")
	}
	type Plain TowerRafflePoolData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TowerRafflePoolData(plain)
	return nil
}

type TowerRafflePoolRecordStatus string

const TowerRafflePoolRecordStatusFail TowerRafflePoolRecordStatus = "fail"
const TowerRafflePoolRecordStatusPending TowerRafflePoolRecordStatus = "pending"
const TowerRafflePoolRecordStatusSuccess TowerRafflePoolRecordStatus = "success"

var enumValues_TowerRafflePoolRecordStatus = []interface{}{
	"fail",
	"pending",
	"success",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TowerRafflePoolRecordStatus) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TowerRafflePoolRecordStatus {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TowerRafflePoolRecordStatus, v)
	}
	*j = TowerRafflePoolRecordStatus(v)
	return nil
}

type TowerRafflePoolRecordType string

const TowerRafflePoolRecordTypeCharge TowerRafflePoolRecordType = "charge"
const TowerRafflePoolRecordTypeCreate TowerRafflePoolRecordType = "create"
const TowerRafflePoolRecordTypePrize TowerRafflePoolRecordType = "prize"
const TowerRafflePoolRecordTypeReset TowerRafflePoolRecordType = "reset"

var enumValues_TowerRafflePoolRecordType = []interface{}{
	"charge",
	"create",
	"prize",
	"reset",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TowerRafflePoolRecordType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TowerRafflePoolRecordType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TowerRafflePoolRecordType, v)
	}
	*j = TowerRafflePoolRecordType(v)
	return nil
}

type TowerRafflePoolStatus string

const TowerRafflePoolStatusClose TowerRafflePoolStatus = "close"
const TowerRafflePoolStatusOpen TowerRafflePoolStatus = "open"
const TowerRafflePoolStatusPending TowerRafflePoolStatus = "pending"

var enumValues_TowerRafflePoolStatus = []interface{}{
	"close",
	"open",
	"pending",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TowerRafflePoolStatus) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TowerRafflePoolStatus {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TowerRafflePoolStatus, v)
	}
	*j = TowerRafflePoolStatus(v)
	return nil
}

type TransferLUAInput struct {
	// Amount corresponds to the JSON schema field "amount".
	Amount string `json:"amount" yaml:"amount" mapstructure:"amount"`

	// FromUserId corresponds to the JSON schema field "fromUserId".
	FromUserId string `json:"fromUserId" yaml:"fromUserId" mapstructure:"fromUserId"`

	// 转移备注
	Remark string `json:"remark" yaml:"remark" mapstructure:"remark"`

	// ToUserId corresponds to the JSON schema field "toUserId".
	ToUserId string `json:"toUserId" yaml:"toUserId" mapstructure:"toUserId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TransferLUAInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["amount"]; raw != nil && !ok {
		return fmt.Errorf("field amount in TransferLUAInput: required")
	}
	if _, ok := raw["fromUserId"]; raw != nil && !ok {
		return fmt.Errorf("field fromUserId in TransferLUAInput: required")
	}
	if _, ok := raw["remark"]; raw != nil && !ok {
		return fmt.Errorf("field remark in TransferLUAInput: required")
	}
	if _, ok := raw["toUserId"]; raw != nil && !ok {
		return fmt.Errorf("field toUserId in TransferLUAInput: required")
	}
	type Plain TransferLUAInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TransferLUAInput(plain)
	return nil
}

type TransferLUAOutput struct {
	// FailedReason corresponds to the JSON schema field "failedReason".
	FailedReason string `json:"failedReason" yaml:"failedReason" mapstructure:"failedReason"`

	// Success corresponds to the JSON schema field "success".
	Success bool `json:"success" yaml:"success" mapstructure:"success"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TransferLUAOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["failedReason"]; raw != nil && !ok {
		return fmt.Errorf("field failedReason in TransferLUAOutput: required")
	}
	if _, ok := raw["success"]; raw != nil && !ok {
		return fmt.Errorf("field success in TransferLUAOutput: required")
	}
	type Plain TransferLUAOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TransferLUAOutput(plain)
	return nil
}

type UnloadEquipment struct {
	// NftId corresponds to the JSON schema field "nftId".
	NftId string `json:"nftId" yaml:"nftId" mapstructure:"nftId"`

	// 游戏角色id
	PlayerId string `json:"playerId" yaml:"playerId" mapstructure:"playerId"`

	// 用户id
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UnloadEquipment) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["nftId"]; raw != nil && !ok {
		return fmt.Errorf("field nftId in UnloadEquipment: required")
	}
	if _, ok := raw["playerId"]; raw != nil && !ok {
		return fmt.Errorf("field playerId in UnloadEquipment: required")
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in UnloadEquipment: required")
	}
	type Plain UnloadEquipment
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UnloadEquipment(plain)
	return nil
}

type UpdateTotemInvestData struct {
	// Data corresponds to the JSON schema field "data".
	Data TotemInvestData `json:"data" yaml:"data" mapstructure:"data"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UpdateTotemInvestData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["data"]; raw != nil && !ok {
		return fmt.Errorf("field data in UpdateTotemInvestData: required")
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in UpdateTotemInvestData: required")
	}
	type Plain UpdateTotemInvestData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UpdateTotemInvestData(plain)
	return nil
}

type UpdateTowerRafflePoolEvent struct {
	// Pools corresponds to the JSON schema field "pools".
	Pools []TowerRafflePoolData `json:"pools" yaml:"pools" mapstructure:"pools"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UpdateTowerRafflePoolEvent) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["pools"]; raw != nil && !ok {
		return fmt.Errorf("field pools in UpdateTowerRafflePoolEvent: required")
	}
	type Plain UpdateTowerRafflePoolEvent
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UpdateTowerRafflePoolEvent(plain)
	return nil
}

type UpdateUpcomingUses struct {
	// Number corresponds to the JSON schema field "number".
	Number int `json:"number" yaml:"number" mapstructure:"number"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UpdateUpcomingUses) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["number"]; raw != nil && !ok {
		return fmt.Errorf("field number in UpdateUpcomingUses: required")
	}
	type Plain UpdateUpcomingUses
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UpdateUpcomingUses(plain)
	return nil
}

type UpgradePlayerItemSlotsInput struct {
	// ItemSlots corresponds to the JSON schema field "itemSlots".
	ItemSlots []PlayerItemSlot `json:"itemSlots" yaml:"itemSlots" mapstructure:"itemSlots"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UpgradePlayerItemSlotsInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["itemSlots"]; raw != nil && !ok {
		return fmt.Errorf("field itemSlots in UpgradePlayerItemSlotsInput: required")
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in UpgradePlayerItemSlotsInput: required")
	}
	type Plain UpgradePlayerItemSlotsInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UpgradePlayerItemSlotsInput(plain)
	return nil
}

type UpgradePlayerItemSlotsOutput struct {
	// 是否成功
	Success bool `json:"success" yaml:"success" mapstructure:"success"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UpgradePlayerItemSlotsOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["success"]; raw != nil && !ok {
		return fmt.Errorf("field success in UpgradePlayerItemSlotsOutput: required")
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in UpgradePlayerItemSlotsOutput: required")
	}
	type Plain UpgradePlayerItemSlotsOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UpgradePlayerItemSlotsOutput(plain)
	return nil
}

type UseEquipment struct {
	// 装备位置 对时装和装备有效
	AvatarPos int `json:"avatarPos" yaml:"avatarPos" mapstructure:"avatarPos"`

	// Cid corresponds to the JSON schema field "cid".
	Cid int `json:"cid" yaml:"cid" mapstructure:"cid"`

	// NftId corresponds to the JSON schema field "nftId".
	NftId string `json:"nftId" yaml:"nftId" mapstructure:"nftId"`

	// 游戏角色id
	PlayerId string `json:"playerId" yaml:"playerId" mapstructure:"playerId"`

	// 用户id
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UseEquipment) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["avatarPos"]; raw != nil && !ok {
		return fmt.Errorf("field avatarPos in UseEquipment: required")
	}
	if _, ok := raw["cid"]; raw != nil && !ok {
		return fmt.Errorf("field cid in UseEquipment: required")
	}
	if _, ok := raw["nftId"]; raw != nil && !ok {
		return fmt.Errorf("field nftId in UseEquipment: required")
	}
	if _, ok := raw["playerId"]; raw != nil && !ok {
		return fmt.Errorf("field playerId in UseEquipment: required")
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in UseEquipment: required")
	}
	type Plain UseEquipment
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UseEquipment(plain)
	return nil
}

type UseGameTokenByUSDAmountInput struct {
	// GameTokenPrice corresponds to the JSON schema field "gameTokenPrice".
	GameTokenPrice string `json:"gameTokenPrice" yaml:"gameTokenPrice" mapstructure:"gameTokenPrice"`

	// Remark corresponds to the JSON schema field "remark".
	Remark string `json:"remark" yaml:"remark" mapstructure:"remark"`

	// UsdAmount corresponds to the JSON schema field "usdAmount".
	UsdAmount string `json:"usdAmount" yaml:"usdAmount" mapstructure:"usdAmount"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UseGameTokenByUSDAmountInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["gameTokenPrice"]; raw != nil && !ok {
		return fmt.Errorf("field gameTokenPrice in UseGameTokenByUSDAmountInput: required")
	}
	if _, ok := raw["remark"]; raw != nil && !ok {
		return fmt.Errorf("field remark in UseGameTokenByUSDAmountInput: required")
	}
	if _, ok := raw["usdAmount"]; raw != nil && !ok {
		return fmt.Errorf("field usdAmount in UseGameTokenByUSDAmountInput: required")
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in UseGameTokenByUSDAmountInput: required")
	}
	type Plain UseGameTokenByUSDAmountInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UseGameTokenByUSDAmountInput(plain)
	return nil
}

type UseGameTokenByUSDAmountOutput struct {
	// DeductedGameTokenAmount corresponds to the JSON schema field
	// "deductedGameTokenAmount".
	DeductedGameTokenAmount string `json:"deductedGameTokenAmount" yaml:"deductedGameTokenAmount" mapstructure:"deductedGameTokenAmount"`

	// FailedReason corresponds to the JSON schema field "failedReason".
	FailedReason string `json:"failedReason" yaml:"failedReason" mapstructure:"failedReason"`

	// GameMessageId corresponds to the JSON schema field "gameMessageId".
	GameMessageId string `json:"gameMessageId" yaml:"gameMessageId" mapstructure:"gameMessageId"`

	// Success corresponds to the JSON schema field "success".
	Success bool `json:"success" yaml:"success" mapstructure:"success"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UseGameTokenByUSDAmountOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["deductedGameTokenAmount"]; raw != nil && !ok {
		return fmt.Errorf("field deductedGameTokenAmount in UseGameTokenByUSDAmountOutput: required")
	}
	if _, ok := raw["failedReason"]; raw != nil && !ok {
		return fmt.Errorf("field failedReason in UseGameTokenByUSDAmountOutput: required")
	}
	if _, ok := raw["gameMessageId"]; raw != nil && !ok {
		return fmt.Errorf("field gameMessageId in UseGameTokenByUSDAmountOutput: required")
	}
	if _, ok := raw["success"]; raw != nil && !ok {
		return fmt.Errorf("field success in UseGameTokenByUSDAmountOutput: required")
	}
	type Plain UseGameTokenByUSDAmountOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UseGameTokenByUSDAmountOutput(plain)
	return nil
}

type UseLUAUSD struct {
	// 消耗的金额
	// decimal 18
	Amount string `json:"amount" yaml:"amount" mapstructure:"amount"`

	// 每个用户的消耗备注
	Remark string `json:"remark" yaml:"remark" mapstructure:"remark"`

	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UseLUAUSD) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["amount"]; raw != nil && !ok {
		return fmt.Errorf("field amount in UseLUAUSD: required")
	}
	if _, ok := raw["remark"]; raw != nil && !ok {
		return fmt.Errorf("field remark in UseLUAUSD: required")
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in UseLUAUSD: required")
	}
	type Plain UseLUAUSD
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UseLUAUSD(plain)
	return nil
}

type User struct {
	// Avatar corresponds to the JSON schema field "avatar".
	Avatar string `json:"avatar" yaml:"avatar" mapstructure:"avatar"`

	// Email corresponds to the JSON schema field "email".
	Email string `json:"email" yaml:"email" mapstructure:"email"`

	// Id corresponds to the JSON schema field "id".
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// Mobile corresponds to the JSON schema field "mobile".
	Mobile string `json:"mobile" yaml:"mobile" mapstructure:"mobile"`

	// Nickname corresponds to the JSON schema field "nickname".
	Nickname string `json:"nickname" yaml:"nickname" mapstructure:"nickname"`

	// Realname corresponds to the JSON schema field "realname".
	Realname string `json:"realname" yaml:"realname" mapstructure:"realname"`

	// SchoolId corresponds to the JSON schema field "schoolId".
	SchoolId string `json:"schoolId" yaml:"schoolId" mapstructure:"schoolId"`

	// Sex corresponds to the JSON schema field "sex".
	Sex Sex `json:"sex" yaml:"sex" mapstructure:"sex"`

	// Username corresponds to the JSON schema field "username".
	Username string `json:"username" yaml:"username" mapstructure:"username"`

	// Usertype corresponds to the JSON schema field "usertype".
	Usertype UserType `json:"usertype" yaml:"usertype" mapstructure:"usertype"`
}

type UserType string

const UserTypeMANAGER UserType = "MANAGER"
const UserTypeSTUDENT UserType = "STUDENT"
const UserTypeTEACHER UserType = "TEACHER"

var enumValues_UserType = []interface{}{
	"MANAGER",
	"STUDENT",
	"TEACHER",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UserType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_UserType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_UserType, v)
	}
	*j = UserType(v)
	return nil
}

type UserUsingNft struct {
	// UserId corresponds to the JSON schema field "userId".
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`

	// UsingNfts corresponds to the JSON schema field "usingNfts".
	UsingNfts []UsingNFT `json:"usingNfts" yaml:"usingNfts" mapstructure:"usingNfts"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UserUsingNft) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in UserUsingNft: required")
	}
	if _, ok := raw["usingNfts"]; raw != nil && !ok {
		return fmt.Errorf("field usingNfts in UserUsingNft: required")
	}
	type Plain UserUsingNft
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UserUsingNft(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *User) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["avatar"]; raw != nil && !ok {
		return fmt.Errorf("field avatar in User: required")
	}
	if _, ok := raw["email"]; raw != nil && !ok {
		return fmt.Errorf("field email in User: required")
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in User: required")
	}
	if _, ok := raw["mobile"]; raw != nil && !ok {
		return fmt.Errorf("field mobile in User: required")
	}
	if _, ok := raw["nickname"]; raw != nil && !ok {
		return fmt.Errorf("field nickname in User: required")
	}
	if _, ok := raw["realname"]; raw != nil && !ok {
		return fmt.Errorf("field realname in User: required")
	}
	if _, ok := raw["schoolId"]; raw != nil && !ok {
		return fmt.Errorf("field schoolId in User: required")
	}
	if _, ok := raw["sex"]; raw != nil && !ok {
		return fmt.Errorf("field sex in User: required")
	}
	if _, ok := raw["username"]; raw != nil && !ok {
		return fmt.Errorf("field username in User: required")
	}
	if _, ok := raw["usertype"]; raw != nil && !ok {
		return fmt.Errorf("field usertype in User: required")
	}
	type Plain User
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = User(plain)
	return nil
}

type UsingNFT struct {
	// 装备位置 对时装和装备有效
	AvatarPos int `json:"avatarPos" yaml:"avatarPos" mapstructure:"avatarPos"`

	// Cid corresponds to the JSON schema field "cid".
	Cid int `json:"cid" yaml:"cid" mapstructure:"cid"`

	// NftId corresponds to the JSON schema field "nftId".
	NftId string `json:"nftId" yaml:"nftId" mapstructure:"nftId"`

	// 游戏角色id
	PlayerId string `json:"playerId" yaml:"playerId" mapstructure:"playerId"`

	// 用户id
	UserId string `json:"userId" yaml:"userId" mapstructure:"userId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UsingNFT) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["avatarPos"]; raw != nil && !ok {
		return fmt.Errorf("field avatarPos in UsingNFT: required")
	}
	if _, ok := raw["cid"]; raw != nil && !ok {
		return fmt.Errorf("field cid in UsingNFT: required")
	}
	if _, ok := raw["nftId"]; raw != nil && !ok {
		return fmt.Errorf("field nftId in UsingNFT: required")
	}
	if _, ok := raw["playerId"]; raw != nil && !ok {
		return fmt.Errorf("field playerId in UsingNFT: required")
	}
	if _, ok := raw["userId"]; raw != nil && !ok {
		return fmt.Errorf("field userId in UsingNFT: required")
	}
	type Plain UsingNFT
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UsingNFT(plain)
	return nil
}

type Web3ServiceAction string

const Web3ServiceActionBatchBurnNFT Web3ServiceAction = "BatchBurnNFT"
const Web3ServiceActionBatchGetGameMessageStatus Web3ServiceAction = "BatchGetGameMessageStatus"
const Web3ServiceActionCheckMintNFTWithAttributes Web3ServiceAction = "CheckMintNFTWithAttributes"
const Web3ServiceActionCheckMultiBatchBurnNFT Web3ServiceAction = "CheckMultiBatchBurnNFT"
const Web3ServiceActionCheckMultiUseLUAUSD Web3ServiceAction = "CheckMultiUseLUAUSD"
const Web3ServiceActionConvertLUAOP Web3ServiceAction = "ConvertLUAOP"
const Web3ServiceActionConvertPTS Web3ServiceAction = "ConvertPTS"
const Web3ServiceActionDistributeLUAG1 Web3ServiceAction = "DistributeLUAG1"
const Web3ServiceActionDistributeLUAUSD Web3ServiceAction = "DistributeLUAUSD"
const Web3ServiceActionDivestDungeon Web3ServiceAction = "DivestDungeon"
const Web3ServiceActionEnhanceEquipment Web3ServiceAction = "EnhanceEquipment"
const Web3ServiceActionEnhanceEquipmentLog Web3ServiceAction = "EnhanceEquipmentLog"
const Web3ServiceActionEstimateDivestDungeon Web3ServiceAction = "EstimateDivestDungeon"
const Web3ServiceActionEstimateInvestDungeon Web3ServiceAction = "EstimateInvestDungeon"
const Web3ServiceActionExecGameMessage Web3ServiceAction = "ExecGameMessage"
const Web3ServiceActionExtractEquipment Web3ServiceAction = "ExtractEquipment"
const Web3ServiceActionFetchDungeonExtraDropPools Web3ServiceAction = "FetchDungeonExtraDropPools"
const Web3ServiceActionFetchTaskPools Web3ServiceAction = "FetchTaskPools"
const Web3ServiceActionFetchTaskUseNFTSupplyList Web3ServiceAction = "FetchTaskUseNFTSupplyList"
const Web3ServiceActionFindRaffleRrawLogs Web3ServiceAction = "FindRaffleRrawLogs"
const Web3ServiceActionGetAllDungeonInvestData Web3ServiceAction = "GetAllDungeonInvestData"
const Web3ServiceActionGetGameMessageStatusById Web3ServiceAction = "GetGameMessageStatusById"
const Web3ServiceActionGetGameTokenPrice Web3ServiceAction = "GetGameTokenPrice"
const Web3ServiceActionGetInvestHavestLogs Web3ServiceAction = "GetInvestHavestLogs"
const Web3ServiceActionGetRoninNFTMoveLogs Web3ServiceAction = "GetRoninNFTMoveLogs"
const Web3ServiceActionGetTowerRafflePool Web3ServiceAction = "GetTowerRafflePool"
const Web3ServiceActionGetUserAllTotemInvestData Web3ServiceAction = "GetUserAllTotemInvestData"
const Web3ServiceActionGetUserExternalNFTs Web3ServiceAction = "GetUserExternalNFTs"
const Web3ServiceActionGetUserMintOnChainCount Web3ServiceAction = "GetUserMintOnChainCount"
const Web3ServiceActionGetUserNFTsByUserIdAndAddress Web3ServiceAction = "GetUserNFTsByUserIdAndAddress"
const Web3ServiceActionGetUserOffchainNFTs Web3ServiceAction = "GetUserOffchainNFTs"
const Web3ServiceActionGetUserOnchainNFTs Web3ServiceAction = "GetUserOnchainNFTs"
const Web3ServiceActionGetUserRoninchainNFTs Web3ServiceAction = "GetUserRoninchainNFTs"
const Web3ServiceActionHavestDungeonInvestReward Web3ServiceAction = "HavestDungeonInvestReward"
const Web3ServiceActionInvestDungeon Web3ServiceAction = "InvestDungeon"
const Web3ServiceActionMergeByRecipe Web3ServiceAction = "MergeByRecipe"
const Web3ServiceActionMintTaskTicket Web3ServiceAction = "MintTaskTicket"
const Web3ServiceActionMintUserTowerReward Web3ServiceAction = "MintUserTowerReward"
const Web3ServiceActionMoveNFTToOnchain Web3ServiceAction = "MoveNFTToOnchain"
const Web3ServiceActionMoveNFTToRoninchain Web3ServiceAction = "MoveNFTToRoninchain"
const Web3ServiceActionMoveRoninchainToGame Web3ServiceAction = "MoveRoninchainToGame"
const Web3ServiceActionMultiGetWorldTotemPool Web3ServiceAction = "MultiGetWorldTotemPool"
const Web3ServiceActionRaffleDraw Web3ServiceAction = "RaffleDraw"
const Web3ServiceActionTransferLUA Web3ServiceAction = "TransferLUA"
const Web3ServiceActionUseGameTokenByUSDAmount Web3ServiceAction = "UseGameTokenByUSDAmount"
const Web3ServiceActionWorldTotemPoolDeposit Web3ServiceAction = "WorldTotemPoolDeposit"
const Web3ServiceActionWorldTotemPoolRedemption Web3ServiceAction = "WorldTotemPoolRedemption"

var enumValues_Web3ServiceAction = []interface{}{
	"BatchBurnNFT",
	"BatchGetGameMessageStatus",
	"CheckMintNFTWithAttributes",
	"CheckMultiBatchBurnNFT",
	"CheckMultiUseLUAUSD",
	"ConvertLUAOP",
	"ConvertPTS",
	"DistributeLUAG1",
	"DistributeLUAUSD",
	"DivestDungeon",
	"EnhanceEquipment",
	"EnhanceEquipmentLog",
	"EstimateDivestDungeon",
	"EstimateInvestDungeon",
	"ExecGameMessage",
	"ExtractEquipment",
	"FetchDungeonExtraDropPools",
	"FetchTaskPools",
	"FetchTaskUseNFTSupplyList",
	"FindRaffleRrawLogs",
	"GetAllDungeonInvestData",
	"GetGameMessageStatusById",
	"GetGameTokenPrice",
	"GetInvestHavestLogs",
	"GetRoninNFTMoveLogs",
	"GetTowerRafflePool",
	"GetUserAllTotemInvestData",
	"GetUserExternalNFTs",
	"GetUserMintOnChainCount",
	"GetUserNFTsByUserIdAndAddress",
	"GetUserOffchainNFTs",
	"GetUserOnchainNFTs",
	"GetUserRoninchainNFTs",
	"HavestDungeonInvestReward",
	"InvestDungeon",
	"MergeByRecipe",
	"MintTaskTicket",
	"MintUserTowerReward",
	"MoveNFTToOnchain",
	"MoveNFTToRoninchain",
	"MoveRoninchainToGame",
	"MultiGetWorldTotemPool",
	"RaffleDraw",
	"TransferLUA",
	"UseGameTokenByUSDAmount",
	"WorldTotemPoolDeposit",
	"WorldTotemPoolRedemption",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Web3ServiceAction) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Web3ServiceAction {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Web3ServiceAction, v)
	}
	*j = Web3ServiceAction(v)
	return nil
}

type WorldTotemData struct {
	// Energy corresponds to the JSON schema field "energy".
	Energy int `json:"energy" yaml:"energy" mapstructure:"energy"`

	// ItemId corresponds to the JSON schema field "itemId".
	ItemId int `json:"itemId" yaml:"itemId" mapstructure:"itemId"`

	// NftId corresponds to the JSON schema field "nftId".
	NftId string `json:"nftId" yaml:"nftId" mapstructure:"nftId"`

	// Owner corresponds to the JSON schema field "owner".
	Owner string `json:"owner" yaml:"owner" mapstructure:"owner"`

	// OwnerName corresponds to the JSON schema field "ownerName".
	OwnerName string `json:"ownerName" yaml:"ownerName" mapstructure:"ownerName"`

	// PriceRatio corresponds to the JSON schema field "priceRatio".
	PriceRatio int `json:"priceRatio" yaml:"priceRatio" mapstructure:"priceRatio"`

	// Quality corresponds to the JSON schema field "quality".
	Quality string `json:"quality" yaml:"quality" mapstructure:"quality"`

	// SceneAppId corresponds to the JSON schema field "sceneAppId".
	SceneAppId string `json:"sceneAppId" yaml:"sceneAppId" mapstructure:"sceneAppId"`

	// SuccessProbability corresponds to the JSON schema field "successProbability".
	SuccessProbability float64 `json:"successProbability" yaml:"successProbability" mapstructure:"successProbability"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WorldTotemData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["energy"]; raw != nil && !ok {
		return fmt.Errorf("field energy in WorldTotemData: required")
	}
	if _, ok := raw["itemId"]; raw != nil && !ok {
		return fmt.Errorf("field itemId in WorldTotemData: required")
	}
	if _, ok := raw["nftId"]; raw != nil && !ok {
		return fmt.Errorf("field nftId in WorldTotemData: required")
	}
	if _, ok := raw["owner"]; raw != nil && !ok {
		return fmt.Errorf("field owner in WorldTotemData: required")
	}
	if _, ok := raw["ownerName"]; raw != nil && !ok {
		return fmt.Errorf("field ownerName in WorldTotemData: required")
	}
	if _, ok := raw["priceRatio"]; raw != nil && !ok {
		return fmt.Errorf("field priceRatio in WorldTotemData: required")
	}
	if _, ok := raw["quality"]; raw != nil && !ok {
		return fmt.Errorf("field quality in WorldTotemData: required")
	}
	if _, ok := raw["sceneAppId"]; raw != nil && !ok {
		return fmt.Errorf("field sceneAppId in WorldTotemData: required")
	}
	if _, ok := raw["successProbability"]; raw != nil && !ok {
		return fmt.Errorf("field successProbability in WorldTotemData: required")
	}
	type Plain WorldTotemData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = WorldTotemData(plain)
	return nil
}

type WorldTotemPool struct {
	// EnhanceIncome corresponds to the JSON schema field "enhanceIncome".
	EnhanceIncome string `json:"enhanceIncome" yaml:"enhanceIncome" mapstructure:"enhanceIncome"`

	// Principal corresponds to the JSON schema field "principal".
	Principal string `json:"principal" yaml:"principal" mapstructure:"principal"`

	// Total corresponds to the JSON schema field "total".
	Total string `json:"total" yaml:"total" mapstructure:"total"`

	// TotemNftId corresponds to the JSON schema field "totemNftId".
	TotemNftId string `json:"totemNftId" yaml:"totemNftId" mapstructure:"totemNftId"`

	// TotemOwner corresponds to the JSON schema field "totemOwner".
	TotemOwner string `json:"totemOwner" yaml:"totemOwner" mapstructure:"totemOwner"`
}

type WorldTotemPoolDepositInput struct {
	// DepositAmount corresponds to the JSON schema field "depositAmount".
	DepositAmount string `json:"depositAmount" yaml:"depositAmount" mapstructure:"depositAmount"`

	// TotemNftId corresponds to the JSON schema field "totemNftId".
	TotemNftId string `json:"totemNftId" yaml:"totemNftId" mapstructure:"totemNftId"`

	// TotemOwnerId corresponds to the JSON schema field "totemOwnerId".
	TotemOwnerId string `json:"totemOwnerId" yaml:"totemOwnerId" mapstructure:"totemOwnerId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WorldTotemPoolDepositInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["depositAmount"]; raw != nil && !ok {
		return fmt.Errorf("field depositAmount in WorldTotemPoolDepositInput: required")
	}
	if _, ok := raw["totemNftId"]; raw != nil && !ok {
		return fmt.Errorf("field totemNftId in WorldTotemPoolDepositInput: required")
	}
	if _, ok := raw["totemOwnerId"]; raw != nil && !ok {
		return fmt.Errorf("field totemOwnerId in WorldTotemPoolDepositInput: required")
	}
	type Plain WorldTotemPoolDepositInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = WorldTotemPoolDepositInput(plain)
	return nil
}

type WorldTotemPoolDepositOutput struct {
	// FailedReason corresponds to the JSON schema field "failedReason".
	FailedReason string `json:"failedReason" yaml:"failedReason" mapstructure:"failedReason"`

	// PoolData corresponds to the JSON schema field "poolData".
	PoolData WorldTotemPool `json:"poolData" yaml:"poolData" mapstructure:"poolData"`

	// Success corresponds to the JSON schema field "success".
	Success bool `json:"success" yaml:"success" mapstructure:"success"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WorldTotemPoolDepositOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["failedReason"]; raw != nil && !ok {
		return fmt.Errorf("field failedReason in WorldTotemPoolDepositOutput: required")
	}
	if _, ok := raw["poolData"]; raw != nil && !ok {
		return fmt.Errorf("field poolData in WorldTotemPoolDepositOutput: required")
	}
	if _, ok := raw["success"]; raw != nil && !ok {
		return fmt.Errorf("field success in WorldTotemPoolDepositOutput: required")
	}
	type Plain WorldTotemPoolDepositOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = WorldTotemPoolDepositOutput(plain)
	return nil
}

type WorldTotemPoolRedemptionInput struct {
	// RedemptionAll corresponds to the JSON schema field "redemptionAll".
	RedemptionAll bool `json:"redemptionAll" yaml:"redemptionAll" mapstructure:"redemptionAll"`

	// RedemptionAmount corresponds to the JSON schema field "redemptionAmount".
	RedemptionAmount string `json:"redemptionAmount" yaml:"redemptionAmount" mapstructure:"redemptionAmount"`

	// TotemNftId corresponds to the JSON schema field "totemNftId".
	TotemNftId string `json:"totemNftId" yaml:"totemNftId" mapstructure:"totemNftId"`

	// TotemOwnerId corresponds to the JSON schema field "totemOwnerId".
	TotemOwnerId string `json:"totemOwnerId" yaml:"totemOwnerId" mapstructure:"totemOwnerId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WorldTotemPoolRedemptionInput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["redemptionAll"]; raw != nil && !ok {
		return fmt.Errorf("field redemptionAll in WorldTotemPoolRedemptionInput: required")
	}
	if _, ok := raw["redemptionAmount"]; raw != nil && !ok {
		return fmt.Errorf("field redemptionAmount in WorldTotemPoolRedemptionInput: required")
	}
	if _, ok := raw["totemNftId"]; raw != nil && !ok {
		return fmt.Errorf("field totemNftId in WorldTotemPoolRedemptionInput: required")
	}
	if _, ok := raw["totemOwnerId"]; raw != nil && !ok {
		return fmt.Errorf("field totemOwnerId in WorldTotemPoolRedemptionInput: required")
	}
	type Plain WorldTotemPoolRedemptionInput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = WorldTotemPoolRedemptionInput(plain)
	return nil
}

type WorldTotemPoolRedemptionOutput struct {
	// FailedReason corresponds to the JSON schema field "failedReason".
	FailedReason string `json:"failedReason" yaml:"failedReason" mapstructure:"failedReason"`

	// Success corresponds to the JSON schema field "success".
	Success bool `json:"success" yaml:"success" mapstructure:"success"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WorldTotemPoolRedemptionOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["failedReason"]; raw != nil && !ok {
		return fmt.Errorf("field failedReason in WorldTotemPoolRedemptionOutput: required")
	}
	if _, ok := raw["success"]; raw != nil && !ok {
		return fmt.Errorf("field success in WorldTotemPoolRedemptionOutput: required")
	}
	type Plain WorldTotemPoolRedemptionOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = WorldTotemPoolRedemptionOutput(plain)
	return nil
}

type WorldTotemPoolUpdateEvent struct {
	// Pool corresponds to the JSON schema field "pool".
	Pool WorldTotemPool `json:"pool" yaml:"pool" mapstructure:"pool"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WorldTotemPoolUpdateEvent) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["pool"]; raw != nil && !ok {
		return fmt.Errorf("field pool in WorldTotemPoolUpdateEvent: required")
	}
	type Plain WorldTotemPoolUpdateEvent
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = WorldTotemPoolUpdateEvent(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WorldTotemPool) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["enhanceIncome"]; raw != nil && !ok {
		return fmt.Errorf("field enhanceIncome in WorldTotemPool: required")
	}
	if _, ok := raw["principal"]; raw != nil && !ok {
		return fmt.Errorf("field principal in WorldTotemPool: required")
	}
	if _, ok := raw["total"]; raw != nil && !ok {
		return fmt.Errorf("field total in WorldTotemPool: required")
	}
	if _, ok := raw["totemNftId"]; raw != nil && !ok {
		return fmt.Errorf("field totemNftId in WorldTotemPool: required")
	}
	if _, ok := raw["totemOwner"]; raw != nil && !ok {
		return fmt.Errorf("field totemOwner in WorldTotemPool: required")
	}
	type Plain WorldTotemPool
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = WorldTotemPool(plain)
	return nil
}
